import { Injectable, RendererFactory2, Component, ChangeDetectionStrategy, ElementRef, Input, InjectionToken, Optional, Inject, Renderer2, NgModule, TemplateRef, Directive, EventEmitter, Output, ContentChildren, ChangeDetectorRef, HostBinding, HostListener, ViewChildren, ViewChild, ContentChild, ViewContainerRef, forwardRef, Self, NgZone, LOCALE_ID } from '@angular/core';
import { CommonModule, DOCUMENT, getLocaleMonthNames, FormStyle, TranslationWidth, getLocaleDayNames, getLocaleFirstDayOfWeek } from '@angular/common';
import { __decorate } from 'tslib';
import { coerceBooleanProperty, _isNumberValue, coerceNumberProperty } from '@angular/cdk/coercion';
import { LEFT_ARROW, RIGHT_ARROW, ESCAPE, DOWN_ARROW, UP_ARROW, ENTER, PAGE_UP, PAGE_DOWN, HOME, END } from '@angular/cdk/keycodes';
import { BehaviorSubject, Subject, merge, fromEvent } from 'rxjs';
import { ConnectionPositionPair, Overlay, OverlayModule, CdkConnectedOverlay, ScrollDispatcher } from '@angular/cdk/overlay';
import { FocusTrapFactory, A11yModule, ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { ComponentPortal } from '@angular/cdk/portal';
import { map, distinctUntilChanged, mapTo, filter, flatMap, startWith, takeUntil, buffer, debounceTime, take } from 'rxjs/operators';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS, FormsModule } from '@angular/forms';
import { parse, format } from 'date-fns';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/cdk/a11y';
import * as ɵngcc3 from '@angular/cdk/overlay';
import * as ɵngcc4 from '@angular/forms';
import * as ɵngcc5 from '@angular/cdk/scrolling';

function NglIcon_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "span", 2);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.alternativeText);
} }
const _c0 = ["*"];
const _c1 = ["nglIconName", ""];
const _c2 = ["nglInternalOutlet", ""];
function NglInternalOutlet_ng_template_0_ng_template_0_Template(rf, ctx) { }
function NglInternalOutlet_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NglInternalOutlet_ng_template_0_ng_template_0_Template, 0, 0, "ng-template", 2);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.nglInternalOutlet)("ngTemplateOutletContext", ctx_r0.nglInternalOutletContext);
} }
function NglInternalOutlet_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.nglInternalOutlet);
} }
function NglAccordion_li_0_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 1);
    ɵngcc0.ɵɵlistener("toggle", function NglAccordion_li_0_Template_li_toggle_0_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r3); const section_r1 = restoredCtx.$implicit; const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.toggle(section_r1); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const section_r1 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("isActive", ctx_r0.isActive(section_r1))("section", section_r1);
} }
const _c3 = ["nglAccordionItem", ""];
function NglAccordionItem_ng_container_7_ng_template_1_Template(rf, ctx) { }
function NglAccordionItem_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NglAccordionItem_ng_container_7_ng_template_1_Template, 0, 0, "ng-template", 8);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.section.templateRef);
} }
const _c4 = function (a0) { return { $implicit: a0 }; };
function NglAlert_ngl_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-icon", 4);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("iconName", ctx_r0.iconName);
} }
function NglAlert_button_5_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "span", 0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.closeButtonAssistiveText);
} }
function NglAlert_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 5);
    ɵngcc0.ɵɵlistener("click", function NglAlert_button_5_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.close("button", $event); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 6);
    ɵngcc0.ɵɵtemplate(2, NglAlert_button_5_span_2_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.closeButtonAssistiveText);
} }
function NglAvatar_img_0_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "img", 2);
    ɵngcc0.ɵɵlistener("error", function NglAvatar_img_0_Template_img_error_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.onImgError(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("src", ctx_r0.src, ɵngcc0.ɵɵsanitizeUrl)("alt", ctx_r0.alternativeText);
} }
function NglAvatar_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "abbr", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r2.fallbackIconClass());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.initials);
} }
function NglBreadcrumbs_li_2_ng_template_1_Template(rf, ctx) { }
function NglBreadcrumbs_li_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 3);
    ɵngcc0.ɵɵtemplate(1, NglBreadcrumbs_li_2_ng_template_1_Template, 0, 0, "ng-template", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const b_r1 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", b_r1.templateRef);
} }
const _c5 = ["nglButtonIcon", ""];
function NglButtonIcon__svg_svg_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 2);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r0.iconName)("ngClass", ctx_r0.iconClass());
} }
function NglButtonIcon_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const text_r2 = ctx.ngIf;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(text_r2);
} }
const _c6 = ["nglButtonIconStateful", ""];
function NglButtonIconStateful__svg_svg_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 2);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r0.iconName);
} }
function NglButtonIconStateful_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const text_r2 = ctx.ngIf;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(text_r2);
} }
const _c7 = ["nglButton", ""];
function NglButton__svg_svg_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 2);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r0.iconName);
} }
function NglButton__svg_svg_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 3);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r1.iconName);
} }
function NglButtonStateOn__svg_svg_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 1);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r0.iconName);
} }
function NglButtonStateOff__svg_svg_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 1);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r0.iconName);
} }
function NglButtonStateHover__svg_svg_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 1);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r0.iconName);
} }
const _c8 = ["indicatorsEl"];
function NglCarousel_span_1_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 6);
    ɵngcc0.ɵɵelementStart(1, "button", 7);
    ɵngcc0.ɵɵlistener("click", function NglCarousel_span_1_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.togglePlay(); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(2, "svg", 8);
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(3, "span", 9);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("title", ctx_r0.playLabel());
    ɵngcc0.ɵɵattribute("aria-pressed", !ctx_r0.playing);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r0.playing ? "utility:pause" : "utility:right");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.playLabel());
} }
function NglCarousel_li_6_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 10);
    ɵngcc0.ɵɵelementStart(1, "a", 11);
    ɵngcc0.ɵɵlistener("click", function NglCarousel_li_6_Template_a_click_1_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r8); const i_r6 = restoredCtx.index; const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.onIndicatorClick(i_r6); });
    ɵngcc0.ɵɵelementStart(2, "span", 9);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const image_r5 = ctx.$implicit;
    const i_r6 = ctx.index;
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("isActive", ctx_r2.isActive(i_r6))("image", ctx_r2.getImage(i_r6))("title", image_r5.header);
    ɵngcc0.ɵɵattribute("aria-controls", image_r5.uid);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(image_r5.header);
} }
function NglCheckbox_abbr_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "abbr", 7);
    ɵngcc0.ɵɵtext(1, "*");
    ɵngcc0.ɵɵelementEnd();
} }
function NglCheckbox_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 8);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r1.errorId)("nglInternalOutlet", ctx_r1.error);
} }
function NglCheckboxToggle_abbr_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "abbr", 8);
    ɵngcc0.ɵɵtext(1, "*");
    ɵngcc0.ɵɵelementEnd();
} }
function NglCheckboxToggle_div_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.error);
} }
function NglCheckboxOption_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 2);
    ɵngcc0.ɵɵelement(1, "span", 3);
    ɵngcc0.ɵɵelement(2, "span", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("for", ctx_r0.input.id);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r0.label);
} }
function NglCheckboxOption_label_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 5);
    ɵngcc0.ɵɵelement(1, "span", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("for", ctx_r1.input.id);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r1.label);
} }
function NglCheckboxGroup_abbr_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "abbr", 7);
    ɵngcc0.ɵɵtext(1, "*");
    ɵngcc0.ɵɵelementEnd();
} }
function NglCheckboxGroup_div_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NglCheckboxGroup_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtemplate(1, NglCheckboxGroup_div_4_ng_container_1_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r3 = ɵngcc0.ɵɵreference(7);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r3);
} }
function NglCheckboxGroup_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 10);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r2.errorId)("nglInternalOutlet", ctx_r2.error);
} }
function NglCheckboxGroup_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function NglTabs_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 3);
    ɵngcc0.ɵɵlistener("click", function NglTabs_li_1_Template_li_click_0_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r4); const tab_r2 = restoredCtx.$implicit; const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.select(tab_r2); });
    ɵngcc0.ɵɵelement(1, "a", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r2 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("slds-is-active", tab_r2.active);
    ɵngcc0.ɵɵproperty("ngClass", "slds-tabs_" + ctx_r0.variant + "__item")("id", tab_r2.uid + "__item");
    ɵngcc0.ɵɵattribute("aria-controls", tab_r2.uid);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("nglInternalOutlet", tab_r2.label)("ngClass", "slds-tabs_" + ctx_r0.variant + "__link");
    ɵngcc0.ɵɵattribute("aria-selected", tab_r2.active)("tabindex", tab_r2.active ? 0 : -1);
} }
function NglTabs_div_2_ng_container_1_ng_template_1_Template(rf, ctx) { }
function NglTabs_div_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NglTabs_div_2_ng_container_1_ng_template_1_Template, 0, 0, "ng-template", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const tab_r5 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", tab_r5 == null ? null : tab_r5.templateRef);
} }
function NglTabs_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 5);
    ɵngcc0.ɵɵtemplate(1, NglTabs_div_2_ng_container_1_Template, 2, 1, "ng-container", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r5 = ctx.$implicit;
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", tab_r5.uid)("ngClass", ctx_r1.tabClass(tab_r5));
    ɵngcc0.ɵɵattribute("aria-labelledby", tab_r5.uid + "__item");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.lazy || tab_r5.active);
} }
const _c9 = ["ngl-popover", ""];
function NglPopover_button_0_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "span", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.closeTitle);
} }
function NglPopover_button_0_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 4);
    ɵngcc0.ɵɵlistener("click", function NglPopover_button_0_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onClose(); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 5);
    ɵngcc0.ɵɵtemplate(2, NglPopover_button_0_span_2_Template, 2, 1, "span", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("slds-button_icon-inverse", ctx_r0.inverseCloseButton);
    ɵngcc0.ɵɵproperty("title", ctx_r0.closeTitle);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.closeTitle);
} }
function NglPopover_header_1_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵelementContainer(1, 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("id", ctx_r6.labelledby);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r6.header);
} }
function NglPopover_header_1_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "h2", 13);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("id", ctx_r8.labelledby);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r8.header);
} }
function NglPopover_header_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "header", 8);
    ɵngcc0.ɵɵtemplate(1, NglPopover_header_1_div_1_Template, 2, 2, "div", 9);
    ɵngcc0.ɵɵtemplate(2, NglPopover_header_1_ng_template_2_Template, 2, 2, "ng-template", null, 10, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r7 = ɵngcc0.ɵɵreference(3);
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.isTemplateRef(ctx_r1.header))("ngIfElse", _r7);
} }
function NglPopover_footer_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "footer", 14);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r2.footer);
} }
const _c10 = ["ngl-tooltip", ""];
const _c11 = ["nglFormLabel", ""];
function NglFormLabel_abbr_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "abbr", 2);
    ɵngcc0.ɵɵtext(1, "*");
    ɵngcc0.ɵɵelementEnd();
} }
function NglColorpicker_ngl_form_help_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-form-help", 15);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("content", ctx_r0.fieldLevelHelpTooltip);
} }
function NglColorpicker__svg_svg_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 16);
} }
function NglColorpicker_p_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "p", 17);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r2.invalidColorLabel);
} }
function NglColorpicker_ng_template_12_ng_container_1_ng_template_1_Template(rf, ctx) { }
function NglColorpicker_ng_template_12_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NglColorpicker_ng_template_12_ng_container_1_ng_template_1_Template, 0, 0, "ng-template", 21);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r5 = ɵngcc0.ɵɵreference(15);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r5);
} }
function NglColorpicker_ng_template_12_ng_container_2_ng_template_1_Template(rf, ctx) { }
function NglColorpicker_ng_template_12_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NglColorpicker_ng_template_12_ng_container_2_ng_template_1_Template, 0, 0, "ng-template", 21);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r7 = ɵngcc0.ɵɵreference(17);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r7);
} }
function NglColorpicker_ng_template_12_ngl_tabset_3_ng_template_1_ng_template_0_Template(rf, ctx) { }
function NglColorpicker_ng_template_12_ngl_tabset_3_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NglColorpicker_ng_template_12_ngl_tabset_3_ng_template_1_ng_template_0_Template, 0, 0, "ng-template", 21);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(3);
    const _r5 = ɵngcc0.ɵɵreference(15);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r5);
} }
function NglColorpicker_ng_template_12_ngl_tabset_3_ng_template_2_ng_template_0_Template(rf, ctx) { }
function NglColorpicker_ng_template_12_ngl_tabset_3_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NglColorpicker_ng_template_12_ngl_tabset_3_ng_template_2_ng_template_0_Template, 0, 0, "ng-template", 21);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(3);
    const _r7 = ɵngcc0.ɵɵreference(17);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r7);
} }
function NglColorpicker_ng_template_12_ngl_tabset_3_Template(rf, ctx) { if (rf & 1) {
    const _r21 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngl-tabset", 22);
    ɵngcc0.ɵɵlistener("selectedChange", function NglColorpicker_ng_template_12_ngl_tabset_3_Template_ngl_tabset_selectedChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r21); const ctx_r20 = ɵngcc0.ɵɵnextContext(2); return ctx_r20.defaultSelectedTab = $event.id; });
    ɵngcc0.ɵɵtemplate(1, NglColorpicker_ng_template_12_ngl_tabset_3_ng_template_1_Template, 1, 1, "ng-template", 23);
    ɵngcc0.ɵɵtemplate(2, NglColorpicker_ng_template_12_ngl_tabset_3_ng_template_2_Template, 1, 1, "ng-template", 24);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r13 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("selected", ctx_r13.defaultSelectedTab);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("label", ctx_r13.swatchTabLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("label", ctx_r13.customTabLabel);
} }
function NglColorpicker_ng_template_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0, 18);
    ɵngcc0.ɵɵtemplate(1, NglColorpicker_ng_template_12_ng_container_1_Template, 2, 1, "ng-container", 19);
    ɵngcc0.ɵɵtemplate(2, NglColorpicker_ng_template_12_ng_container_2_Template, 2, 1, "ng-container", 19);
    ɵngcc0.ɵɵtemplate(3, NglColorpicker_ng_template_12_ngl_tabset_3_Template, 3, 3, "ngl-tabset", 20);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngSwitch", ctx_r4.variant);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "swatches");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "custom");
} }
function NglColorpicker_ng_template_14_Template(rf, ctx) { if (rf & 1) {
    const _r23 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngl-colorpicker-swatches", 25);
    ɵngcc0.ɵɵlistener("hexChange", function NglColorpicker_ng_template_14_Template_ngl_colorpicker_swatches_hexChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r23); const ctx_r22 = ɵngcc0.ɵɵnextContext(); return ctx_r22.onSwatchSelection($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("hex", ctx_r6.hexCurrent)("swatchColors", ctx_r6.swatchColors);
} }
function NglColorpicker_ng_template_16_Template(rf, ctx) { if (rf & 1) {
    const _r25 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngl-colorpicker-custom", 26);
    ɵngcc0.ɵɵlistener("hsvChange", function NglColorpicker_ng_template_16_Template_ngl_colorpicker_custom_hsvChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r25); const ctx_r24 = ɵngcc0.ɵɵnextContext(); return ctx_r24.onCustomSelection($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("hsv", ctx_r8.hsvCurrent);
} }
function NglColorpicker_ng_template_18_Template(rf, ctx) { if (rf & 1) {
    const _r27 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 27);
    ɵngcc0.ɵɵelementStart(1, "button", 28);
    ɵngcc0.ɵɵlistener("click", function NglColorpicker_ng_template_18_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r27); const ctx_r26 = ɵngcc0.ɵɵnextContext(); return ctx_r26.cancel(); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "button", 29);
    ɵngcc0.ɵɵlistener("click", function NglColorpicker_ng_template_18_Template_button_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r27); const ctx_r28 = ɵngcc0.ɵɵnextContext(); return ctx_r28.done(); });
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r10.cancelButtonLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("disabled", !ctx_r10.canApply());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r10.submitButtonLabel);
} }
const _c12 = ["nglColorpickerSwatch", ""];
const _c13 = ["rangeIndicator"];
const _c14 = ["rangeIndicatorContainer"];
function NglColorpickerInputs_p_25_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 13);
    ɵngcc0.ɵɵtext(1, "The color entered is invalid");
    ɵngcc0.ɵɵelementEnd();
} }
function NglColorpickerInputs_ng_template_26_p_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 13);
    ɵngcc0.ɵɵtext(1, "The value needs to be an integer from 0-255");
    ɵngcc0.ɵɵelementEnd();
} }
function NglColorpickerInputs_ng_template_26_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NglColorpickerInputs_ng_template_26_p_0_Template, 2, 0, "p", 14);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r2.isRGBValid());
} }
function NglColorpickerSwatches_li_0_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 1);
    ɵngcc0.ɵɵelementStart(1, "a", 2);
    ɵngcc0.ɵɵlistener("selectedChange", function NglColorpickerSwatches_li_0_Template_a_selectedChange_1_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r4); const color_r1 = restoredCtx.$implicit; const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.onSelect(color_r1); });
    ɵngcc0.ɵɵelement(2, "span", 3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const color_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("selected", ctx_r0.isSelected(color_r1));
    ɵngcc0.ɵɵattribute("tabindex", ctx_r0.activeIndex === i_r2 ? 0 : -1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("color", color_r1);
} }
function NglComboboxOption_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 6);
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 7);
    ɵngcc0.ɵɵelementEnd();
} }
function NglComboboxOption_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 8);
    ɵngcc0.ɵɵtext(1, "Current Selection:");
    ɵngcc0.ɵɵelementEnd();
} }
const _c15 = ["overlayOrigin"];
const _c16 = ["cdkOverlay"];
const _c17 = ["dropdown"];
function NglCombobox_div_7_ng_template_6_Template(rf, ctx) { }
function NglCombobox_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵelementStart(1, "div", 12);
    ɵngcc0.ɵɵelementStart(2, "span", 13);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(4, "div", 14);
    ɵngcc0.ɵɵelement(5, "div", 15);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, NglCombobox_div_7_ng_template_6_Template, 0, 0, "ng-template", 16);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(9);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.loadingLabel);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
} }
function NglCombobox_ng_template_8_button_0_Template(rf, ctx) { if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 18);
    ɵngcc0.ɵɵlistener("click", function NglCombobox_ng_template_8_button_0_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r11); const ctx_r10 = ɵngcc0.ɵɵnextContext(2); return ctx_r10.onClearSelection(); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 19);
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(2, "span", 13);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("title", ctx_r9.removeSelectedLabel);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r9.removeSelectedLabel);
} }
function NglCombobox_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NglCombobox_ng_template_8_button_0_Template, 4, 2, "button", 17);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    const _r4 = ɵngcc0.ɵɵreference(11);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.hasLookupSingleSelection)("ngIfElse", _r4);
} }
function NglCombobox_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 20);
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 21);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r5.inputIconRight());
} }
function NglCombobox_ng_template_12_li_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "li", 28);
} if (rf & 2) {
    const d_r16 = ctx.$implicit;
    const ctx_r13 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("value", d_r16.value)("label", d_r16.label)("disabled", d_r16.disabled)("selected", ctx_r13.isSelected(d_r16.value));
} }
function NglCombobox_ng_template_12_li_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 29);
    ɵngcc0.ɵɵelementStart(1, "div", 30);
    ɵngcc0.ɵɵelementStart(2, "div", 31);
    ɵngcc0.ɵɵelementStart(3, "div", 13);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(5, "div", 14);
    ɵngcc0.ɵɵelement(6, "div", 15);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r14.loadingLabel);
} }
function NglCombobox_ng_template_12_li_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 32);
    ɵngcc0.ɵɵelementStart(1, "div", 33);
    ɵngcc0.ɵɵelementStart(2, "span", 34);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r15.noOptionsFound);
} }
function NglCombobox_ng_template_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 22, 23);
    ɵngcc0.ɵɵlistener("mousedown", function NglCombobox_ng_template_12_Template_div_mousedown_0_listener($event) { return $event.preventDefault(); });
    ɵngcc0.ɵɵelementStart(2, "ul", 24);
    ɵngcc0.ɵɵtemplate(3, NglCombobox_ng_template_12_li_3_Template, 1, 4, "li", 25);
    ɵngcc0.ɵɵtemplate(4, NglCombobox_ng_template_12_li_4_Template, 7, 1, "li", 26);
    ɵngcc0.ɵɵtemplate(5, NglCombobox_ng_template_12_li_5_Template, 4, 1, "li", 27);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r7.dropdownClass());
    ɵngcc0.ɵɵattribute("id", ctx_r7.uid);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r7.data)("ngForTrackBy", ctx_r7.trackByOption);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.loadingMore);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.hasNoMatches());
} }
const _c18 = [[["input"]]];
const _c19 = ["input"];
const _c20 = ["ngl-datatable", ""];
function NglDatatable_th_2_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "th", 5);
    ɵngcc0.ɵɵlistener("sort", function NglDatatable_th_2_Template_th_sort_0_listener($event) { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r7); const col_r5 = restoredCtx.$implicit; const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.onColumnSort(col_r5, $event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const col_r5 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("heading", col_r5.heading)("headingTpl", col_r5.headingTpl == null ? null : col_r5.headingTpl.templateRef)("sortable", col_r5.sortable)("sortOrder", ctx_r0.getColumnSortOrder(col_r5))("ngClass", col_r5.headClass);
} }
function NglDatatable_ng_template_4_ng_template_2_Template(rf, ctx) { }
function NglDatatable_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵelementStart(1, "td");
    ɵngcc0.ɵɵtemplate(2, NglDatatable_ng_template_4_ng_template_2_Template, 0, 0, "ng-template", 6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("colspan", ctx_r2.columns.length);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2.noRowsOverlay == null ? null : ctx_r2.noRowsOverlay.templateRef);
} }
function NglDatatable_ng_container_6_tr_1_td_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 10);
} if (rf & 2) {
    const col_r13 = ctx.$implicit;
    const ctx_r14 = ɵngcc0.ɵɵnextContext();
    const d_r10 = ctx_r14.$implicit;
    const i_r11 = ctx_r14.index;
    ɵngcc0.ɵɵproperty("ngClass", col_r13.cellClass)("row", d_r10)("column", col_r13)("index", i_r11);
} }
function NglDatatable_ng_container_6_tr_1_Template(rf, ctx) { if (rf & 1) {
    const _r16 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "tr", 8);
    ɵngcc0.ɵɵlistener("click", function NglDatatable_ng_container_6_tr_1_Template_tr_click_0_listener($event) { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r16); const d_r10 = restoredCtx.$implicit; const ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.onRowClick($event, d_r10); });
    ɵngcc0.ɵɵtemplate(1, NglDatatable_ng_container_6_tr_1_td_1_Template, 1, 4, "td", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r9.columns)("ngForTrackBy", ctx_r9.columnTrackBy);
} }
function NglDatatable_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NglDatatable_ng_container_6_tr_1_Template, 2, 2, "tr", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.data)("ngForTrackBy", ctx_r3.dataTrackBy);
} }
function NglDatatable_div_7_ng_template_1_Template(rf, ctx) { }
function NglDatatable_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵtemplate(1, NglDatatable_div_7_ng_template_1_Template, 0, 0, "ng-template", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r4.loadingOverlay.templateRef);
} }
const _c21 = ["nglDatatableHead", ""];
function NglInternalDatatableHeadCell_a_0_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 2);
    ɵngcc0.ɵɵlistener("click", function NglInternalDatatableHeadCell_a_0_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.sortChange(); });
    ɵngcc0.ɵɵelementStart(1, "span", 3);
    ɵngcc0.ɵɵtext(2, "Sort by:");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div", 4);
    ɵngcc0.ɵɵelement(4, "span", 5);
    ɵngcc0.ɵɵelementStart(5, "span", 6);
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(6, "svg", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r0.header);
    ɵngcc0.ɵɵattribute("title", ctx_r0.attrTitle);
} }
function NglInternalDatatableHeadCell_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 5);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r2.header);
    ɵngcc0.ɵɵattribute("title", ctx_r2.attrTitle);
} }
const _c22 = ["nglDatatatableCell_", ""];
function NglInternalDatatableCell_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 2);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.column.cellTpl.templateRef)("ngTemplateOutletContext", ctx_r0.context);
} }
function NglInternalDatatableCell_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.value);
} }
function NglDatepickerInput_label_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "label", 8);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r0.label);
    ɵngcc0.ɵɵattribute("for", ctx_r0.uid);
} }
function NglDatepickerInput_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngl-datepicker", 9);
    ɵngcc0.ɵɵlistener("dateChange", function NglDatepickerInput_ng_template_9_Template_ngl_datepicker_dateChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.pickerSelection($event); })("nglClickOutside", function NglDatepickerInput_ng_template_9_Template_ngl_datepicker_nglClickOutside_0_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.closeCalendar(false); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵproperty("date", ctx_r4.date)("monthNames", ctx_r4.monthNames)("dayNamesShort", ctx_r4.dayNamesShort)("dayNamesLong", ctx_r4.dayNamesLong)("firstDayOfWeek", ctx_r4.firstDayOfWeek)("showToday", ctx_r4.showToday)("min", ctx_r4.min)("max", ctx_r4.max)("relativeYearFrom", ctx_r4.relativeYearFrom)("relativeYearTo", ctx_r4.relativeYearTo)("todayLabel", ctx_r4.todayLabel)("previousMonthLabel", ctx_r4.previousMonthLabel)("nextMonthLabel", ctx_r4.nextMonthLabel)("dateDisabled", ctx_r4.dateDisabled)("nglClickOutsideIgnore", _r1);
    ɵngcc0.ɵɵattribute("aria-hidden", !ctx_r4.open);
} }
const _c23 = ["nglDatepickerMonth", ""];
function NglDatepickerMonth_tr_0_td_1_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 2);
    ɵngcc0.ɵɵlistener("click", function NglDatepickerMonth_tr_0_td_1_Template_td_click_0_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r5); const date_r3 = restoredCtx.$implicit; const ctx_r4 = ɵngcc0.ɵɵnextContext(2); return ctx_r4.onSelect(date_r3); });
    ɵngcc0.ɵɵelementStart(1, "span", 3);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const date_r3 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("slds-is-today", date_r3.today);
    ɵngcc0.ɵɵproperty("isActive", date_r3.active)("nglDay", date_r3)("nglDaySelected", date_r3.selected)("nglDayDisabled", date_r3.disabled);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(date_r3.day);
} }
function NglDatepickerMonth_tr_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵtemplate(1, NglDatepickerMonth_tr_0_td_1_Template, 3, 7, "td", 1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const week_r1 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", week_r1)("ngForTrackBy", ctx_r0.dateTrackBy);
} }
function NglDatepicker_tbody_18_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "tbody", 13);
    ɵngcc0.ɵɵlistener("selectDate", function NglDatepicker_tbody_18_Template_tbody_selectDate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.select($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("year", ctx_r0.current.year)("month", ctx_r0.current.month)("day", ctx_r0.current.day)("selected", ctx_r0._date)("firstDayOfWeek", ctx_r0.firstDayOfWeek)("minDate", ctx_r0.minDate)("maxDate", ctx_r0.maxDate)("dateDisabled", ctx_r0.dateDisabled);
} }
function NglDatepicker_button_19_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 14);
    ɵngcc0.ɵɵlistener("click", function NglDatepicker_button_19_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.selectToday(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.todayLabel);
} }
const _c24 = ["nglWeekdays", ""];
function NglDatepickerWeekdays_th_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "th", 1);
    ɵngcc0.ɵɵelementStart(1, "abbr", 2);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const day_r1 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("id", day_r1.id);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("title", day_r1.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(day_r1.label);
} }
function NglDatepickerYear_option_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "option", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const yr_r1 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("value", yr_r1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(yr_r1);
} }
function NglDynamicIcon_ngl_dynamic_icon_ellie_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-dynamic-icon-ellie", 3);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("alternativeText", ctx_r0.alternativeText);
} }
function NglDynamicIcon_ngl_dynamic_icon_eq_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-dynamic-icon-eq", 4);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("option", ctx_r1.option)("alternativeText", ctx_r1.alternativeText);
} }
function NglDynamicIcon_ngl_dynamic_icon_score_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-dynamic-icon-score", 4);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("option", ctx_r2.option)("alternativeText", ctx_r2.alternativeText);
} }
function NglDynamicIcon_ngl_dynamic_icon_waffle_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-dynamic-icon-waffle", 3);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("alternativeText", ctx_r3.alternativeText);
} }
function NglDynamicIconEllie_span_42_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "span", 43);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.alternativeText);
} }
function NglDynamicIconEq_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.alternativeText);
} }
function NglDynamicIconScore_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "span", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.alternativeText);
} }
function NglDynamicIconWaffle_span_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 12);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.alternativeText);
} }
function NglFile_figcaption_2_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵelement(1, "ngl-icon", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("iconName", ctx_r1.iconName);
} }
function NglFile_figcaption_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "figcaption", 1);
    ɵngcc0.ɵɵelementStart(1, "div", 2);
    ɵngcc0.ɵɵtemplate(2, NglFile_figcaption_2_div_2_Template, 2, 1, "div", 3);
    ɵngcc0.ɵɵelementStart(3, "div", 4);
    ɵngcc0.ɵɵelement(4, "span", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.iconName);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("title", ctx_r0.text)("nglInternalOutlet", ctx_r0.text);
} }
function NglFileUpload_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 10);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r0.uid + "-primary-label")("nglInternalOutlet", ctx_r0.label);
} }
function NglFileUpload_div_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 11);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r1.uid + "-error")("nglInternalOutlet", ctx_r1.error);
} }
function NglInput_ngl_form_help_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-form-help", 4);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("content", ctx_r0.fieldLevelHelpTooltip);
} }
function NglInput_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 5);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r1.errorId)("nglInternalOutlet", ctx_r1.error);
} }
function NglModal_button_3_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "span", 13);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r6.closeButtonAssistiveText);
} }
function NglModal_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 10);
    ɵngcc0.ɵɵlistener("click", function NglModal_button_3_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.close(); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 11);
    ɵngcc0.ɵɵtemplate(2, NglModal_button_3_span_2_Template, 2, 1, "span", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.closeButtonAssistiveText);
} }
function NglModal_ng_template_4_h2_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "h2", 15);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("id", ctx_r9.headingId);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r9.header);
} }
function NglModal_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NglModal_ng_template_4_h2_0_Template, 2, 2, "h2", 14);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.header);
} }
function NglModal_6_ng_template_0_Template(rf, ctx) { }
const _c25 = function (a0) { return { id: a0 }; };
function NglModal_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NglModal_6_ng_template_0_Template, 0, 0, "ng-template", 16);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r3.headerTpl.templateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c25, ctx_r3.headingId));
} }
function NglModal_p_7_ng_template_1_Template(rf, ctx) { }
function NglModal_p_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 17);
    ɵngcc0.ɵɵtemplate(1, NglModal_p_7_ng_template_1_Template, 0, 0, "ng-template", 18);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r4.taglineTpl.templateRef);
} }
function NglModal_footer_10_ng_template_1_Template(rf, ctx) { }
function NglModal_footer_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "footer", 19);
    ɵngcc0.ɵɵtemplate(1, NglModal_footer_10_ng_template_1_Template, 0, 0, "ng-template", 18);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r5.modalFooterClass());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r5.footer.templateRef);
} }
function NglToast_ngl_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-icon", 4);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("iconName", ctx_r0.iconName);
} }
function NglToast_button_5_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "span", 0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.closeButtonAssistiveText);
} }
function NglToast_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 5);
    ɵngcc0.ɵɵlistener("click", function NglToast_button_5_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.close("button", $event); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 6);
    ɵngcc0.ɵɵtemplate(2, NglToast_button_5_span_2_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.closeButtonAssistiveText);
} }
function NglPagination_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 2);
    ɵngcc0.ɵɵlistener("click", function NglPagination_button_1_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.goto(1); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", !ctx_r0.hasPrevious());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.firstText);
} }
function NglPagination_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 4);
    ɵngcc0.ɵɵlistener("click", function NglPagination_button_4_Template_button_click_0_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r7); const page_r5 = restoredCtx.$implicit; const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.goto(page_r5.number); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const page_r5 = ctx.$implicit;
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", "slds-button_" + (page_r5.number === ctx_r1.current ? "brand" : "neutral"))("disabled", page_r5.disabled);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(page_r5.number);
} }
function NglPagination_button_7_Template(rf, ctx) { if (rf & 1) {
    const _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 2);
    ɵngcc0.ɵɵlistener("click", function NglPagination_button_7_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r9); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.goto(ctx_r8.totalPages); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", !ctx_r2.hasNext());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.lastText);
} }
function NglPill_span_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 7);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r5.pillIcon);
} }
function NglPill_span_0_ng_template_2_ngl_icon_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-icon", 10);
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("iconName", ctx_r8.icon);
} }
function NglPill_span_0_ng_template_2_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-avatar", 11);
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("src", ctx_r10.avatar);
} }
function NglPill_span_0_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NglPill_span_0_ng_template_2_ngl_icon_0_Template, 1, 1, "ngl-icon", 8);
    ɵngcc0.ɵɵtemplate(1, NglPill_span_0_ng_template_2_ng_template_1_Template, 1, 1, "ng-template", null, 9, ɵngcc0.ɵɵtemplateRefExtractor);
} if (rf & 2) {
    const _r9 = ɵngcc0.ɵɵreference(2);
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.icon)("ngIfElse", _r9);
} }
function NglPill_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 4);
    ɵngcc0.ɵɵtemplate(1, NglPill_span_0_ng_container_1_Template, 1, 1, "ng-container", 5);
    ɵngcc0.ɵɵtemplate(2, NglPill_span_0_ng_template_2_Template, 3, 2, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r6 = ɵngcc0.ɵɵreference(3);
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.isTemplateRef(ctx_r0.pillIcon))("ngIfElse", _r6);
} }
function NglPill_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function NglPill_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 12);
    ɵngcc0.ɵɵprojection(1, 1);
    ɵngcc0.ɵɵelementEnd();
} }
function NglPill_button_4_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "span", 16);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r11.removeTitle);
} }
function NglPill_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 13);
    ɵngcc0.ɵɵlistener("click", function NglPill_button_4_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); const ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onRemove($event); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 14);
    ɵngcc0.ɵɵtemplate(2, NglPill_button_4_span_2_Template, 2, 1, "span", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r4.removeTitle);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.removeTitle);
} }
const _c26 = [[["a"]], "*"];
const _c27 = ["a", "*"];
const _c28 = ["nglPillAction", ""];
function NglRadioGroup_abbr_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "abbr", 7);
    ɵngcc0.ɵɵtext(1, "*");
    ɵngcc0.ɵɵelementEnd();
} }
function NglRadioGroup_div_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NglRadioGroup_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtemplate(1, NglRadioGroup_div_4_ng_container_1_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r3 = ɵngcc0.ɵɵreference(7);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r3);
} }
function NglRadioGroup_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r2.errorId);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.error);
} }
function NglRadioGroup_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function NglRadioOption_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 2);
    ɵngcc0.ɵɵelement(1, "span", 3);
    ɵngcc0.ɵɵelement(2, "span", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("for", ctx_r0.input.id);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r0.label);
} }
function NglRadioOption_label_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 5);
    ɵngcc0.ɵɵelement(1, "span", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("for", ctx_r1.input.id);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r1.label);
} }
const _c29 = ["t"];
function NglRating_ng_template_0__svg_svg_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 4);
} if (rf & 2) {
    const fill_r3 = ɵngcc0.ɵɵnextContext().fill;
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("fill", ctx_r4.colorOn)("left", fill_r3 - 100, "%");
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r4.icon)("ngClass", ctx_r4.size ? "slds-icon_" + ctx_r4.size : "")("xPos", 100 - fill_r3 + "%");
} }
function NglRating_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 2);
    ɵngcc0.ɵɵtemplate(1, NglRating_ng_template_0__svg_svg_1_Template, 1, 7, "svg", 3);
} if (rf & 2) {
    const fill_r3 = ctx.fill;
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("fill", fill_r3 === 100 ? ctx_r1.colorOn : ctx_r1.colorOff);
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r1.icon)("ngClass", ctx_r1.size ? "slds-icon_" + ctx_r1.size : "");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", fill_r3 > 0 && fill_r3 < 100);
} }
function NglRating_div_2_ng_template_1_Template(rf, ctx) { }
const _c30 = function (a0, a1, a2) { return { $implicit: a0, index: a1, fill: a2 }; };
function NglRating_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 5);
    ɵngcc0.ɵɵlistener("click", function NglRating_div_2_Template_div_click_0_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); const r_r6 = restoredCtx.$implicit; const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.update(r_r6); })("mouseenter", function NglRating_div_2_Template_div_mouseenter_0_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); const r_r6 = restoredCtx.$implicit; const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.enter(r_r6); });
    ɵngcc0.ɵɵtemplate(1, NglRating_div_2_ng_template_1_Template, 0, 0, "ng-template", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const r_r6 = ctx.$implicit;
    const i_r7 = ctx.index;
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2._template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction3(2, _c30, r_r6 <= ctx_r2.currentRate, i_r7, ctx_r2.getFill(r_r6)));
} }
function NglExpandableSection_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 4);
    ɵngcc0.ɵɵlistener("click", function NglExpandableSection_button_1_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.toggle($event); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 5);
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(2, "span", 6);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-controls", ctx_r0.uid)("aria-expanded", ctx_r0.expanded);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("title", ctx_r0.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.title);
} }
function NglExpandableSection_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r2.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.title);
} }
function NglSelect_ngl_form_help_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-form-help", 5);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("content", ctx_r0.fieldLevelHelpTooltip);
} }
function NglSelect_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 6);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r1.errorId)("nglInternalOutlet", ctx_r1.error);
} }
function NglSlider_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 9);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r0.label);
} }
function NglSlider_div_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 10);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r1.uid + "-error")("nglInternalOutlet", ctx_r1.error);
} }
function NglSpinner_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.alternativeText);
} }
function NglTextarea_ngl_form_help_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-form-help", 5);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("content", ctx_r0.fieldLevelHelpTooltip);
} }
function NglTextarea_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r1.errorId);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.error);
} }
class HostService {
    constructor(rendererFactory2) {
        this.classMap = {};
        this.styleMap = {};
        this.renderer = rendererFactory2.createRenderer(null, null);
    }
    updateClass({ nativeElement }, classMap) {
        const newClassMap = {};
        const remove = Object.assign({}, this.classMap);
        Object.keys(classMap).filter(i => classMap[i]).forEach(i => {
            newClassMap[i] = true;
            if (!this.classMap[i]) {
                this.renderer.addClass(nativeElement, i);
            }
            if (remove[i]) {
                remove[i] = false;
            }
        });
        Object.keys(remove).filter(i => remove[i]).forEach(i => this.renderer.removeClass(nativeElement, i));
        this.classMap = newClassMap;
    }
    updateStyle({ nativeElement }, styleMap) {
        const remove = Object.assign({}, this.styleMap);
        Object.keys(styleMap).filter(i => styleMap[i]).forEach(i => {
            if (styleMap[i] !== false) {
                this.renderer.setStyle(nativeElement, i, styleMap[i]);
            }
            if (remove[i]) {
                delete remove[i];
            }
        });
        Object.keys(remove).forEach(i => this.renderer.removeStyle(nativeElement, i));
        this.styleMap = styleMap;
    }
}
HostService.ɵfac = function HostService_Factory(t) { return new (t || HostService)(ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2)); };
HostService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: HostService, factory: HostService.ɵfac });
HostService.ctorParameters = () => [
    { type: RendererFactory2 }
];

// Check if given value is integer. Cast strings as potential integers as well.
// See: http://stackoverflow.com/questions/14636536/how-to-check-if-a-variable-is-an-integer-in-javascript
function isInt(value) {
    if (isNaN(value)) {
        return false;
    }
    const x = parseFloat(value);
    // tslint:disable-next-line:no-bitwise
    return (x | 0) === x;
}
// Similar to `lodash.isobject`
function isObject(value) {
    const type = typeof value;
    return !!value && (type === 'object' || type === 'function');
}
// Generate a unique id (unique within the entire client session).
// Useful for temporary DOM ids.
let idCounter = 0;
function uniqueId(prefix = 'uid') {
    return `ngl_${prefix}_${++idCounter}`;
}
function replaceClass(instance, oldClass, newClass) {
    if (oldClass && oldClass !== newClass) {
        setClass(instance, oldClass, false);
    }
    if (newClass) {
        setClass(instance, newClass, true);
    }
}
function setClass(instance, klasses, isAdd) {
    if (klasses) {
        (Array.isArray(klasses) ? klasses : [klasses]).forEach(k => {
            instance.renderer[isAdd ? 'addClass' : 'removeClass'](instance.element.nativeElement, k);
        });
    }
}
function ngClassCombine(ngClasses, customClasses) {
    if (!ngClasses) {
        return customClasses;
    }
    // Convert string and Set to array
    if (typeof ngClasses === 'string') {
        ngClasses = ngClasses.split(/\s+/);
    }
    else if (ngClasses instanceof Set) {
        const a = [];
        ngClasses.forEach(v => a.push(v));
        ngClasses = a;
    }
    // Convert array to object
    if (Array.isArray(ngClasses)) {
        ngClasses = ngClasses.reduce((o, klass) => {
            o[klass] = true;
            return o;
        }, {});
    }
    return Object.assign(Object.assign({}, ngClasses), customClasses);
}
/**
   * Check whether value is currently selected.
   *
   * @param selection The value(s) currently selected
   * @param value The value in test, whether is (part of) selection or not
   * @param multiple Whether selections can be have multiple values
   */
function isOptionSelected(value, selection, multiple) {
    // Multiple
    if (multiple) {
        if (!selection) {
            return false;
        }
        return Array.isArray(selection) ? selection.indexOf(value) > -1 : !!selection[value];
    }
    // Single
    return value === selection;
}
function addOptionToSelection(value, selection, multiple, clearable = false) {
    let next;
    if (multiple) {
        if (!selection) {
            selection = [];
        }
        if (Array.isArray(selection)) {
            // Remove if already there or add to selection
            const index = selection.indexOf(value);
            next = index > -1
                ? [...selection.slice(0, index), ...selection.slice(index + 1)]
                : [...selection, value];
        }
        else {
            next = Object.assign({}, selection, { [value]: !selection[value] });
        }
    }
    else {
        next = selection === value && clearable ? null : value;
    }
    return next;
}
function menuItemScroll(container, domItem, scrollPadding = 4) {
    if (domItem.offsetHeight - container.scrollTop + domItem.offsetTop >=
        container.offsetHeight) {
        container.scrollTop =
            domItem.offsetHeight +
                domItem.offsetTop -
                container.offsetHeight +
                scrollPadding;
    }
    else if (domItem.offsetTop <= container.scrollTop) {
        container.scrollTop = domItem.offsetTop - scrollPadding;
    }
}
function trapEvent(event) {
    if (!event) {
        return;
    }
    event.preventDefault();
    event.stopPropagation();
}

function normalizeIconName(iconName) {
    return iconName.indexOf(':') > -1 ? iconName : `utility:${iconName}`;
}

class NglIcon {
    constructor(el, hostService) {
        this.el = el;
        this.hostService = hostService;
        /**
         * The appearance of a `utility` icon.
         */
        this.variant = 'default';
    }
    set iconName(iconName) {
        this._iconName = normalizeIconName(iconName);
    }
    get iconName() {
        return this._iconName;
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    svgClasses() {
        const [category] = this.iconName.split(':');
        const isUtility = category === 'utility';
        const isDefaultOrInverse = this.variant === 'default' || this.variant === 'inverse';
        const classes = {
            [`slds-icon_${this.size}`]: !!this.size && this.size !== 'medium',
            [`slds-icon-text-${isDefaultOrInverse ? 'default' : this.variant}`]: isDefaultOrInverse ?
                (this.variant === 'default' ? isUtility : !isUtility)
                : !!this.variant,
        };
        return ngClassCombine(this.svgClass, classes);
    }
    setHostClass() {
        const [category, icon] = this.iconName.split(':');
        const kebabCaseName = icon.replace(/_/g, '-');
        this.hostService.updateClass(this.el, {
            [`slds-icon_container`]: category !== 'utility',
            [`slds-icon_container_circle`]: category === 'action',
            [`slds-icon-${category}-${kebabCaseName}`]: category !== 'utility' && category !== 'doctype',
        });
    }
}
NglIcon.ɵfac = function NglIcon_Factory(t) { return new (t || NglIcon)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(HostService)); };
NglIcon.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglIcon, selectors: [["ngl-icon"], ["", "ngl-icon", ""]], inputs: { variant: "variant", iconName: "iconName", size: "size", alternativeText: "alternativeText", svgClass: "svgClass" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 3, vars: 3, consts: [[1, "slds-icon", 3, "nglIconName", "ngClass"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-assistive-text"]], template: function NglIcon_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "svg", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, NglIcon_span_2_Template, 2, 1, "span", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("nglIconName", ctx.iconName)("ngClass", ctx.svgClasses());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.alternativeText);
    } }, directives: function () { return [NglIconSvg, ɵngcc1.NgClass, ɵngcc1.NgIf]; }, encapsulation: 2, changeDetection: 0 });
NglIcon.ctorParameters = () => [
    { type: ElementRef },
    { type: HostService }
];
NglIcon.propDecorators = {
    iconName: [{ type: Input }],
    variant: [{ type: Input }],
    size: [{ type: Input }],
    alternativeText: [{ type: Input }],
    svgClass: [{ type: Input }]
};

/** Injection token that can be used to specify default options. */
const NGL_ICON_CONFIG = new InjectionToken('ngl-icon-config');
/**
 * Configuration service for the icons components.
 */
class NglIconConfig {
    constructor() {
        /**
         * The path to LDS assets
         */
        this.svgPath = 'assets/icons';
    }
}

class NglIconSvg {
    constructor(defaultConfig, el, renderer) {
        this.xPos = '0';
        renderer.setAttribute(el.nativeElement, 'aria-hidden', 'true');
        const config = Object.assign(Object.assign({}, new NglIconConfig()), defaultConfig);
        this.path = config.svgPath;
    }
    set iconName(iconName) {
        const [category, icon] = normalizeIconName(iconName).split(':');
        this.iconPath = `${this.path}/${category}-sprite/svg/symbols.svg#${icon}`;
    }
}
NglIconSvg.ɵfac = function NglIconSvg_Factory(t) { return new (t || NglIconSvg)(ɵngcc0.ɵɵdirectiveInject(NGL_ICON_CONFIG, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglIconSvg.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglIconSvg, selectors: [["svg", "nglIconName", ""]], inputs: { xPos: "xPos", iconName: ["nglIconName", "iconName"] }, attrs: _c1, decls: 1, vars: 2, template: function NglIconSvg_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "use");
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("href", ctx.iconPath, null, "xlink")("x", ctx.xPos);
    } }, encapsulation: 2, changeDetection: 0 });
NglIconSvg.ctorParameters = () => [
    { type: NglIconConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_ICON_CONFIG,] }] },
    { type: ElementRef },
    { type: Renderer2 }
];
NglIconSvg.propDecorators = {
    iconName: [{ type: Input, args: ['nglIconName',] }],
    xPos: [{ type: Input }]
};

const NGL_ICON_DIRECTIVES = [
    NglIcon,
    NglIconSvg,
];
class NglIconsModule {
}
NglIconsModule.ɵfac = function NglIconsModule_Factory(t) { return new (t || NglIconsModule)(); };
NglIconsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglIconsModule });
NglIconsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

class NglInternalOutlet {
    isTemplate() {
        return this.nglInternalOutlet instanceof TemplateRef;
    }
}
NglInternalOutlet.ɵfac = function NglInternalOutlet_Factory(t) { return new (t || NglInternalOutlet)(); };
NglInternalOutlet.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglInternalOutlet, selectors: [["", "nglInternalOutlet", ""]], inputs: { nglInternalOutlet: "nglInternalOutlet", nglInternalOutletContext: "nglInternalOutletContext" }, attrs: _c2, decls: 3, vars: 2, consts: [[3, "ngIf", "ngIfElse"], ["str", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function NglInternalOutlet_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglInternalOutlet_ng_template_0_Template, 1, 2, "ng-template", 0);
        ɵngcc0.ɵɵtemplate(1, NglInternalOutlet_ng_template_1_Template, 1, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isTemplate())("ngIfElse", _r1);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
NglInternalOutlet.propDecorators = {
    nglInternalOutlet: [{ type: Input }],
    nglInternalOutletContext: [{ type: Input }]
};

class NglInternalOutletModule {
}
NglInternalOutletModule.ɵfac = function NglInternalOutletModule_Factory(t) { return new (t || NglInternalOutletModule)(); };
NglInternalOutletModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglInternalOutletModule });
NglInternalOutletModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

class NglAccordionSection {
    constructor(templateRef) {
        this.templateRef = templateRef;
        /**
         * The unique name to use with the `activeName` of the accordion component.
         */
        this.name = uniqueId('accordion-section');
    }
}
NglAccordionSection.ɵfac = function NglAccordionSection_Factory(t) { return new (t || NglAccordionSection)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglAccordionSection.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglAccordionSection, selectors: [["", "nglAccordionSection", ""]], inputs: { name: "name", label: "label", labelContext: "labelContext" } });
NglAccordionSection.ctorParameters = () => [
    { type: TemplateRef }
];
NglAccordionSection.propDecorators = {
    label: [{ type: Input }],
    labelContext: [{ type: Input }],
    name: [{ type: Input }]
};

function propDecoratorFactory(name, fallback) {
    function propDecorator(target, propName) {
        const privatePropName = `$$__${propName}`;
        if (Object.prototype.hasOwnProperty.call(target, privatePropName)) {
            console.warn(`The prop "${privatePropName}" is already exist, it will be overrided by ${name} decorator.`);
        }
        Object.defineProperty(target, privatePropName, {
            configurable: true,
            writable: true
        });
        Object.defineProperty(target, propName, {
            get() {
                return this[privatePropName];
            },
            set(value) {
                this[privatePropName] = fallback(value);
            }
        });
    }
    return propDecorator;
}
function toBoolean(value) {
    return coerceBooleanProperty(value);
}
function InputBoolean() {
    return propDecoratorFactory('InputBoolean', toBoolean);
}
function toNumber(value, fallbackValue = 0) {
    return _isNumberValue(value) ? Number(value) : fallbackValue;
}
function InputNumber() {
    return propDecoratorFactory('InputNumber', toNumber);
}

class NglAccordion {
    constructor(element, renderer) {
        this.activeNameChange = new EventEmitter();
        /**
         * Whether we allow multiple sections open at a time.
         */
        this.multiple = false;
        renderer.addClass(element.nativeElement, 'slds-accordion');
    }
    toggle(section) {
        const active = addOptionToSelection(section.name, this.activeName, this.multiple, true);
        this.activeNameChange.emit(active);
    }
    isActive(section) {
        return isOptionSelected(section.name, this.activeName, this.multiple);
    }
}
NglAccordion.ɵfac = function NglAccordion_Factory(t) { return new (t || NglAccordion)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglAccordion.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglAccordion, selectors: [["ngl-accordion"], ["", "ngl-accordion", ""]], contentQueries: function NglAccordion_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglAccordionSection, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.sections = _t);
    } }, inputs: { multiple: "multiple", activeName: "activeName" }, outputs: { activeNameChange: "activeNameChange" }, decls: 1, vars: 1, consts: [["nglAccordionItem", "", 3, "isActive", "section", "toggle", 4, "ngFor", "ngForOf"], ["nglAccordionItem", "", 3, "isActive", "section", "toggle"]], template: function NglAccordion_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglAccordion_li_0_Template, 1, 2, "li", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.sections);
    } }, directives: function () { return [ɵngcc1.NgForOf, NglAccordionItem]; }, encapsulation: 2, changeDetection: 0 });
NglAccordion.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglAccordion.propDecorators = {
    activeName: [{ type: Input }],
    activeNameChange: [{ type: Output }],
    multiple: [{ type: Input }],
    sections: [{ type: ContentChildren, args: [NglAccordionSection,] }]
};
__decorate([
    InputBoolean()
], NglAccordion.prototype, "multiple", void 0);

class NglAccordionItem {
    constructor(element, renderer) {
        this.toggle = new EventEmitter();
        this.uid = uniqueId('accordion-item');
        renderer.addClass(element.nativeElement, 'slds-accordion__list-item');
    }
    onToggle() {
        this.toggle.emit();
    }
}
NglAccordionItem.ɵfac = function NglAccordionItem_Factory(t) { return new (t || NglAccordionItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglAccordionItem.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglAccordionItem, selectors: [["li", "nglAccordionItem", ""]], inputs: { isActive: "isActive", section: "section" }, outputs: { toggle: "toggle" }, attrs: _c3, decls: 8, vars: 11, consts: [[1, "slds-accordion__section"], [1, "slds-accordion__summary"], [1, "slds-accordion__summary-heading", 3, "click"], ["type", "button", 1, "slds-button", "slds-button_reset", "slds-accordion__summary-action"], ["nglIconName", "utility:switch", 1, "slds-accordion__summary-action-icon", "slds-button__icon", "slds-button__icon_left"], [1, "slds-truncate", 3, "nglInternalOutlet", "nglInternalOutletContext"], [1, "slds-accordion__content", 3, "id"], [4, "ngIf"], [3, "ngTemplateOutlet"]], template: function NglAccordionItem_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "section", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "h3", 2);
        ɵngcc0.ɵɵlistener("click", function NglAccordionItem_Template_h3_click_2_listener() { return ctx.onToggle(); });
        ɵngcc0.ɵɵelementStart(3, "button", 3);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(4, "svg", 4);
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelement(5, "span", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "div", 6);
        ɵngcc0.ɵɵtemplate(7, NglAccordionItem_ng_container_7_Template, 2, 1, "ng-container", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-is-open", ctx.isActive);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵattribute("aria-controls", ctx.uid)("aria-expanded", ctx.isActive);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.section.label)("nglInternalOutletContext", ɵngcc0.ɵɵpureFunction1(9, _c4, ctx.section.labelContext));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.uid);
        ɵngcc0.ɵɵattribute("hidden", ctx.isActive ? null : "");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isActive);
    } }, directives: [NglIconSvg, NglInternalOutlet, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
NglAccordionItem.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglAccordionItem.propDecorators = {
    isActive: [{ type: Input }],
    section: [{ type: Input }],
    toggle: [{ type: Output }]
};

const DIRECTIVES$c = [
    NglAccordion,
    NglAccordionSection,
];
class NglAccordionModule {
}
NglAccordionModule.ɵfac = function NglAccordionModule_Factory(t) { return new (t || NglAccordionModule)(); };
NglAccordionModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglAccordionModule });
NglAccordionModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglIconsModule, NglInternalOutletModule]] });

class NglCommonNotify {
    constructor(element, renderer, cd, type) {
        this.element = element;
        this.renderer = renderer;
        this.cd = cd;
        this.closeButtonAssistiveText = 'Close';
        /**
         * Triggered by close button or duration timeout.
         */
        // tslint:disable-next-line:no-output-rename
        this.closeEventEmitter = new EventEmitter();
        this.currentTimeout = null;
        this.renderer.addClass(this.element.nativeElement, 'slds-notify');
        this.renderer.addClass(this.element.nativeElement, `slds-notify_${type}`);
        this.toggleThemeClass(true, this.variant);
        this.renderer.setAttribute(this.element.nativeElement, 'role', type === 'toast' ? 'status' : 'alert');
    }
    /**
     * The type of alert.
     */
    set variant(variant) {
        this.toggleThemeClass(false, this.variant);
        this._variant = variant;
        this.toggleThemeClass(true, this.variant);
    }
    get variant() {
        return this._variant || 'info';
    }
    /**
     * The number of milliseconds after which, the close event will be triggered with an emitted reason of `'timeout'`.
     */
    set duration(duration) {
        this.clearTimeout();
        if (isInt(duration) && duration >= 0) {
            this.currentTimeout = setTimeout(() => this.close('timeout'), +duration);
        }
    }
    set dismissible(dismissible) {
        this._dismissible = dismissible;
        this.cd.markForCheck();
    }
    get dismissible() {
        return this._dismissible;
    }
    close(reason, $event) {
        this.clearTimeout();
        if ($event) {
            $event.preventDefault();
            $event.stopPropagation();
        }
        this.closeEventEmitter.emit(reason);
    }
    ngOnDestroy() {
        this.clearTimeout();
    }
    clearTimeout() {
        if (this.currentTimeout !== null) {
            clearTimeout(this.currentTimeout);
            this.currentTimeout = null;
        }
    }
    toggleThemeClass(isAdd, klass) {
        if (!klass) {
            return;
        }
        const el = this.element.nativeElement;
        this.renderer[isAdd ? 'addClass' : 'removeClass'](el, `slds-theme_${klass}`);
    }
}
NglCommonNotify.ɵfac = function NglCommonNotify_Factory(t) { return new (t || NglCommonNotify)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject('type')); };
NglCommonNotify.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglCommonNotify, inputs: { closeButtonAssistiveText: "closeButtonAssistiveText", variant: "variant", duration: "duration", iconName: "iconName", assistiveText: "assistiveText" }, outputs: { closeEventEmitter: "close" } });
NglCommonNotify.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: String, decorators: [{ type: Inject, args: ['type',] }] }
];
NglCommonNotify.propDecorators = {
    variant: [{ type: Input }],
    iconName: [{ type: Input }],
    assistiveText: [{ type: Input }],
    closeButtonAssistiveText: [{ type: Input }],
    duration: [{ type: Input }],
    closeEventEmitter: [{ type: Output, args: ['close',] }]
};

class NglAlert extends NglCommonNotify {
    constructor(element, renderer, cd) {
        super(element, renderer, cd, 'alert');
    }
}
NglAlert.ɵfac = function NglAlert_Factory(t) { return new (t || NglAlert)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglAlert.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglAlert, selectors: [["ngl-alert"]], exportAs: ["nglAlert"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 6, vars: 3, consts: [[1, "slds-assistive-text"], ["class", "slds-m-right_x-small", "size", "x-small", "variant", "", 3, "iconName", 4, "ngIf"], [1, "slds-notify__content"], ["class", "slds-button slds-button_icon slds-notify__close slds-button_icon-inverse", "type", "button", 3, "click", 4, "ngIf"], ["size", "x-small", "variant", "", 1, "slds-m-right_x-small", 3, "iconName"], ["type", "button", 1, "slds-button", "slds-button_icon", "slds-notify__close", "slds-button_icon-inverse", 3, "click"], ["nglIconName", "utility:close", 1, "slds-button__icon"], ["class", "slds-assistive-text", 4, "ngIf"]], template: function NglAlert_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NglAlert_ngl_icon_2_Template, 1, 1, "ngl-icon", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, NglAlert_button_5_Template, 3, 1, "button", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.assistiveText || ctx.variant);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconName);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.dismissible);
    } }, directives: [ɵngcc1.NgIf, NglIcon, NglIconSvg], encapsulation: 2, changeDetection: 0 });
NglAlert.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];

class NglCommonNotifyClose {
    constructor(host) {
        this.host = host;
        this.host.dismissible = true;
    }
    set dismissible(dismissible) {
        this.host.dismissible = dismissible;
    }
}
NglCommonNotifyClose.ɵfac = function NglCommonNotifyClose_Factory(t) { return new (t || NglCommonNotifyClose)(ɵngcc0.ɵɵdirectiveInject('host')); };
NglCommonNotifyClose.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglCommonNotifyClose, inputs: { dismissible: "dismissible" } });
NglCommonNotifyClose.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['host',] }] }
];
NglCommonNotifyClose.propDecorators = {
    dismissible: [{ type: Input }]
};

class NglAlertClose extends NglCommonNotifyClose {
    constructor(alert) {
        super(alert);
    }
}
NglAlertClose.ɵfac = function NglAlertClose_Factory(t) { return new (t || NglAlertClose)(ɵngcc0.ɵɵdirectiveInject(NglAlert)); };
NglAlertClose.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglAlertClose, selectors: [["ngl-alert", "close", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
NglAlertClose.ctorParameters = () => [
    { type: NglAlert }
];

const NGL_ALERT_DIRECTIVES = [
    NglAlert,
    NglAlertClose,
];
class NglAlertModule {
}
NglAlertModule.ɵfac = function NglAlertModule_Factory(t) { return new (t || NglAlertModule)(); };
NglAlertModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglAlertModule });
NglAlertModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglIconsModule]] });

class NglAvatar {
    constructor(element, renderer, hostService) {
        this.element = element;
        this.hostService = hostService;
        this.src = '';
        this.alternativeText = '';
        this.fallbackIconName = 'standard:user';
        this.error = new EventEmitter();
        this._imgError = false;
        renderer.addClass(element.nativeElement, 'slds-avatar');
    }
    fallbackIconClass() {
        const [category, icon] = this.fallbackIconName.split(':');
        return `slds-icon-${category}-${icon}`;
    }
    get shouldShowImage() {
        return this.src && !this._imgError;
    }
    onImgError() {
        this._imgError = true;
        this.error.emit();
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    setHostClass() {
        this.hostService.updateClass(this.element, {
            [`slds-avatar_${this.size || 'medium'}`]: true,
            [`slds-avatar_${this.variant || 'rectangle'}`]: true,
        });
    }
}
NglAvatar.ɵfac = function NglAvatar_Factory(t) { return new (t || NglAvatar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(HostService)); };
NglAvatar.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglAvatar, selectors: [["ngl-avatar"]], hostVars: 1, hostBindings: function NglAvatar_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("title", ctx.alternativeText);
    } }, inputs: { src: "src", alternativeText: "alternativeText", fallbackIconName: "fallbackIconName", size: "size", variant: "variant", initials: "initials" }, outputs: { error: "error" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 3, vars: 2, consts: [[3, "src", "alt", "error", 4, "ngIf", "ngIfElse"], ["template_initials", ""], [3, "src", "alt", "error"], [1, "slds-avatar__initials", 3, "ngClass"]], template: function NglAvatar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglAvatar_img_0_Template, 1, 2, "img", 0);
        ɵngcc0.ɵɵtemplate(1, NglAvatar_ng_template_1_Template, 2, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.shouldShowImage)("ngIfElse", _r1);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass], encapsulation: 2, changeDetection: 0 });
NglAvatar.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService }
];
NglAvatar.propDecorators = {
    src: [{ type: Input }],
    alternativeText: [{ type: HostBinding, args: ['attr.title',] }, { type: Input }],
    size: [{ type: Input }],
    variant: [{ type: Input }],
    initials: [{ type: Input }],
    fallbackIconName: [{ type: Input }],
    error: [{ type: Output }]
};

class NglAvatarModule {
}
NglAvatarModule.ɵfac = function NglAvatarModule_Factory(t) { return new (t || NglAvatarModule)(); };
NglAvatarModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglAvatarModule });
NglAvatarModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

class NglBadge {
}
NglBadge.ɵfac = function NglBadge_Factory(t) { return new (t || NglBadge)(); };
NglBadge.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglBadge, selectors: [["ngl-badge"]], inputs: { theme: "theme" }, ngContentSelectors: _c0, decls: 2, vars: 1, consts: [[1, "slds-badge", 3, "ngClass"]], template: function NglBadge_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.theme ? "slds-theme_" + ctx.theme : "");
    } }, directives: [ɵngcc1.NgClass], encapsulation: 2, changeDetection: 0 });
NglBadge.propDecorators = {
    theme: [{ type: Input }]
};

class NglBadgesModule {
}
NglBadgesModule.ɵfac = function NglBadgesModule_Factory(t) { return new (t || NglBadgesModule)(); };
NglBadgesModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglBadgesModule });
NglBadgesModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

class NglBreadcrumb {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NglBreadcrumb.ɵfac = function NglBreadcrumb_Factory(t) { return new (t || NglBreadcrumb)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglBreadcrumb.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglBreadcrumb, selectors: [["", "nglBreadcrumb", ""]] });
NglBreadcrumb.ctorParameters = () => [
    { type: TemplateRef }
];

class NglBreadcrumbs {
}
NglBreadcrumbs.ɵfac = function NglBreadcrumbs_Factory(t) { return new (t || NglBreadcrumbs)(); };
NglBreadcrumbs.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglBreadcrumbs, selectors: [["ngl-breadcrumbs"]], contentQueries: function NglBreadcrumbs_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglBreadcrumb, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.breadcrumbs = _t);
    } }, inputs: { assistiveText: "assistiveText" }, decls: 3, vars: 2, consts: [["role", "navigation"], [1, "slds-breadcrumb", "slds-list_horizontal", "slds-wrap"], ["class", "slds-breadcrumb__item", 4, "ngFor", "ngForOf"], [1, "slds-breadcrumb__item"], [3, "ngTemplateOutlet"]], template: function NglBreadcrumbs_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nav", 0);
        ɵngcc0.ɵɵelementStart(1, "ol", 1);
        ɵngcc0.ɵɵtemplate(2, NglBreadcrumbs_li_2_Template, 2, 1, "li", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-label", ctx.assistiveText);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.breadcrumbs);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
NglBreadcrumbs.propDecorators = {
    assistiveText: [{ type: Input }],
    breadcrumbs: [{ type: ContentChildren, args: [NglBreadcrumb,] }]
};

const NGL_BREADCRUMB_DIRECTIVES = [
    NglBreadcrumbs,
    NglBreadcrumb,
];
class NglBreadcrumbsModule {
}
NglBreadcrumbsModule.ɵfac = function NglBreadcrumbsModule_Factory(t) { return new (t || NglBreadcrumbsModule)(); };
NglBreadcrumbsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglBreadcrumbsModule });
NglBreadcrumbsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

class NglButtonIcon {
    constructor(el, hostService, renderer) {
        this.el = el;
        this.hostService = hostService;
        /**
         * The variant changes the appearance of the button
         */
        this.variant = 'border';
        renderer.addClass(this.el.nativeElement, 'slds-button');
        renderer.addClass(this.el.nativeElement, 'slds-button_icon');
    }
    get altText() {
        return this.alternativeText || this.title;
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    iconClass() {
        const hasVariant = this.hasVariant();
        const classes = {
            [`slds-button__icon_${this.size}`]: !hasVariant,
        };
        return ngClassCombine(this.svgClass, classes);
    }
    setHostClass() {
        const hasVariant = this.hasVariant();
        this.hostService.updateClass(this.el, {
            [`slds-button_icon-${this.variant}`]: hasVariant,
            [`slds-button_icon-${this.size}`]: this.size && hasVariant,
        });
    }
    hasVariant() {
        return this.variant && this.variant !== 'bare';
    }
}
NglButtonIcon.ɵfac = function NglButtonIcon_Factory(t) { return new (t || NglButtonIcon)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(HostService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglButtonIcon.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglButtonIcon, selectors: [["", "nglButtonIcon", ""]], inputs: { variant: "variant", iconName: "iconName", title: "title", alternativeText: "alternativeText", size: "size", svgClass: "svgClass" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService]), ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c5, ngContentSelectors: _c0, decls: 3, vars: 2, consts: [["class", "slds-button__icon", 3, "nglIconName", "ngClass", 4, "ngIf"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-button__icon", 3, "nglIconName", "ngClass"], [1, "slds-assistive-text"]], template: function NglButtonIcon_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NglButtonIcon__svg_svg_0_Template, 1, 2, "svg", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, NglButtonIcon_span_2_Template, 2, 1, "span", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconName);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.altText);
    } }, directives: [ɵngcc1.NgIf, NglIconSvg, ɵngcc1.NgClass], encapsulation: 2, changeDetection: 0 });
NglButtonIcon.ctorParameters = () => [
    { type: ElementRef },
    { type: HostService },
    { type: Renderer2 }
];
NglButtonIcon.propDecorators = {
    iconName: [{ type: Input }],
    title: [{ type: Input }],
    alternativeText: [{ type: Input }],
    variant: [{ type: Input }],
    size: [{ type: Input }],
    svgClass: [{ type: Input }]
};

const DEFAULT_VARIANT = 'border';
class NglButtonIconStateful {
    constructor(el, hostService, renderer) {
        this.el = el;
        this.hostService = hostService;
        /**
         * Specifies whether button is in selected state or not.
         */
        this.selected = false;
        this.selectedChange = new EventEmitter();
        /**
         * The variant changes the appearance of the button.
         */
        this.variant = DEFAULT_VARIANT;
        /**
         *  The size of the button.
         */
        this.size = null;
        renderer.addClass(this.el.nativeElement, 'slds-button');
        renderer.addClass(this.el.nativeElement, 'slds-button_icon');
    }
    get altText() {
        return this.alternativeText || this.title;
    }
    onclick() {
        this.selectedChange.emit(!this.selected);
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    setHostClass() {
        this.hostService.updateClass(this.el, {
            [`slds-button_icon-${this.variant || DEFAULT_VARIANT}`]: true,
            [`slds-button_icon-${this.size}`]: !!this.size,
        });
    }
}
NglButtonIconStateful.ɵfac = function NglButtonIconStateful_Factory(t) { return new (t || NglButtonIconStateful)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(HostService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglButtonIconStateful.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglButtonIconStateful, selectors: [["", "nglButtonIconStateful", ""]], hostVars: 3, hostBindings: function NglButtonIconStateful_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NglButtonIconStateful_click_HostBindingHandler() { return ctx.onclick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-pressed", ctx.selected);
        ɵngcc0.ɵɵclassProp("slds-is-selected", ctx.selected);
    } }, inputs: { selected: "selected", variant: "variant", size: "size", iconName: "iconName", title: "title", alternativeText: "alternativeText" }, outputs: { selectedChange: "selectedChange" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService]), ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c6, ngContentSelectors: _c0, decls: 3, vars: 2, consts: [["class", "slds-button__icon", 3, "nglIconName", 4, "ngIf"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-button__icon", 3, "nglIconName"], [1, "slds-assistive-text"]], template: function NglButtonIconStateful_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NglButtonIconStateful__svg_svg_0_Template, 1, 1, "svg", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, NglButtonIconStateful_span_2_Template, 2, 1, "span", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconName);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.altText);
    } }, directives: [ɵngcc1.NgIf, NglIconSvg], encapsulation: 2, changeDetection: 0 });
NglButtonIconStateful.ctorParameters = () => [
    { type: ElementRef },
    { type: HostService },
    { type: Renderer2 }
];
NglButtonIconStateful.propDecorators = {
    selected: [{ type: HostBinding, args: ['class.slds-is-selected',] }, { type: HostBinding, args: ['attr.aria-pressed',] }, { type: Input }],
    selectedChange: [{ type: Output }],
    iconName: [{ type: Input }],
    title: [{ type: Input }],
    alternativeText: [{ type: Input }],
    variant: [{ type: Input }],
    size: [{ type: Input }],
    onclick: [{ type: HostListener, args: ['click',] }]
};
__decorate([
    InputBoolean()
], NglButtonIconStateful.prototype, "selected", void 0);

const NGL_BUTTON_ICON_DIRECTIVES = [
    NglButtonIcon,
    NglButtonIconStateful,
];
class NglButtonIconsModule {
}
NglButtonIconsModule.ɵfac = function NglButtonIconsModule_Factory(t) { return new (t || NglButtonIconsModule)(); };
NglButtonIconsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglButtonIconsModule });
NglButtonIconsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglIconsModule]] });

class NglButton {
    constructor(el, renderer, hostService) {
        this.el = el;
        this.renderer = renderer;
        this.hostService = hostService;
        /**
         * Changes the appearance of the button.
         */
        this.variant = 'neutral';
        /**
         * Describes the position of the icon with respect to ng-content.
         */
        this.iconPosition = 'left';
        this.renderer.addClass(this.el.nativeElement, 'slds-button');
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges(changes) {
        if (changes.variant) {
            this.setHostClass();
        }
    }
    hasLeftIcon() {
        return this.iconName && (!this.iconPosition || this.iconPosition === 'left');
    }
    hasRightIcon() {
        return this.iconName && this.iconPosition === 'right';
    }
    setHostClass() {
        this.hostService.updateClass(this.el, {
            [`slds-button_${this.variant}`]: this.variant && this.variant !== 'base',
        });
    }
}
NglButton.ɵfac = function NglButton_Factory(t) { return new (t || NglButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(HostService)); };
NglButton.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglButton, selectors: [["", "nglButton", ""]], inputs: { variant: "variant", iconPosition: "iconPosition", iconName: "iconName" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService]), ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c7, ngContentSelectors: _c0, decls: 3, vars: 2, consts: [["class", "slds-button__icon slds-button__icon_left", 3, "nglIconName", 4, "ngIf"], ["class", "slds-button__icon slds-button__icon_right", 3, "nglIconName", 4, "ngIf"], [1, "slds-button__icon", "slds-button__icon_left", 3, "nglIconName"], [1, "slds-button__icon", "slds-button__icon_right", 3, "nglIconName"]], template: function NglButton_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NglButton__svg_svg_0_Template, 1, 1, "svg", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, NglButton__svg_svg_2_Template, 1, 1, "svg", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasLeftIcon());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasRightIcon());
    } }, directives: [ɵngcc1.NgIf, NglIconSvg], encapsulation: 2, changeDetection: 0 });
NglButton.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService }
];
NglButton.propDecorators = {
    variant: [{ type: Input }],
    iconName: [{ type: Input }],
    iconPosition: [{ type: Input }]
};

class NglButtonStateful {
    constructor(el, renderer, hostService) {
        this.el = el;
        this.renderer = renderer;
        this.hostService = hostService;
        /**
         * Triggered when the button is clicked.
         */
        this.stateChange = new EventEmitter();
        /**
         * Appearance.
         */
        this.variant = 'neutral';
        this.renderer.addClass(this.el.nativeElement, 'slds-button');
        this.renderer.addClass(this.el.nativeElement, 'slds-button_stateful');
        this.renderer.setAttribute(this.el.nativeElement, 'aria-live', 'assertive');
    }
    onSelectChange() {
        this.stateChange.emit(!this.state);
    }
    onFocusToggle(focused) {
        this.focused = !!+focused;
        if (!this.focused) {
            this.setHostClass();
        }
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    setHostClass() {
        this.hostService.updateClass(this.el, {
            [`slds-button_${this.variant === 'text' ? 'reset' : this.variant}`]: !!this.variant,
            [`slds-is-selected-clicked`]: this.state && this.focused,
            [`slds-is-selected`]: this.state && !this.focused,
            [`slds-not-selected`]: !this.state,
        });
    }
}
NglButtonStateful.ɵfac = function NglButtonStateful_Factory(t) { return new (t || NglButtonStateful)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(HostService)); };
NglButtonStateful.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglButtonStateful, selectors: [["", "nglButtonStateful", ""]], hostBindings: function NglButtonStateful_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NglButtonStateful_click_HostBindingHandler() { return ctx.onSelectChange(); })("focus", function NglButtonStateful_focus_HostBindingHandler() { return ctx.onFocusToggle(1); })("blur", function NglButtonStateful_blur_HostBindingHandler() { return ctx.onFocusToggle(0); });
    } }, inputs: { variant: "variant", state: "state" }, outputs: { stateChange: "stateChange" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService]), ɵngcc0.ɵɵNgOnChangesFeature] });
NglButtonStateful.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService }
];
NglButtonStateful.propDecorators = {
    state: [{ type: Input }],
    stateChange: [{ type: Output }],
    variant: [{ type: Input }],
    onSelectChange: [{ type: HostListener, args: ['click',] }],
    onFocusToggle: [{ type: HostListener, args: ['focus', ['1'],] }, { type: HostListener, args: ['blur', ['0'],] }]
};
__decorate([
    InputBoolean()
], NglButtonStateful.prototype, "state", void 0);

class NglButtonStateOn {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.renderer.addClass(this.el.nativeElement, this.getHostClass());
    }
    getHostClass() {
        return 'slds-text-selected';
    }
}
NglButtonStateOn.ɵfac = function NglButtonStateOn_Factory(t) { return new (t || NglButtonStateOn)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglButtonStateOn.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglButtonStateOn, selectors: [["ngl-state-on"]], inputs: { iconName: "iconName" }, ngContentSelectors: _c0, decls: 2, vars: 1, consts: [["class", "slds-button__icon slds-button__icon_small slds-button__icon_left", 3, "nglIconName", 4, "ngIf"], [1, "slds-button__icon", "slds-button__icon_small", "slds-button__icon_left", 3, "nglIconName"]], template: function NglButtonStateOn_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NglButtonStateOn__svg_svg_0_Template, 1, 1, "svg", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconName);
    } }, directives: [ɵngcc1.NgIf, NglIconSvg], encapsulation: 2, changeDetection: 0 });
NglButtonStateOn.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglButtonStateOn.propDecorators = {
    iconName: [{ type: Input }]
};
class NglButtonStateOff extends NglButtonStateOn {
    getHostClass() {
        return 'slds-text-not-selected';
    }
}
NglButtonStateOff.ɵfac = /*@__PURE__*/ function () { let ɵNglButtonStateOff_BaseFactory; return function NglButtonStateOff_Factory(t) { return (ɵNglButtonStateOff_BaseFactory || (ɵNglButtonStateOff_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglButtonStateOff)))(t || NglButtonStateOff); }; }();
NglButtonStateOff.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglButtonStateOff, selectors: [["ngl-state-off"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 2, vars: 1, consts: [["class", "slds-button__icon slds-button__icon_small slds-button__icon_left", 3, "nglIconName", 4, "ngIf"], [1, "slds-button__icon", "slds-button__icon_small", "slds-button__icon_left", 3, "nglIconName"]], template: function NglButtonStateOff_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NglButtonStateOff__svg_svg_0_Template, 1, 1, "svg", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconName);
    } }, directives: [ɵngcc1.NgIf, NglIconSvg], encapsulation: 2, changeDetection: 0 });
class NglButtonStateHover extends NglButtonStateOn {
    getHostClass() {
        return 'slds-text-selected-focus';
    }
}
NglButtonStateHover.ɵfac = /*@__PURE__*/ function () { let ɵNglButtonStateHover_BaseFactory; return function NglButtonStateHover_Factory(t) { return (ɵNglButtonStateHover_BaseFactory || (ɵNglButtonStateHover_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglButtonStateHover)))(t || NglButtonStateHover); }; }();
NglButtonStateHover.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglButtonStateHover, selectors: [["ngl-state-hover"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 2, vars: 1, consts: [["class", "slds-button__icon slds-button__icon_small slds-button__icon_left", 3, "nglIconName", 4, "ngIf"], [1, "slds-button__icon", "slds-button__icon_small", "slds-button__icon_left", 3, "nglIconName"]], template: function NglButtonStateHover_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NglButtonStateHover__svg_svg_0_Template, 1, 1, "svg", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconName);
    } }, directives: [ɵngcc1.NgIf, NglIconSvg], encapsulation: 2, changeDetection: 0 });

const NGL_BUTTON_DIRECTIVES = [
    NglButton,
    NglButtonStateful,
    NglButtonStateOn,
    NglButtonStateOff,
    NglButtonStateHover
];
class NglButtonsModule {
}
NglButtonsModule.ɵfac = function NglButtonsModule_Factory(t) { return new (t || NglButtonsModule)(); };
NglButtonsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglButtonsModule });
NglButtonsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglIconsModule]] });

class NglCarouselImage {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.uid = uniqueId('carousel-image');
        this.renderer.setAttribute(this.el.nativeElement, 'id', this.uid);
        this.renderer.addClass(this.el.nativeElement, 'slds-carousel__panel');
        this.renderer.setAttribute(this.el.nativeElement, 'role', 'tabpanel');
    }
    set labelledby(labelledby) {
        this.renderer.setAttribute(this.el.nativeElement, 'aria-labelledby', labelledby);
    }
    set active(active) {
        this.renderer.setAttribute(this.el.nativeElement, 'aria-hidden', `${!active}`);
    }
}
NglCarouselImage.ɵfac = function NglCarouselImage_Factory(t) { return new (t || NglCarouselImage)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglCarouselImage.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglCarouselImage, selectors: [["ngl-carousel-image"]], inputs: { src: "src", header: "header", description: "description", alternativeText: "alternativeText" }, decls: 6, vars: 5, consts: [["href", "javascript:void(0);", 1, "slds-carousel__panel-action", "slds-text-link_reset"], [1, "slds-carousel__image"], [3, "src"], [1, "slds-carousel__content"], [1, "slds-carousel__content-title", 3, "nglInternalOutlet"], [3, "nglInternalOutlet"]], template: function NglCarouselImage_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "a", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelement(2, "img", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵelement(4, "h2", 4);
        ɵngcc0.ɵɵelement(5, "p", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.active ? 0 : -1);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("src", ctx.src, ɵngcc0.ɵɵsanitizeUrl);
        ɵngcc0.ɵɵattribute("alt", ctx.alternativeText || null);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.header);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.description);
    } }, directives: [NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglCarouselImage.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglCarouselImage.propDecorators = {
    src: [{ type: Input }],
    header: [{ type: Input }],
    description: [{ type: Input }],
    alternativeText: [{ type: Input }]
};

class NglCarouselIndicator {
    constructor(el) {
        this.el = el;
        this.uid = uniqueId('carousel-indicator');
    }
    get tabindex() {
        return this.isActive ? 0 : -1;
    }
    ngOnChanges(changes) {
        this.image.active = this.isActive;
        if (changes.image) {
            this.image.labelledby = this.uid;
        }
    }
    focus() {
        this.el.nativeElement.focus();
    }
}
NglCarouselIndicator.ɵfac = function NglCarouselIndicator_Factory(t) { return new (t || NglCarouselIndicator)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NglCarouselIndicator.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglCarouselIndicator, selectors: [["", "nglCarouselIndicator", ""]], hostVars: 5, hostBindings: function NglCarouselIndicator_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.uid)("tabindex", ctx.tabindex)("aria-selected", ctx.isActive);
        ɵngcc0.ɵɵclassProp("slds-is-active", ctx.isActive);
    } }, inputs: { isActive: "isActive", image: "image" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
NglCarouselIndicator.ctorParameters = () => [
    { type: ElementRef }
];
NglCarouselIndicator.propDecorators = {
    isActive: [{ type: HostBinding, args: ['class.slds-is-active',] }, { type: HostBinding, args: ['attr.aria-selected',] }, { type: Input }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    image: [{ type: Input }],
    uid: [{ type: HostBinding, args: ['attr.id',] }]
};
__decorate([
    InputBoolean()
], NglCarouselIndicator.prototype, "isActive", void 0);

class NglCarousel {
    constructor(document) {
        this.document = document;
        this.activeChange = new EventEmitter();
        /**
         * The auto scroll duration in seconds. After that the next image is displayed.
         */
        this.scrollDuration = 5;
        /**
         * Whether auto scroll is enabled.
         */
        this.autoScroll = true;
        /**
         * Whether the carousel should continue looping from the beginning after the last item is displayed.
         */
        this.autoRefresh = true;
        this.labels = {
            startAutoPlay: 'Start auto-play',
            stopAutoPlay: 'Stop auto-play',
        };
        this.playing = true;
        this.nextTimer = null;
    }
    isActive(index) {
        return index === this.active;
    }
    getImage(index) {
        return this.images.toArray()[index];
    }
    ngOnChanges(changes) {
        if (changes.active) {
            // Focus correct indicator if one is already focused
            if (this.document && this.indicatorsEl.nativeElement.contains(document.activeElement)) {
                this.indicators.toArray()[this.active].focus();
            }
        }
        if (changes.active || changes.autoScroll || changes.scrollDuration) {
            // Reset timer when active changes
            this.setTimer();
        }
    }
    onIndicatorClick(index) {
        this.setActive(index, true);
    }
    onKeyboard(evt) {
        if (evt.keyCode === LEFT_ARROW || evt.keyCode === RIGHT_ARROW) {
            this.activateNext(evt.keyCode === LEFT_ARROW);
        }
    }
    setActive(index, stopPlaying = false) {
        if (stopPlaying) {
            this.playing = false;
        }
        if (this.active !== index) {
            this.activeChange.emit(index);
        }
    }
    togglePlay() {
        this.playing = !this.playing;
        this.setTimer();
    }
    playLabel() {
        return this.labels[this.playing ? 'stopAutoPlay' : 'startAutoPlay'];
    }
    activateNext(reverse = false) {
        const active = this.active + (reverse ? -1 : 1);
        if ((active < 0 || active > this.images.length - 1) && !this.autoRefresh) {
            return;
        }
        this.setActive((this.images.length + active) % this.images.length);
    }
    setTimer() {
        clearTimeout(this.nextTimer);
        if (this.autoScroll && this.playing) {
            this.nextTimer = setTimeout(() => {
                this.activateNext();
            }, this.scrollDuration * 1000);
        }
    }
}
NglCarousel.ɵfac = function NglCarousel_Factory(t) { return new (t || NglCarousel)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8)); };
NglCarousel.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglCarousel, selectors: [["ngl-carousel"]], contentQueries: function NglCarousel_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglCarouselImage, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.images = _t);
    } }, viewQuery: function NglCarousel_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c8, 7);
        ɵngcc0.ɵɵviewQuery(NglCarouselIndicator, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.indicatorsEl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.indicators = _t);
    } }, hostVars: 2, hostBindings: function NglCarousel_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-carousel", true);
    } }, inputs: { scrollDuration: "scrollDuration", autoScroll: "autoScroll", autoRefresh: "autoRefresh", labels: "labels", active: "active" }, outputs: { activeChange: "activeChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 7, vars: 4, consts: [[1, "slds-carousel__stage"], ["class", "slds-carousel__autoplay", 4, "ngIf"], [1, "slds-carousel__panels"], ["role", "tablist", 1, "slds-carousel__indicators", 3, "keydown"], ["indicatorsEl", ""], ["class", "slds-carousel__indicator", "role", "presentation", 4, "ngFor", "ngForOf"], [1, "slds-carousel__autoplay"], [1, "slds-button", "slds-button_icon", "slds-button_icon-border-filled", "slds-button_icon-x-small", 3, "title", "click"], [1, "slds-button__icon", 3, "nglIconName"], [1, "slds-assistive-text"], ["role", "presentation", 1, "slds-carousel__indicator"], ["nglCarouselIndicator", "", "href", "javascript:void(0);", "role", "tab", 1, "slds-carousel__indicator-action", 3, "isActive", "image", "title", "click"]], template: function NglCarousel_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, NglCarousel_span_1_Template, 5, 4, "span", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "ul", 3, 4);
        ɵngcc0.ɵɵlistener("keydown", function NglCarousel_Template_ul_keydown_4_listener($event) { return ctx.onKeyboard($event); });
        ɵngcc0.ɵɵtemplate(6, NglCarousel_li_6_Template, 4, 5, "li", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.autoScroll);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("transform", "translateX(" + -ctx.active * 100 + "%)");
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.images);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf, NglIconSvg, NglCarouselIndicator], encapsulation: 2, changeDetection: 0 });
NglCarousel.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
NglCarousel.propDecorators = {
    active: [{ type: Input }],
    activeChange: [{ type: Output }],
    scrollDuration: [{ type: Input }],
    autoScroll: [{ type: Input }],
    autoRefresh: [{ type: Input }],
    images: [{ type: ContentChildren, args: [NglCarouselImage,] }],
    indicators: [{ type: ViewChildren, args: [NglCarouselIndicator,] }],
    indicatorsEl: [{ type: ViewChild, args: ['indicatorsEl', { static: true },] }],
    labels: [{ type: Input }]
};
__decorate([
    InputNumber()
], NglCarousel.prototype, "active", void 0);
__decorate([
    InputNumber()
], NglCarousel.prototype, "scrollDuration", void 0);
__decorate([
    InputBoolean()
], NglCarousel.prototype, "autoScroll", void 0);
__decorate([
    InputBoolean()
], NglCarousel.prototype, "autoRefresh", void 0);

const DIRECTIVES$b = [
    NglCarousel,
    NglCarouselImage,
];
class NglCarouselModule {
}
NglCarouselModule.ɵfac = function NglCarouselModule_Factory(t) { return new (t || NglCarouselModule)(); };
NglCarouselModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglCarouselModule });
NglCarouselModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglIconsModule, NglInternalOutletModule]] });

class NglCheckboxInput {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.ɵRequiredSubject = new BehaviorSubject(false);
        if (!this.el.nativeElement.id) {
            this.renderer.setAttribute(this.el.nativeElement, 'id', uniqueId('checkbox'));
        }
    }
    set describedBy(value) {
        this.renderer.setAttribute(this.el.nativeElement, 'aria-describedby', value);
    }
    set required(required) {
        this.ɵRequiredSubject.next(toBoolean(required));
    }
    get id() {
        return this.el.nativeElement.id;
    }
    addClass(klass) {
        this.renderer.addClass(this.el.nativeElement, klass);
    }
}
NglCheckboxInput.ɵfac = function NglCheckboxInput_Factory(t) { return new (t || NglCheckboxInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglCheckboxInput.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglCheckboxInput, selectors: [["input", "ngl", "", "type", "checkbox"]], inputs: { required: "required" } });
NglCheckboxInput.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglCheckboxInput.propDecorators = {
    required: [{ type: Input }]
};

class NglCheckboxButton {
    constructor(cd) {
        this.cd = cd;
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <input type="checkbox"> with [ngl] attribute inside ${this}`);
        }
        this._uid = this.input.id;
        this.cd.detectChanges();
        this.input.addClass('slds-assistive-text');
    }
}
NglCheckboxButton.ɵfac = function NglCheckboxButton_Factory(t) { return new (t || NglCheckboxButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglCheckboxButton.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglCheckboxButton, selectors: [["ngl-checkbox-button"]], contentQueries: function NglCheckboxButton_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglCheckboxInput, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 2, hostBindings: function NglCheckboxButton_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-checkbox_add-button", true);
    } }, inputs: { label: "label" }, ngContentSelectors: _c0, decls: 3, vars: 2, consts: [[1, "slds-checkbox_faux"], [1, "slds-assistive-text", 3, "nglInternalOutlet"]], template: function NglCheckboxButton_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "label", 0);
        ɵngcc0.ɵɵelement(2, "span", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("for", ctx._uid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.label);
    } }, directives: [NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglCheckboxButton.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NglCheckboxButton.propDecorators = {
    input: [{ type: ContentChild, args: [NglCheckboxInput, { static: true },] }],
    label: [{ type: Input }]
};

class NglCheckbox {
    constructor(cd) {
        this.cd = cd;
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this._uid}`;
    }
    ngOnChanges() {
        this.input.describedBy = this.error ? this.errorId : null;
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <input type="checkbox"> with [ngl] attribute inside NglCheckbox`);
        }
        this.ɵRequiredSubscription = this.input.ɵRequiredSubject.subscribe((required) => {
            this.required = required;
            this.cd.detectChanges();
        });
        this._uid = this.input.id;
        this.cd.detectChanges();
    }
    ngOnDestroy() {
        if (this.ɵRequiredSubscription) {
            this.ɵRequiredSubscription.unsubscribe();
            this.ɵRequiredSubscription = null;
        }
    }
}
NglCheckbox.ɵfac = function NglCheckbox_Factory(t) { return new (t || NglCheckbox)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglCheckbox.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglCheckbox, selectors: [["ngl-checkbox"], ["", "ngl-checkbox", ""]], contentQueries: function NglCheckbox_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglCheckboxInput, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 4, hostBindings: function NglCheckbox_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-form-element", true)("slds-has-error", ctx.hasError);
    } }, inputs: { label: "label", error: "error", stacked: "stacked" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 8, vars: 6, consts: [[1, "slds-form-element__control"], [1, "slds-checkbox"], ["class", "slds-required", "title", "required", 4, "ngIf"], [1, "slds-checkbox__label"], [1, "slds-checkbox_faux"], [1, "slds-form-element__label", 3, "nglInternalOutlet"], ["class", "slds-form-element__help", 3, "id", "nglInternalOutlet", 4, "ngIf"], ["title", "required", 1, "slds-required"], [1, "slds-form-element__help", 3, "id", "nglInternalOutlet"]], template: function NglCheckbox_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵtemplate(2, NglCheckbox_abbr_2_Template, 2, 0, "abbr", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementStart(4, "label", 3);
        ɵngcc0.ɵɵelement(5, "span", 4);
        ɵngcc0.ɵɵelement(6, "span", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, NglCheckbox_div_7_Template, 1, 2, "div", 6);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("slds-checkbox_stacked", ctx.stacked);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.required);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("for", ctx._uid);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasError);
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglCheckbox.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NglCheckbox.propDecorators = {
    input: [{ type: ContentChild, args: [NglCheckboxInput, { static: true },] }],
    label: [{ type: Input }],
    error: [{ type: Input }],
    stacked: [{ type: Input }],
    hasError: [{ type: HostBinding, args: ['class.slds-has-error',] }]
};
__decorate([
    InputBoolean()
], NglCheckbox.prototype, "stacked", void 0);

class NglCheckboxToggle {
    constructor(cd) {
        this.cd = cd;
        this.enabledText = 'Enabled';
        this.disabledText = 'Disabled';
    }
    get hasError() {
        return toBoolean(this.error);
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <input type="checkbox"> with [ngl] attribute inside NglCheckboxToggle`);
        }
        this.ɵRequiredSubscription = this.input.ɵRequiredSubject.subscribe((required) => {
            this.required = required;
            this.cd.detectChanges();
        });
        this.uid = `${this.input.id}_toggle`;
        this.input.describedBy = this.uid;
        this.cd.detectChanges();
    }
    ngOnDestroy() {
        if (this.ɵRequiredSubscription) {
            this.ɵRequiredSubscription.unsubscribe();
            this.ɵRequiredSubscription = null;
        }
    }
}
NglCheckboxToggle.ɵfac = function NglCheckboxToggle_Factory(t) { return new (t || NglCheckboxToggle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglCheckboxToggle.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglCheckboxToggle, selectors: [["ngl-checkbox-toggle"]], contentQueries: function NglCheckboxToggle_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglCheckboxInput, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 4, hostBindings: function NglCheckboxToggle_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-form-element", true)("slds-has-error", ctx.hasError);
    } }, inputs: { enabledText: "enabledText", disabledText: "disabledText", label: "label", error: "error" }, ngContentSelectors: _c0, decls: 11, vars: 6, consts: [[1, "slds-checkbox_toggle", "slds-grid"], ["class", "slds-required", "title", "required", 4, "ngIf"], [1, "slds-form-element__label", "slds-m-bottom_none", 3, "nglInternalOutlet"], ["aria-live", "assertive", 1, "slds-checkbox_faux_container", 3, "id"], [1, "slds-checkbox_faux"], [1, "slds-checkbox_on"], [1, "slds-checkbox_off"], ["class", "slds-form-element__help", 4, "ngIf"], ["title", "required", 1, "slds-required"], [1, "slds-form-element__help"]], template: function NglCheckboxToggle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵtemplate(1, NglCheckboxToggle_abbr_1_Template, 2, 0, "abbr", 1);
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementStart(4, "span", 3);
        ɵngcc0.ɵɵelement(5, "span", 4);
        ɵngcc0.ɵɵelementStart(6, "span", 5);
        ɵngcc0.ɵɵtext(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "span", 6);
        ɵngcc0.ɵɵtext(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, NglCheckboxToggle_div_10_Template, 2, 1, "div", 7);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.required);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.label);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("id", ctx.uid);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.enabledText);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.disabledText);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.error);
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglCheckboxToggle.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NglCheckboxToggle.propDecorators = {
    input: [{ type: ContentChild, args: [NglCheckboxInput, { static: true },] }],
    label: [{ type: Input }],
    error: [{ type: Input }],
    enabledText: [{ type: Input }],
    disabledText: [{ type: Input }],
    hasError: [{ type: HostBinding, args: ['class.slds-has-error',] }]
};

class NglCheckboxOption {
    constructor(cd, element, hostService) {
        this.cd = cd;
        this.element = element;
        this.hostService = hostService;
    }
    set type(type) {
        this._type = type;
        this.setHostClass();
        this.cd.detectChanges();
    }
    get type() {
        return this._type;
    }
    setError(id) {
        this.input.describedBy = id;
    }
    setHostClass() {
        this.hostService.updateClass(this.element, {
            [`slds-checkbox`]: this.type === 'list',
            [`slds-button`]: this.type === 'button',
            [`slds-checkbox_button`]: this.type === 'button',
        });
    }
}
NglCheckboxOption.ɵfac = function NglCheckboxOption_Factory(t) { return new (t || NglCheckboxOption)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(HostService)); };
NglCheckboxOption.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglCheckboxOption, selectors: [["ngl-checkbox-option"]], contentQueries: function NglCheckboxOption_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglCheckboxInput, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, inputs: { label: "label" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService])], ngContentSelectors: _c0, decls: 3, vars: 2, consts: [["class", "slds-checkbox__label", 4, "ngIf"], ["class", "slds-checkbox_button__label", 4, "ngIf"], [1, "slds-checkbox__label"], [1, "slds-checkbox_faux"], [1, "slds-form-element__label", 3, "nglInternalOutlet"], [1, "slds-checkbox_button__label"], [1, "slds-checkbox_faux", 3, "nglInternalOutlet"]], template: function NglCheckboxOption_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, NglCheckboxOption_label_1_Template, 3, 2, "label", 0);
        ɵngcc0.ɵɵtemplate(2, NglCheckboxOption_label_2_Template, 2, 2, "label", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.type === "list");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.type === "button");
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglCheckboxOption.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: HostService }
];
NglCheckboxOption.propDecorators = {
    label: [{ type: Input }],
    input: [{ type: ContentChild, args: [NglCheckboxInput, { static: true },] }]
};

class NglCheckboxGroup {
    constructor() {
        this.uid = uniqueId('checkbox-group');
        this._type = 'list';
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this.uid}`;
    }
    set type(type) {
        this._type = type;
        this.updateChildrenType();
    }
    get type() {
        return this._type;
    }
    ngOnChanges(changes) {
        if (changes.error && this.options) {
            this.options.forEach((option) => {
                option.setError(this.error ? this.errorId : null);
            });
        }
    }
    ngAfterContentInit() {
        this.updateChildrenType();
    }
    updateChildrenType() {
        if (!this.options) {
            return;
        }
        this.options.forEach((option) => {
            option.type = this.type;
        });
    }
}
NglCheckboxGroup.ɵfac = function NglCheckboxGroup_Factory(t) { return new (t || NglCheckboxGroup)(); };
NglCheckboxGroup.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglCheckboxGroup, selectors: [["ngl-checkbox-group"], ["", "ngl-checkbox-group", ""]], contentQueries: function NglCheckboxGroup_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglCheckboxOption, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.options = _t);
    } }, hostVars: 4, hostBindings: function NglCheckboxGroup_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-form-element", true)("slds-has-error", ctx.hasError);
    } }, inputs: { type: "type", label: "label", error: "error", required: "required" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 8, vars: 5, consts: [[1, "slds-form-element__legend", "slds-form-element__label"], ["class", "slds-required", "title", "required", 4, "ngIf"], [3, "nglInternalOutlet"], [1, "slds-form-element__control"], ["class", "slds-checkbox_button-group", 4, "ngIf", "ngIfElse"], ["class", "slds-form-element__help", 3, "id", "nglInternalOutlet", 4, "ngIf"], ["contentTpl", ""], ["title", "required", 1, "slds-required"], [1, "slds-checkbox_button-group"], [4, "ngTemplateOutlet"], [1, "slds-form-element__help", 3, "id", "nglInternalOutlet"]], template: function NglCheckboxGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "legend", 0);
        ɵngcc0.ɵɵtemplate(1, NglCheckboxGroup_abbr_1_Template, 2, 0, "abbr", 1);
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵtemplate(4, NglCheckboxGroup_div_4_Template, 2, 1, "div", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, NglCheckboxGroup_div_5_Template, 1, 2, "div", 5);
        ɵngcc0.ɵɵtemplate(6, NglCheckboxGroup_ng_template_6_Template, 1, 0, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r3 = ɵngcc0.ɵɵreference(7);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.required);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.label);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.type === "button")("ngIfElse", _r3);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasError);
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
NglCheckboxGroup.propDecorators = {
    options: [{ type: ContentChildren, args: [NglCheckboxOption,] }],
    label: [{ type: Input }],
    error: [{ type: Input }],
    hasError: [{ type: HostBinding, args: ['class.slds-has-error',] }],
    required: [{ type: Input }],
    type: [{ type: Input }]
};
__decorate([
    InputBoolean()
], NglCheckboxGroup.prototype, "required", void 0);

const DIRECTIVES$a = [
    NglCheckboxButton,
    NglCheckbox,
    NglCheckboxToggle,
    NglCheckboxInput,
    NglCheckboxGroup,
    NglCheckboxOption,
];
class NglCheckboxesModule {
}
NglCheckboxesModule.ɵfac = function NglCheckboxesModule_Factory(t) { return new (t || NglCheckboxesModule)(); };
NglCheckboxesModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglCheckboxesModule });
NglCheckboxesModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglInternalOutletModule]] });

/*
 * <ng-template ngl-tab label="...">
 *    Content goes here...
 * </ng-template>
 */
class NglTab {
    constructor(templateRef) {
        this.templateRef = templateRef;
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.uid = uniqueId('tab');
        this._active = false;
    }
    set active(active) {
        if (active === this._active) {
            return;
        }
        this._active = active;
        if (active) {
            this.activate.emit(this);
        }
        else {
            this.deactivate.emit(this);
        }
    }
    get active() {
        return this._active;
    }
}
NglTab.ɵfac = function NglTab_Factory(t) { return new (t || NglTab)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
NglTab.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglTab, selectors: [["", "ngl-tab", ""]], inputs: { id: "id", label: "label" }, outputs: { activate: "activate", deactivate: "deactivate" }, exportAs: ["nglTab"] });
NglTab.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
NglTab.propDecorators = {
    id: [{ type: Input }],
    label: [{ type: Input }],
    activate: [{ type: Output }],
    deactivate: [{ type: Output }]
};

class NglTabs {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.selectedChange = new EventEmitter();
        /**
         * Whether every tab's content is instantiated when visible, and destroyed when hidden.
         */
        this.lazy = true;
        this.renderer.addClass(this.element.nativeElement, `slds-tabs_${this.variant}`);
    }
    set variant(variant) {
        const el = this.element.nativeElement;
        this.renderer.removeClass(el, `slds-tabs_${this.variant}`);
        this._variant = variant;
        this.renderer.addClass(el, `slds-tabs_${this.variant}`);
    }
    get variant() {
        return this._variant || 'default';
    }
    set setSelected(selected) {
        if (selected === this.selected) {
            return;
        }
        this.selected = selected;
        if (!this.tabs) {
            return;
        } // Wait for content to initialize
        this.activate();
    }
    ngAfterContentInit() {
        // Initial selection after all tabs are created
        this.activate();
        if (!this.activeTab) {
            setTimeout(() => this.select(this.tabs.first));
        }
    }
    select(tab) {
        this.selectedChange.emit(tab);
    }
    move(evt, moves) {
        evt.preventDefault();
        const tabs = this.tabs.toArray();
        const selectedIndex = tabs.indexOf(this.activeTab);
        this.select(tabs[(tabs.length + selectedIndex + moves) % tabs.length]);
    }
    tabClass(tab) {
        return `slds-tabs_${this.variant}__content slds-${tab.active ? 'show' : 'hide'}`;
    }
    trackByTab(index, tab) {
        return tab.uid;
    }
    activate() {
        if (this.activeTab) {
            this.activeTab.active = false;
        }
        this.activeTab = this.findTab();
        if (this.activeTab) {
            this.activeTab.active = true;
        }
    }
    findTab(value = this.selected) {
        if (value instanceof NglTab) {
            return value;
        }
        if (isInt(value)) {
            return this.tabs.toArray()[+value];
        }
        return this.tabs.toArray().find((t) => {
            return t.id && t.id === value;
        });
    }
}
NglTabs.ɵfac = function NglTabs_Factory(t) { return new (t || NglTabs)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglTabs.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglTabs, selectors: [["ngl-tabset"]], contentQueries: function NglTabs_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglTab, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabs = _t);
    } }, inputs: { lazy: "lazy", variant: "variant", setSelected: ["selected", "setSelected"] }, outputs: { selectedChange: "selectedChange" }, decls: 3, vars: 5, consts: [["role", "tablist", 3, "ngClass", "keydown.ArrowLeft", "keydown.ArrowRight"], ["role", "presentation", 3, "ngClass", "slds-is-active", "id", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "tabpanel", 3, "id", "ngClass", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "presentation", 3, "ngClass", "id", "click"], ["role", "tab", 3, "nglInternalOutlet", "ngClass"], ["role", "tabpanel", 3, "id", "ngClass"], [4, "ngIf"], [3, "ngTemplateOutlet"]], template: function NglTabs_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵlistener("keydown.ArrowLeft", function NglTabs_Template_ul_keydown_ArrowLeft_0_listener($event) { return ctx.move($event, -1); })("keydown.ArrowRight", function NglTabs_Template_ul_keydown_ArrowRight_0_listener($event) { return ctx.move($event, 1); });
        ɵngcc0.ɵɵtemplate(1, NglTabs_li_1_Template, 2, 9, "li", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NglTabs_div_2_Template, 2, 4, "div", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", "slds-tabs_" + ctx.variant + "__nav");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabs)("ngForTrackBy", ctx.trackByTab);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabs)("ngForTrackBy", ctx.trackByTab);
    } }, directives: [ɵngcc1.NgClass, ɵngcc1.NgForOf, NglInternalOutlet, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
NglTabs.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglTabs.propDecorators = {
    variant: [{ type: Input }],
    tabs: [{ type: ContentChildren, args: [NglTab,] }],
    setSelected: [{ type: Input, args: ['selected',] }],
    selectedChange: [{ type: Output }],
    lazy: [{ type: Input }]
};
__decorate([
    InputBoolean()
], NglTabs.prototype, "lazy", void 0);

/*
 * <ngl-tab [label="..."]>
 *    <ng-template ngl-tab-label>...</ng-template>
 *    <ng-template ngl-tab-content>
 *       Content goes here...
 *    </ng-template>
 * </ngl-tab>
 */
// tslint:disable-next-line:directive-selector
class NglTabLabel {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NglTabLabel.ɵfac = function NglTabLabel_Factory(t) { return new (t || NglTabLabel)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglTabLabel.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglTabLabel, selectors: [["", "ngl-tab-label", ""]] });
NglTabLabel.ctorParameters = () => [
    { type: TemplateRef }
];
// tslint:disable-next-line:directive-selector
class NglTabContent {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NglTabContent.ɵfac = function NglTabContent_Factory(t) { return new (t || NglTabContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglTabContent.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglTabContent, selectors: [["", "ngl-tab-content", ""]] });
NglTabContent.ctorParameters = () => [
    { type: TemplateRef }
];
class NglTabVerbose extends NglTab {
    ngAfterContentInit() {
        if (this.labelTemplate) {
            this.label = this.labelTemplate.templateRef;
        }
        this.templateRef = this.contentTemplate.templateRef;
    }
}
NglTabVerbose.ɵfac = /*@__PURE__*/ function () { let ɵNglTabVerbose_BaseFactory; return function NglTabVerbose_Factory(t) { return (ɵNglTabVerbose_BaseFactory || (ɵNglTabVerbose_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglTabVerbose)))(t || NglTabVerbose); }; }();
NglTabVerbose.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglTabVerbose, selectors: [["ngl-tab"]], contentQueries: function NglTabVerbose_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglTabContent, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglTabLabel, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.labelTemplate = _t.first);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NglTab, useExisting: NglTabVerbose }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
NglTabVerbose.propDecorators = {
    contentTemplate: [{ type: ContentChild, args: [NglTabContent,] }],
    labelTemplate: [{ type: ContentChild, args: [NglTabLabel,] }]
};

const NGL_TAB_DIRECTIVES = [
    NglTabs,
    NglTab,
    NglTabVerbose, NglTabContent, NglTabLabel,
];
class NglTabsModule {
}
NglTabsModule.ɵfac = function NglTabsModule_Factory(t) { return new (t || NglTabsModule)(); };
NglTabsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglTabsModule });
NglTabsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglInternalOutletModule]] });

const POSITION_MAP = {
    'top': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: 'center', overlayY: 'bottom' }),
        nubbin: 'bottom'
    },
    'top-left': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),
        nubbin: 'bottom-left'
    },
    'top-left-corner': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),
        nubbin: 'bottom-left-corner'
    },
    'top-right': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),
        nubbin: 'bottom-right'
    },
    'top-right-corner': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),
        nubbin: 'bottom-right-corner'
    },
    'right': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' }),
        nubbin: 'left'
    },
    'right-top': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'top' }),
        nubbin: 'left-top'
    },
    'right-top-corner': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'top' }),
        nubbin: 'left-top-corner'
    },
    'right-bottom': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'bottom' }),
        nubbin: 'left-bottom'
    },
    'right-bottom-corner': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'bottom' }),
        nubbin: 'left-bottom-corner'
    },
    'bottom': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: 'center', overlayY: 'top' }),
        nubbin: 'top'
    },
    'bottom-left': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
        nubbin: 'top-left'
    },
    'bottom-left-corner': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
        nubbin: 'top-left-corner'
    },
    'bottom-right': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),
        nubbin: 'top-right'
    },
    'bottom-right-corner': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),
        nubbin: 'top-right-corner'
    },
    'left': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' }),
        nubbin: 'right'
    },
    'left-top': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'top' }),
        nubbin: 'right-top'
    },
    'left-top-corner': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'top' }),
        nubbin: 'right-top-corner'
    },
    'left-bottom': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'bottom' }),
        nubbin: 'right-bottom'
    },
    'left-bottom-corner': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'bottom' }),
        nubbin: 'right-bottom-corner'
    }
};
const DROPDOWN_POSITION_MAP = {
    'top-left': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),
    },
    'bottom-left': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
    },
    'bottom-right': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),
    },
    'top-right': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),
    },
};
const ɵ0 = (p) => DROPDOWN_POSITION_MAP[p].position, ɵ1 = (p) => DROPDOWN_POSITION_MAP[p].position;
const DEFAULT_DROPDOWN_POSITIONS = {
    left: [`bottom-left`, `top-left`].map(ɵ0),
    right: [`bottom-right`, `top-right`].map(ɵ1),
};
const ɵ2 = (placement) => POSITION_MAP[placement].position;
const DEFAULT_TOOLTIP_POSITIONS = ['top', 'right', 'bottom', 'left'].map(ɵ2);
const DEFAULT_POPOVER_POSITIONS = DEFAULT_TOOLTIP_POSITIONS;
function getPlacementName(position, initialPlacement) {
    const keyList = ['originX', 'originY', 'overlayX', 'overlayY'];
    for (const placement in POSITION_MAP) {
        if (keyList.every(key => position.connectionPair[key] === POSITION_MAP[placement]['position'][key])) {
            if (initialPlacement && initialPlacement === `${placement}-corner`) {
                return initialPlacement;
            }
            return placement;
        }
    }
}
function getPlacementStyles(nubbin) {
    const [direction, align, corner] = nubbin.split('-');
    return {
        [direction]: '1rem',
        [align]: corner ? '-0.75rem' : (align ? '-1.5rem' : false), // space of nubbin from the edge
    };
}

function isTemplateRef(value) {
    return value instanceof TemplateRef;
}

function OnChange(callback = 'nglOnPropertyChange') {
    const cachedValueKey = Symbol();
    const isFirstChangeKey = Symbol();
    return (target, key) => {
        Object.defineProperty(target, key, {
            set: function (value) {
                // change status of "isFirstChange"
                if (this[isFirstChangeKey] === undefined) {
                    this[isFirstChangeKey] = true;
                }
                else {
                    this[isFirstChangeKey] = false;
                }
                // No operation if new value is same as old value
                if (!this[isFirstChangeKey] && this[cachedValueKey] === value) {
                    return;
                }
                const oldValue = this[cachedValueKey];
                this[cachedValueKey] = value;
                const simpleChange = {
                    firstChange: this[isFirstChangeKey],
                    previousValue: oldValue,
                    currentValue: this[cachedValueKey],
                    isFirstChange: () => this[isFirstChangeKey],
                };
                this[callback](key, this[cachedValueKey], simpleChange);
            },
            get: function () {
                return this[cachedValueKey];
            },
        });
    };
}

class NglPopover {
    constructor(hostService, element, renderer, focusTrapFactory, cd) {
        this.hostService = hostService;
        this.element = element;
        this.renderer = renderer;
        this.focusTrapFactory = focusTrapFactory;
        this.cd = cd;
        this.close = new EventEmitter();
        this.isTemplateRef = isTemplateRef;
        this.uid = uniqueId('popover');
    }
    get labelledby() {
        return this.header ? `${this.uid}-heading` : null;
    }
    get describedby() {
        return this.template ? this.uid : null;
    }
    ngOnInit() {
        this.focusTrap = this.focusTrapFactory.create(this.element.nativeElement);
        this.focusTrap.focusInitialElementWhenReady();
    }
    ngOnDestroy() {
        if (this.focusTrap) {
            this.focusTrap.destroy();
            this.focusTrap = null;
        }
    }
    nglOnPropertyChange(prop) {
        if (prop === 'size' || prop === 'popoverClass') {
            this.setHostClass();
        }
        else if (prop === 'placement') {
            this.nubbin = POSITION_MAP[this.placement].nubbin;
            this.setHostClass();
        }
        else if (prop === 'variant') {
            this.inverseCloseButton = ['walkthrough', 'feature', 'error'].indexOf(this.variant) > -1;
            this.setHostClass();
        }
    }
    markForCheck() {
        this.cd.markForCheck();
    }
    onClose() {
        this.close.emit();
    }
    setHostClass() {
        this.hostService.updateClass(this.element, ngClassCombine(this.popoverClass, {
            [`slds-nubbin_${this.nubbin}`]: true,
            [`slds-popover_${this.size}`]: !!this.size,
            [`slds-popover_walkthrough`]: this.variant === 'feature',
            [`slds-popover_${this.variant}`]: !!this.variant,
        }));
        this.hostService.updateStyle(this.element, getPlacementStyles(this.nubbin));
    }
}
NglPopover.ɵfac = function NglPopover_Factory(t) { return new (t || NglPopover)(ɵngcc0.ɵɵdirectiveInject(HostService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FocusTrapFactory), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglPopover.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglPopover, selectors: [["section", "ngl-popover", ""]], hostAttrs: ["role", "dialog"], hostVars: 4, hostBindings: function NglPopover_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-labelledby", ctx.labelledby)("aria-describedby", ctx.describedby);
        ɵngcc0.ɵɵclassProp("slds-popover", true);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([HostService])], attrs: _c9, decls: 4, vars: 5, consts: [["class", "slds-button slds-button_icon slds-button_icon-small slds-float_right slds-popover__close", 3, "title", "slds-button_icon-inverse", "click", 4, "ngIf"], ["class", "slds-popover__header", 4, "ngIf"], [1, "slds-popover__body", 3, "id", "nglInternalOutlet"], ["class", "slds-popover__footer", 3, "nglInternalOutlet", 4, "ngIf"], [1, "slds-button", "slds-button_icon", "slds-button_icon-small", "slds-float_right", "slds-popover__close", 3, "title", "click"], ["nglIconName", "close", 1, "slds-button__icon"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-assistive-text"], [1, "slds-popover__header"], [3, "id", 4, "ngIf", "ngIfElse"], ["defaultTpl", ""], [3, "id"], [3, "ngTemplateOutlet"], [1, "slds-text-heading_small", 3, "id"], [1, "slds-popover__footer", 3, "nglInternalOutlet"]], template: function NglPopover_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglPopover_button_0_Template, 3, 4, "button", 0);
        ɵngcc0.ɵɵtemplate(1, NglPopover_header_1_Template, 4, 2, "header", 1);
        ɵngcc0.ɵɵelement(2, "div", 2);
        ɵngcc0.ɵɵtemplate(3, NglPopover_footer_3_Template, 1, 1, "footer", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.canClose && ctx.closeVisible);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.header);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.uid)("nglInternalOutlet", ctx.template);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.footer);
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet, NglIconSvg, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
NglPopover.ctorParameters = () => [
    { type: HostService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: FocusTrapFactory },
    { type: ChangeDetectorRef }
];
NglPopover.propDecorators = {
    labelledby: [{ type: HostBinding, args: ['attr.aria-labelledby',] }],
    describedby: [{ type: HostBinding, args: ['attr.aria-describedby',] }]
};
__decorate([
    OnChange()
], NglPopover.prototype, "popoverClass", void 0);
__decorate([
    OnChange()
], NglPopover.prototype, "size", void 0);
__decorate([
    OnChange()
], NglPopover.prototype, "variant", void 0);
__decorate([
    OnChange()
], NglPopover.prototype, "placement", void 0);

function hasObservers(output) {
    function propDecorator(target, propName) {
        const privatePropName = `$$__${propName}`;
        if (Object.prototype.hasOwnProperty.call(target, privatePropName)) {
            console.warn(`[ng-lightning]: The prop "${privatePropName}" already exists, it will be overridden by ${propName} decorator.`);
        }
        Object.defineProperty(target, privatePropName, {
            configurable: true,
            writable: true
        });
        Object.defineProperty(target, propName, {
            get() {
                if (!(this[output] instanceof EventEmitter)) {
                    throw Error(`[ng-lightning] ${target.constructor.name}: "${output}" is not an EventEmitter`);
                }
                return this[output].observers.length > 0;
            },
            set() {
                console.warn(`[ng-lightning] ${target.constructor.name}: "${propName}" is readonly and cannot be assigned a value`);
            }
        });
    }
    return propDecorator;
}

class NglPopoverTrigger {
    constructor(element, renderer, viewContainerRef, overlay) {
        this.element = element;
        this.renderer = renderer;
        this.viewContainerRef = viewContainerRef;
        this.overlay = overlay;
        /**
         * Close button title (and assistive text).
         */
        this.closeTitle = 'Close dialog';
        /**
           * Whether or not to override the close button's visibility, if `nglPopoverOpenChange` is set.
           */
        this.closeVisible = true;
        /** Emit an event when actual popover is shown or hidden */
        this.nglPopoverOpenChange = new EventEmitter();
        /** Names of properties that should be proxy to child component. */
        this.needProxyProperties = new Set([
            'template',
            'header',
            'footer',
            'placement',
            'variant',
            'size',
            'closeTitle',
            'canClose',
            'popoverClass',
            'closeVisible',
        ]);
        this._placement = 'top';
        this.backdrop = new Subject();
        this.globalClickEventUnsubscriber = null;
        this.clickEventUnsubscriber = null;
    }
    /**
     * Position relative to host element.
     */
    set placement(_placement) {
        _placement = _placement || 'top';
        if (_placement === this._placement) {
            return;
        }
        this._placement = _placement;
        if (this.overlayRef) {
            this.updatePosition();
        }
    }
    get placement() {
        return this._placement;
    }
    /**
     * Whether the floating popover is visible.
     */
    set nglOpen(_open) {
        _open = toBoolean(_open) && (['backdrop', 'x', 'escape'].indexOf(_open) === -1);
        _open ? this.create() : this.detach();
        this._open = _open;
    }
    get nglOpen() {
        return this._open;
    }
    ngOnChanges(changes) {
        if (changes.nglOpen && !changes.nglOpen.firstChange) {
            const open = changes.nglOpen.currentValue;
            if (!toBoolean(open) || open === 'x' || open === 'escape') {
                this.element.nativeElement.focus();
            }
        }
        if (this.nglOpen) {
            this.updateProxies(changes);
            Promise.resolve().then(() => {
                if (this.overlayRef) {
                    this.overlayRef.updatePosition();
                }
            });
            this.popover.markForCheck();
        }
    }
    onclick(evt) {
        evt.preventDefault();
        this.toggle();
    }
    ngOnDestroy() {
        this.detach();
        this.close();
    }
    open() {
        if (!this.nglOpen) {
            this.nglPopoverOpenChange.emit(true);
        }
    }
    close(reason = false) {
        if (this.nglOpen) {
            this.nglPopoverOpenChange.emit(reason);
        }
    }
    toggle() {
        this.nglOpen ? this.close() : this.open();
    }
    create() {
        if (this.nglOpen) {
            return;
        }
        this.detach();
        const overlayRef = this.createOverlay();
        this.portal = this.portal || new ComponentPortal(NglPopover, this.viewContainerRef);
        this.popover = overlayRef.attach(this.portal).instance;
        this.needProxyProperties.forEach(property => this.updatePopover(property, this[property]));
        this.popover.markForCheck();
        this.clearGlobalClickTimeout();
        this.globalClickTimeout = setTimeout(() => {
            this.subscribeToClickEvents();
        });
        this.closeSubscription = this.popoverClosingActions()
            .subscribe(reason => this.close(reason));
    }
    /** Detaches the currently attached popover. */
    detach() {
        if (this.overlayRef) {
            this.overlayRef.detach();
            this.overlayRef.dispose();
            this.overlayRef = null;
        }
        this.unsubscribeFromClickEvents();
        if (this.closeSubscription) {
            this.closeSubscription.unsubscribe();
            this.closeSubscription = null;
        }
        if (this.positionChangesSubscription) {
            this.positionChangesSubscription.unsubscribe();
            this.positionChangesSubscription = null;
        }
        this.popover = null;
    }
    /** Create the overlay config and position strategy */
    createOverlay() {
        if (this.overlayRef) {
            return this.overlayRef;
        }
        // Create connected position strategy that listens for scroll events to reposition.
        const strategy = this.overlay.position()
            .flexibleConnectedTo(this.element)
            .withFlexibleDimensions(false)
            .withViewportMargin(8)
            .withPush(false);
        this.positionChangesSubscription = strategy.positionChanges
            .pipe(map(change => getPlacementName(change, this.placement)), distinctUntilChanged())
            .subscribe((placement) => {
            this.updatePosition();
            this.updatePopover('placement', placement);
            this.popover.markForCheck();
        });
        this.overlayRef = this.overlay.create({
            positionStrategy: strategy,
            scrollStrategy: this.overlay.scrollStrategies.reposition(),
        });
        this.updatePosition();
        return this.overlayRef;
    }
    /** Updates the position of the current popover. */
    updatePosition() {
        const position = this.overlayRef.getConfig().positionStrategy;
        position.withPositions([
            POSITION_MAP[this.placement].position,
            ...DEFAULT_POPOVER_POSITIONS,
        ]);
    }
    updatePopover(key, value) {
        this.popover[key] = value;
    }
    /** Set inputs of child components when this component's inputs change. */
    updateProxies(changes) {
        Object.keys(changes)
            .filter(key => this.needProxyProperties.has(key))
            .forEach(key => this.updatePopover(key, this[key]));
    }
    /** Returns a stream that emits whenever an action that should close the popover occurs. */
    popoverClosingActions() {
        const backdrop = this.backdrop.pipe(mapTo('backdrop'));
        const close = this.popover.close.pipe(mapTo('x'));
        const escape = this.overlayRef.keydownEvents().pipe(filter(event => event.keyCode === ESCAPE), mapTo('escape'));
        return merge(backdrop, close, escape);
    }
    handleGlobalClickEvent($event) {
        if ($event.$nglStop) {
            return;
        }
        this.backdrop.next();
    }
    subscribeToClickEvents() {
        this.unsubscribeFromClickEvents();
        // Prevent document listener to close it, since click happened inside
        this.clickEventUnsubscriber = this.renderer.listen(this.popover.element.nativeElement, 'click', ($event) => $event.$nglStop = true);
        this.globalClickEventUnsubscriber = this.renderer.listen('document', 'click', this.handleGlobalClickEvent.bind(this));
    }
    unsubscribeFromClickEvents() {
        if (this.clickEventUnsubscriber) {
            this.clickEventUnsubscriber();
            this.clickEventUnsubscriber = null;
        }
        if (this.globalClickEventUnsubscriber) {
            this.globalClickEventUnsubscriber();
            this.globalClickEventUnsubscriber = null;
        }
    }
    clearGlobalClickTimeout() {
        clearTimeout(this.globalClickTimeout);
    }
}
NglPopoverTrigger.ɵfac = function NglPopoverTrigger_Factory(t) { return new (t || NglPopoverTrigger)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Overlay)); };
NglPopoverTrigger.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglPopoverTrigger, selectors: [["", "nglPopover", ""]], hostBindings: function NglPopoverTrigger_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NglPopoverTrigger_click_HostBindingHandler($event) { return ctx.onclick($event); });
    } }, inputs: { closeTitle: ["nglPopoverCloseTitle", "closeTitle"], closeVisible: ["nglPopoverCloseVisible", "closeVisible"], placement: ["nglPopoverPlacement", "placement"], nglOpen: ["nglPopoverOpen", "nglOpen"], template: ["nglPopover", "template"], header: ["nglPopoverHeader", "header"], footer: ["nglPopoverFooter", "footer"], variant: ["nglPopoverVariant", "variant"], size: ["nglPopoverSize", "size"], popoverClass: ["nglPopoverClass", "popoverClass"] }, outputs: { nglPopoverOpenChange: "nglPopoverOpenChange" }, exportAs: ["nglPopover"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });
NglPopoverTrigger.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ViewContainerRef },
    { type: Overlay }
];
NglPopoverTrigger.propDecorators = {
    template: [{ type: Input, args: ['nglPopover',] }],
    header: [{ type: Input, args: ['nglPopoverHeader',] }],
    footer: [{ type: Input, args: ['nglPopoverFooter',] }],
    variant: [{ type: Input, args: ['nglPopoverVariant',] }],
    size: [{ type: Input, args: ['nglPopoverSize',] }],
    placement: [{ type: Input, args: ['nglPopoverPlacement',] }],
    nglOpen: [{ type: Input, args: ['nglPopoverOpen',] }],
    closeTitle: [{ type: Input, args: ['nglPopoverCloseTitle',] }],
    popoverClass: [{ type: Input, args: ['nglPopoverClass',] }],
    closeVisible: [{ type: Input, args: ['nglPopoverCloseVisible',] }],
    nglPopoverOpenChange: [{ type: Output }],
    onclick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
__decorate([
    InputBoolean()
], NglPopoverTrigger.prototype, "closeVisible", void 0);
__decorate([
    hasObservers('nglPopoverOpenChange')
], NglPopoverTrigger.prototype, "canClose", void 0);

const NGL_POPOVER_DIRECTIVES = [
    NglPopover,
    NglPopoverTrigger,
];
class NglPopoversModule {
}
NglPopoversModule.ɵfac = function NglPopoversModule_Factory(t) { return new (t || NglPopoversModule)(); };
NglPopoversModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglPopoversModule });
NglPopoversModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, OverlayModule, A11yModule, NglInternalOutletModule, NglIconsModule]] });

class NglTooltip {
    constructor(element, renderer, hostService, cd) {
        this.element = element;
        this.renderer = renderer;
        this.hostService = hostService;
        this.cd = cd;
        this.renderer.addClass(this.element.nativeElement, 'slds-popover');
        this.renderer.addClass(this.element.nativeElement, 'slds-popover_tooltip');
        this.renderer.setAttribute(this.element.nativeElement, 'role', 'tooltip');
    }
    nglOnPropertyChange(prop) {
        if (prop === 'uid') {
            this.renderer.setAttribute(this.element.nativeElement, 'id', this.uid);
        }
        else if (prop === 'placement') {
            this.nubbin = POSITION_MAP[this.placement].nubbin;
            this.setHostClass();
        }
        else if (prop === 'template') {
            this.cd.markForCheck();
        }
        else if (prop === 'tooltipClass') {
            this.setHostClass();
        }
    }
    setHostClass() {
        this.hostService.updateClass(this.element, ngClassCombine(this.tooltipClass, {
            [`slds-nubbin_${this.nubbin}`]: true,
        }));
        this.hostService.updateStyle(this.element, getPlacementStyles(this.nubbin));
    }
}
NglTooltip.ɵfac = function NglTooltip_Factory(t) { return new (t || NglTooltip)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(HostService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglTooltip.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglTooltip, selectors: [["div", "ngl-tooltip", ""]], features: [ɵngcc0.ɵɵProvidersFeature([HostService])], attrs: _c10, decls: 1, vars: 1, consts: [[1, "slds-popover__body", 3, "nglInternalOutlet"]], template: function NglTooltip_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.template);
    } }, directives: [NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglTooltip.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService },
    { type: ChangeDetectorRef }
];
__decorate([
    OnChange()
], NglTooltip.prototype, "template", void 0);
__decorate([
    OnChange()
], NglTooltip.prototype, "placement", void 0);
__decorate([
    OnChange()
], NglTooltip.prototype, "uid", void 0);
__decorate([
    OnChange()
], NglTooltip.prototype, "tooltipClass", void 0);

/** Injection token that can be used to specify default options. */
const NGL_TOOLTIP_CONFIG = new InjectionToken('ngl-tooltip-config');
class NglTooltipConfig {
    constructor() {
        /**
         * Default position relative to host element.
         */
        this.placement = 'top';
        /**
         * Whether you can interact with the content of the tooltip.
         */
        this.interactive = false;
        /**
         * Whether tooltip will open/close without two-way binding input.
         */
        this.openAuto = false;
        /**
         * Delay in milliseconds until it opens/closes.
         */
        this.delay = 0;
    }
}

class NglTooltipTrigger {
    constructor(defaultConfig, element, renderer, viewContainerRef, overlay) {
        this.element = element;
        this.renderer = renderer;
        this.viewContainerRef = viewContainerRef;
        this.overlay = overlay;
        /**
         * Emit an event when actual tooltip is shown or hidden.
         */
        this.nglTooltipOpenChange = new EventEmitter();
        this.uid = uniqueId('tooltip');
        /** Names of properties that should be proxy to child component. */
        this.needProxyProperties = new Set([
            'template',
            'placement',
            'uid',
            'tooltipClass',
        ]);
        this.openDelay = 0;
        this.closeDelay = 0;
        this.toggleTimeout = null;
        this.overlayListeners = new Set();
        this.config = Object.assign(Object.assign({}, new NglTooltipConfig()), defaultConfig);
        this.openAuto = this.config.openAuto;
        this.interactive = this.config.interactive;
        this.delay = this.config.delay;
        this.renderer.setAttribute(this.element.nativeElement, 'aria-describedby', this.uid);
    }
    /**
     * Position relative to host element.
     */
    set placement(placement) {
        if (placement === this.placement) {
            return;
        }
        this._placement = placement;
        if (this.overlayRef) {
            this.updatePosition();
        }
    }
    get placement() {
        return this._placement || this.config.placement;
    }
    /**
     * Delay in milliseconds until it opens/closes.
     */
    set delay(_delay) {
        const delay = Array.isArray(_delay) ? _delay : [_delay, _delay];
        [this.openDelay, this.closeDelay] = delay.map(Number);
    }
    /**
     * Whether the floating tooltip is visible.
     */
    set nglOpen(open) {
        if (open === this.nglOpen) {
            return;
        }
        open ? this.create() : this.detach();
        this._open = open;
    }
    get nglOpen() {
        return this._open;
    }
    ngOnChanges(changes) {
        if (this.nglOpen) {
            this.updateProxies(changes);
            Promise.resolve().then(() => {
                if (this.overlayRef) {
                    this.overlayRef.updatePosition();
                }
            });
        }
    }
    onMouseOver() {
        this.open();
    }
    onMouseOut() {
        this.close();
        if (this.overlayRef && !this.overlayElement && this.interactive) {
            this.overlayElement = this.overlayRef.overlayElement;
            this.overlayListeners.add(this.renderer.listen(this.overlayElement, 'mouseenter', () => this.open()));
            this.overlayListeners.add(this.renderer.listen(this.overlayElement, 'mouseleave', () => this.close()));
        }
    }
    ngOnDestroy() {
        this.detach();
        this.close(0);
    }
    // Expose open method
    open(delay = this.openDelay) {
        this.handle(true, delay);
    }
    // Expose close method
    close(delay = this.closeDelay) {
        this.handle(false, delay);
    }
    // Expose toggle method
    toggle() {
        this.nglOpen ? this.close(0) : this.open(0);
    }
    handle(open, delay) {
        if (this.toggleTimeout !== null) {
            clearTimeout(this.toggleTimeout);
            this.toggleTimeout = null;
        }
        if (open !== this.nglOpen) {
            if (delay > 0) {
                this.toggleTimeout = setTimeout(() => {
                    this.toggleTimeout = null;
                    this.emitOpen(open);
                }, delay);
            }
            else {
                this.emitOpen(open);
            }
        }
    }
    emitOpen(open) {
        if (this.openAuto) {
            this.nglOpen = open;
        }
        this.nglTooltipOpenChange.emit(open);
    }
    create() {
        if (this.nglOpen) {
            return;
        }
        this.detach();
        const overlayRef = this.createOverlay();
        this.portal = this.portal || new ComponentPortal(NglTooltip, this.viewContainerRef);
        this.tooltip = overlayRef.attach(this.portal).instance;
        this.needProxyProperties.forEach(property => this.updateTooltip(property, this[property]));
    }
    /** Detaches the currently-attached tooltip. */
    detach() {
        if (this.overlayRef) {
            this.overlayRef.detach();
            this.overlayRef.dispose();
            this.overlayRef = null;
        }
        // Clean up the event listeners
        this.overlayListeners.forEach((unlisten) => unlisten());
        this.overlayListeners.clear();
        // Clear the overlay reference used for interactive mode
        if (this.interactive) {
            this.overlayElement = null;
        }
        if (this.positionChangesSubscription) {
            this.positionChangesSubscription.unsubscribe();
            this.positionChangesSubscription = null;
        }
        this.tooltip = null;
    }
    /** Create the overlay config and position strategy */
    createOverlay() {
        if (this.overlayRef) {
            return this.overlayRef;
        }
        // Create connected position strategy that listens for scroll events to reposition.
        const strategy = this.overlay.position()
            .flexibleConnectedTo(this.element)
            .withFlexibleDimensions(false)
            .withViewportMargin(8)
            .withPush(false);
        this.positionChangesSubscription = strategy.positionChanges
            .pipe(map(change => getPlacementName(change, this.placement)), distinctUntilChanged())
            .subscribe((placement) => {
            this.updatePosition();
            this.updateTooltip('placement', placement);
        });
        this.overlayRef = this.overlay.create({
            positionStrategy: strategy,
            scrollStrategy: this.overlay.scrollStrategies.reposition(),
        });
        this.updatePosition();
        return this.overlayRef;
    }
    /** Updates the position of the current tooltip. */
    updatePosition() {
        const position = this.overlayRef.getConfig().positionStrategy;
        position.withPositions([
            POSITION_MAP[this.placement].position,
            ...DEFAULT_TOOLTIP_POSITIONS,
        ]);
    }
    updateTooltip(key, value) {
        this.tooltip[key] = value;
    }
    /**
     * Set inputs of child components when this component's inputs change.
     */
    updateProxies(changes) {
        Object.keys(changes)
            .filter(key => this.needProxyProperties.has(key))
            .forEach(key => this.updateTooltip(key, this[key]));
    }
}
NglTooltipTrigger.ɵfac = function NglTooltipTrigger_Factory(t) { return new (t || NglTooltipTrigger)(ɵngcc0.ɵɵdirectiveInject(NGL_TOOLTIP_CONFIG, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Overlay)); };
NglTooltipTrigger.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglTooltipTrigger, selectors: [["", "nglTooltip", ""]], hostBindings: function NglTooltipTrigger_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function NglTooltipTrigger_mouseenter_HostBindingHandler() { return ctx.onMouseOver(); })("focus", function NglTooltipTrigger_focus_HostBindingHandler() { return ctx.onMouseOver(); })("mouseleave", function NglTooltipTrigger_mouseleave_HostBindingHandler() { return ctx.onMouseOut(); })("blur", function NglTooltipTrigger_blur_HostBindingHandler() { return ctx.onMouseOut(); });
    } }, inputs: { openAuto: ["nglTooltipOpenAuto", "openAuto"], interactive: ["nglTooltipInteractive", "interactive"], delay: ["nglTooltipDelay", "delay"], placement: ["nglTooltipPlacement", "placement"], nglOpen: ["nglTooltipOpen", "nglOpen"], template: ["nglTooltip", "template"], tooltipClass: ["nglTooltipClass", "tooltipClass"] }, outputs: { nglTooltipOpenChange: "nglTooltipOpenChange" }, exportAs: ["nglTooltip"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });
NglTooltipTrigger.ctorParameters = () => [
    { type: NglTooltipConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_TOOLTIP_CONFIG,] }] },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ViewContainerRef },
    { type: Overlay }
];
NglTooltipTrigger.propDecorators = {
    template: [{ type: Input, args: ['nglTooltip',] }],
    placement: [{ type: Input, args: ['nglTooltipPlacement',] }],
    delay: [{ type: Input, args: ['nglTooltipDelay',] }],
    nglOpen: [{ type: Input, args: ['nglTooltipOpen',] }],
    openAuto: [{ type: Input, args: ['nglTooltipOpenAuto',] }],
    interactive: [{ type: Input, args: ['nglTooltipInteractive',] }],
    tooltipClass: [{ type: Input, args: ['nglTooltipClass',] }],
    nglTooltipOpenChange: [{ type: Output }],
    onMouseOver: [{ type: HostListener, args: ['mouseenter',] }, { type: HostListener, args: ['focus',] }],
    onMouseOut: [{ type: HostListener, args: ['mouseleave',] }, { type: HostListener, args: ['blur',] }]
};
__decorate([
    InputBoolean()
], NglTooltipTrigger.prototype, "openAuto", void 0);
__decorate([
    InputBoolean()
], NglTooltipTrigger.prototype, "interactive", void 0);

class NglTooltipsModule {
}
NglTooltipsModule.ɵfac = function NglTooltipsModule_Factory(t) { return new (t || NglTooltipsModule)(); };
NglTooltipsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglTooltipsModule });
NglTooltipsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, OverlayModule, A11yModule, NglInternalOutletModule]] });

class NglFormLabel {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.klass = 'slds-form-element__label';
    }
    ngOnInit() {
        this.renderer.addClass(this.element.nativeElement, this.klass);
    }
}
NglFormLabel.ɵfac = function NglFormLabel_Factory(t) { return new (t || NglFormLabel)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglFormLabel.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglFormLabel, selectors: [["label", "nglFormLabel", ""]], inputs: { klass: ["nglFormLabelClass", "klass"], label: ["nglFormLabel", "label"], required: "required" }, attrs: _c11, ngContentSelectors: _c0, decls: 3, vars: 2, consts: [["class", "slds-required", "title", "Required", 4, "ngIf"], [3, "nglInternalOutlet"], ["title", "Required", 1, "slds-required"]], template: function NglFormLabel_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NglFormLabel_abbr_0_Template, 2, 0, "abbr", 0);
        ɵngcc0.ɵɵelement(1, "span", 1);
        ɵngcc0.ɵɵprojection(2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.required);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.label);
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglFormLabel.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglFormLabel.propDecorators = {
    label: [{ type: Input, args: ['nglFormLabel',] }],
    klass: [{ type: Input, args: ['nglFormLabelClass',] }],
    required: [{ type: Input }]
};
__decorate([
    InputBoolean()
], NglFormLabel.prototype, "required", void 0);

class NglFormHelp {
    constructor() {
        this.isOpen = false;
    }
}
NglFormHelp.ɵfac = function NglFormHelp_Factory(t) { return new (t || NglFormHelp)(); };
NglFormHelp.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglFormHelp, selectors: [["ngl-form-help"]], hostVars: 2, hostBindings: function NglFormHelp_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-form-element__icon", true);
    } }, inputs: { content: "content" }, decls: 4, vars: 2, consts: [[1, "slds-button", "slds-button_icon", 3, "nglTooltip", "nglTooltipOpen", "nglTooltipOpenChange"], ["nglIconName", "utility:info", 1, "slds-button__icon"], [1, "slds-assistive-text"]], template: function NglFormHelp_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("nglTooltipOpenChange", function NglFormHelp_Template_button_nglTooltipOpenChange_0_listener($event) { return ctx.isOpen = $event; });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(1, "svg", 1);
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(2, "span", 2);
        ɵngcc0.ɵɵtext(3, "Help");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("nglTooltip", ctx.content)("nglTooltipOpen", ctx.isOpen);
    } }, directives: [NglTooltipTrigger, NglIconSvg], encapsulation: 2, changeDetection: 0 });
NglFormHelp.propDecorators = {
    content: [{ type: Input }]
};

const DIRECTIVES$9 = [
    NglFormLabel,
    NglFormHelp,
];
class NglFormsModule {
}
NglFormsModule.ɵfac = function NglFormsModule_Factory(t) { return new (t || NglFormsModule)(); };
NglFormsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglFormsModule });
NglFormsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglInternalOutletModule, NglIconsModule, NglTooltipsModule]] });

function getHexFromHsv(hsv) {
    return hsv ? getHexFromRgb(getRgbFromHsv(hsv)) : null;
}
function getRgbFromHsv({ hue, saturation, value }) {
    const hueRatio = hue / 360;
    const satRatio = saturation / 100;
    const valRatio = value / 100;
    let red;
    let green;
    let blue;
    const i = Math.floor(hueRatio * 6);
    const f = hueRatio * 6 - i;
    const p = valRatio * (1 - satRatio);
    const q = valRatio * (1 - f * satRatio);
    const t = valRatio * (1 - (1 - f) * satRatio);
    switch (i % 6) {
        case 0:
            red = valRatio;
            green = t;
            blue = p;
            break;
        case 1:
            red = q;
            green = valRatio;
            blue = p;
            break;
        case 2:
            red = p;
            green = valRatio;
            blue = t;
            break;
        case 3:
            red = p;
            green = q;
            blue = valRatio;
            break;
        case 4:
            red = t;
            green = p;
            blue = valRatio;
            break;
        default:
            red = valRatio;
            green = p;
            blue = q;
    }
    return {
        red: Math.round(red * 255),
        blue: Math.round(blue * 255),
        green: Math.round(green * 255),
    };
}
function getHex(color) {
    return `0${Math.round(color).toString(16)}`.substr(-2);
}
function getHexFromRgb({ red, green, blue }) {
    return `#${getHex(red)}${getHex(green)}${getHex(blue)}`;
}
function getHsvFromHex(hex) {
    return hex ? getHsvFromRgb(getRgbFromHex(hex)) : null;
}
function getHsvFromRgb({ red, green, blue }) {
    const redRatio = red / 255;
    const greenRatio = green / 255;
    const blueRatio = blue / 255;
    const max = Math.max(redRatio, greenRatio, blueRatio);
    const min = Math.min(redRatio, greenRatio, blueRatio);
    const delta = max - min;
    const saturation = max === 0 ? 0 : delta / max * 100;
    const value = max * 100;
    let hue;
    if (max === min) {
        hue = 0;
    }
    else {
        if (redRatio === max) {
            hue =
                (greenRatio - blueRatio) / delta + (greenRatio < blueRatio ? 6 : 0);
        }
        else if (greenRatio === max) {
            hue = (blueRatio - redRatio) / delta + 2;
        }
        else {
            hue = (redRatio - greenRatio) / delta + 4;
        }
        hue *= 60;
    }
    return { hue, saturation, value };
}
const HEX_REGEX = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
function getRgbFromHex(hex) {
    const result = HEX_REGEX.exec(toSixDigitHex(hex));
    return {
        red: parseInt(result[1], 16),
        green: parseInt(result[2], 16),
        blue: parseInt(result[3], 16),
    };
}
function toSixDigitHex(value) {
    const shortHandHex = /^#([a-f\d])([a-f\d])([a-f\d])$/i;
    const match = shortHandHex.exec(value);
    if (match) {
        return `#${match[1]}${match[1]}${match[2]}${match[2]}${match[3]}${match[3]}`;
    }
    return value;
}
function isValidHex(value) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(value);
}

/** Injection token that can be used to specify default options. */
const NGL_COLORPICKER_CONFIG = new InjectionToken('ngl-colorpicker-config');
class NglColorpickerConfig {
    constructor() {
        this.swatchColors = [
            '#e3abec', '#c2dbf7', '#9fd6ff', '#9de7da', '#9df0c0', '#fff099', '#fed49a',
            '#d073e0', '#86baf3', '#5ebbff', '#44d8be', '#3be282', '#ffe654', '#ffb758',
            '#bd35bd', '#5779c1', '#5679c0', '#00aea9', '#3cba4c', '#f5bc25', '#f99221',
            '#580d8c', '#001970', '#0a2399', '#0b7477', '#0b6b50', '#b67e11', '#b85d0d',
        ];
        this.variant = 'base';
    }
}

const NGL_COLORPICKER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NglColorpicker),
    multi: true
};
class NglColorpicker {
    constructor(defaultConfig, el, renderer, cd) {
        this.el = el;
        this.renderer = renderer;
        this.cd = cd;
        /**
         * An input label as for a form.
         */
        this.label = 'Choose Color';
        /**
         * Placeholder of input box.
         */
        this.placeholder = '';
        /**
         * Text for cancel button on popover.
         */
        this.cancelButtonLabel = 'Cancel';
        /**
         * Text for submit button of popover.
         */
        this.submitButtonLabel = 'Done';
        /**
         * Highlights the input as a required field (does not perform any validation).
         */
        this.required = false;
        /**
         * Error message when hex color input is invalid.
         */
        this.invalidColorLabel = 'Please ensure value is correct';
        /**
         * Text for swatch tab of popover.
         */
        this.swatchTabLabel = 'Default';
        /**
         * Text for custom tab of popover.
         */
        this.customTabLabel = 'Custom';
        /**
         * Whether to make the hex color input readonly.
         */
        this.readonlyInput = false;
        /**
         * Determines which tab is visible when popover opens.
         */
        this.defaultSelectedTab = 'swatches';
        this.uid = uniqueId('colorpicker');
        this.hexCurrent = '#FFF';
        this.hsvCurrent = getHsvFromHex(this.hexCurrent);
        this.onChange = (_) => { };
        this.onTouched = () => { };
        this.renderer.addClass(this.el.nativeElement, 'slds-color-picker');
        const config = Object.assign(Object.assign({}, new NglColorpickerConfig()), defaultConfig);
        this.swatchColors = config.swatchColors;
        this.variant = config.variant;
    }
    writeValue(value) {
        this.color = value || '';
        if (isValidHex(value)) {
            this.hexCurrent = value;
            this.hsvCurrent = getHsvFromHex(value);
        }
        this.cd.detectChanges();
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouched = fn; }
    setDisabledState(isDisabled) { this.disabled = isDisabled; }
    onSwatchSelection(hex) {
        this.hsvCurrent = getHsvFromHex(hex);
        this.hexCurrent = hex;
    }
    onCustomSelection(hsv) {
        this.hsvCurrent = hsv;
        this.hexCurrent = getHexFromHsv(hsv);
    }
    openChange(open) {
        this.open = open;
    }
    cancel() {
        this.open = false;
    }
    done() {
        this.open = false;
        if (this.hexCurrent !== this.color) {
            this.color = this.hexCurrent;
            this.onChange(this.color);
        }
    }
    canApply() {
        return isValidHex(this.hexCurrent);
    }
    onInput(hex) {
        this.color = hex;
        if (isValidHex(hex)) {
            this.onSwatchSelection(hex);
            this.onChange(hex);
        }
        else {
            this.onChange(null);
        }
    }
    get isValidInput() {
        return !this.color || isValidHex(this.color);
    }
}
NglColorpicker.ɵfac = function NglColorpicker_Factory(t) { return new (t || NglColorpicker)(ɵngcc0.ɵɵdirectiveInject(NGL_COLORPICKER_CONFIG, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglColorpicker.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglColorpicker, selectors: [["ngl-colorpicker"]], inputs: { label: "label", placeholder: "placeholder", cancelButtonLabel: "cancelButtonLabel", submitButtonLabel: "submitButtonLabel", required: "required", invalidColorLabel: "invalidColorLabel", swatchTabLabel: "swatchTabLabel", customTabLabel: "customTabLabel", readonlyInput: "readonlyInput", defaultSelectedTab: "defaultSelectedTab", swatchColors: "swatchColors", variant: "variant", fieldLevelHelpTooltip: "fieldLevelHelpTooltip" }, features: [ɵngcc0.ɵɵProvidersFeature([NGL_COLORPICKER_VALUE_ACCESSOR])], decls: 20, vars: 21, consts: [[1, "slds-color-picker__summary", "slds-form-element"], [1, "slds-form-element__label", "slds-color-picker__summary-label", 3, "nglFormLabel", "required"], ["class", "slds-m-horizontal_xx-small", 3, "content", 4, "ngIf"], [1, "slds-form-element__control"], ["nglPopoverPlacement", "bottom-left", "nglPopoverClass", "slds-color-picker__selector", "nglPopoverCloseVisible", "false", 1, "slds-button", "slds-color-picker__summary-button", "slds-button_icon", "slds-button_icon-more", 3, "title", "nglPopover", "nglPopoverOpen", "nglPopoverFooter", "disabled", "nglPopoverOpenChange"], ["nglColorpickerSwatch", "", 1, "slds-swatch", 3, "color"], ["class", "slds-button__icon slds-button__icon_small slds-m-left_xx-small", "nglIconName", "utility:down", 4, "ngIf"], [1, "slds-assistive-text"], [1, "slds-color-picker__summary-input"], ["type", "text", "maxlength", "7", 1, "slds-input", 3, "id", "value", "disabled", "readOnly", "placeholder", "input"], ["class", "slds-form-error", 3, "nglInternalOutlet", 4, "ngIf"], ["tip", ""], ["swatches", ""], ["custom", ""], ["footer", ""], [1, "slds-m-horizontal_xx-small", 3, "content"], ["nglIconName", "utility:down", 1, "slds-button__icon", "slds-button__icon_small", "slds-m-left_xx-small"], [1, "slds-form-error", 3, "nglInternalOutlet"], [3, "ngSwitch"], [4, "ngSwitchCase"], [3, "selected", "selectedChange", 4, "ngSwitchDefault"], [3, "ngTemplateOutlet"], [3, "selected", "selectedChange"], ["ngl-tab", "", "id", "swatches", 3, "label"], ["ngl-tab", "", "id", "custom", 3, "label"], [3, "hex", "swatchColors", "hexChange"], [3, "hsv", "hsvChange"], [1, "slds-color-picker__selector-footer"], ["type", "button", 1, "slds-button", "slds-button_neutral", 3, "click"], ["type", "button", 1, "slds-button", "slds-button_brand", 3, "disabled", "click"]], template: function NglColorpicker_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "label", 1);
        ɵngcc0.ɵɵtemplate(2, NglColorpicker_ngl_form_help_2_Template, 1, 1, "ngl-form-help", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵelementStart(4, "button", 4);
        ɵngcc0.ɵɵlistener("nglPopoverOpenChange", function NglColorpicker_Template_button_nglPopoverOpenChange_4_listener($event) { return ctx.openChange($event); });
        ɵngcc0.ɵɵelement(5, "span", 5);
        ɵngcc0.ɵɵtemplate(6, NglColorpicker__svg_svg_6_Template, 1, 0, "svg", 6);
        ɵngcc0.ɵɵelementStart(7, "span", 7);
        ɵngcc0.ɵɵtext(8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "div", 8);
        ɵngcc0.ɵɵelementStart(10, "input", 9);
        ɵngcc0.ɵɵlistener("input", function NglColorpicker_Template_input_input_10_listener($event) { return ctx.onInput($event.target.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, NglColorpicker_p_11_Template, 1, 1, "p", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(12, NglColorpicker_ng_template_12_Template, 4, 3, "ng-template", null, 11, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(14, NglColorpicker_ng_template_14_Template, 1, 2, "ng-template", null, 12, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(16, NglColorpicker_ng_template_16_Template, 1, 1, "ng-template", null, 13, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(18, NglColorpicker_ng_template_18_Template, 5, 3, "ng-template", null, 14, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r3 = ɵngcc0.ɵɵreference(13);
        const _r9 = ɵngcc0.ɵɵreference(19);
        ɵngcc0.ɵɵclassProp("slds-has-error", !ctx.isValidInput);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("nglFormLabel", ctx.label)("required", ctx.required);
        ɵngcc0.ɵɵattribute("for", ctx.uid + "-summary-input");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.fieldLevelHelpTooltip);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("title", ctx.label)("nglPopover", _r3)("nglPopoverOpen", ctx.open)("nglPopoverFooter", _r9)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("color", ctx.isValidInput ? ctx.color : ctx.hexCurrent);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.disabled);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate2("", ctx.label, ": ", ctx.color, "");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("id", ctx.uid + "-summary-input")("value", ctx.color)("disabled", ctx.disabled)("readOnly", ctx.readonlyInput)("placeholder", ctx.placeholder || "");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isValidInput);
    } }, directives: function () { return [NglFormLabel, ɵngcc1.NgIf, NglPopoverTrigger, NglColorpickerSwatch, NglFormHelp, NglIconSvg, NglInternalOutlet, ɵngcc1.NgSwitch, ɵngcc1.NgSwitchCase, ɵngcc1.NgSwitchDefault, ɵngcc1.NgTemplateOutlet, NglTabs, NglTab, NglColorpickerSwatches, NglColorpickerCustom]; }, encapsulation: 2, changeDetection: 0 });
NglColorpicker.ctorParameters = () => [
    { type: NglColorpickerConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_COLORPICKER_CONFIG,] }] },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
NglColorpicker.propDecorators = {
    label: [{ type: Input }],
    placeholder: [{ type: Input }],
    cancelButtonLabel: [{ type: Input }],
    submitButtonLabel: [{ type: Input }],
    required: [{ type: Input }],
    fieldLevelHelpTooltip: [{ type: Input }],
    invalidColorLabel: [{ type: Input }],
    swatchTabLabel: [{ type: Input }],
    customTabLabel: [{ type: Input }],
    swatchColors: [{ type: Input }],
    readonlyInput: [{ type: Input }],
    defaultSelectedTab: [{ type: Input }],
    variant: [{ type: Input }]
};
__decorate([
    InputBoolean()
], NglColorpicker.prototype, "required", void 0);
__decorate([
    InputBoolean()
], NglColorpicker.prototype, "readonlyInput", void 0);

class NglColorpickerSwatch {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.renderer.addClass(this.el.nativeElement, 'slds-swatch');
    }
}
NglColorpickerSwatch.ɵfac = function NglColorpickerSwatch_Factory(t) { return new (t || NglColorpickerSwatch)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglColorpickerSwatch.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglColorpickerSwatch, selectors: [["", "nglColorpickerSwatch", ""]], hostVars: 2, hostBindings: function NglColorpickerSwatch_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("background", ctx.color);
    } }, inputs: { color: "color" }, attrs: _c12, decls: 2, vars: 1, consts: [["aria-hidden", "true", 1, "slds-assistive-text"]], template: function NglColorpickerSwatch_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.color);
    } }, encapsulation: 2, changeDetection: 0 });
NglColorpickerSwatch.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglColorpickerSwatch.propDecorators = {
    color: [{ type: HostBinding, args: ['style.background',] }, { type: Input }]
};

class NglColorpickerCustom {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.hsvChange = new EventEmitter();
        this.renderer.addClass(this.el.nativeElement, 'slds-color-picker__custom');
    }
    ngOnChanges(changes) {
        if (changes.hsv) {
            this.hex = getHexFromHsv(this.hsv);
        }
    }
    onHsvChange($event) {
        this.hsvChange.emit($event);
    }
    onHexChange(hex) {
        const hsv = getHsvFromHex(hex);
        this.hsvChange.emit(hsv);
    }
}
NglColorpickerCustom.ɵfac = function NglColorpickerCustom_Factory(t) { return new (t || NglColorpickerCustom)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglColorpickerCustom.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglColorpickerCustom, selectors: [["ngl-colorpicker-custom"]], inputs: { hsv: "hsv" }, outputs: { hsvChange: "hsvChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 2, consts: [[3, "hsv", "hsvChange"], [3, "hex", "hexChange"]], template: function NglColorpickerCustom_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngl-colorpicker-range", 0);
        ɵngcc0.ɵɵlistener("hsvChange", function NglColorpickerCustom_Template_ngl_colorpicker_range_hsvChange_0_listener($event) { return ctx.onHsvChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(1, "ngl-colorpicker-inputs", 1);
        ɵngcc0.ɵɵlistener("hexChange", function NglColorpickerCustom_Template_ngl_colorpicker_inputs_hexChange_1_listener($event) { return ctx.onHexChange($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("hsv", ctx.hsv);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("hex", ctx.hex);
    } }, directives: function () { return [NglColorpickerRange, NglColorpickerInputs]; }, encapsulation: 2, changeDetection: 0 });
NglColorpickerCustom.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglColorpickerCustom.propDecorators = {
    hsv: [{ type: Input }],
    hsvChange: [{ type: Output }]
};

class NglColorpickerRange {
    constructor(document) {
        this.document = document;
        this.hsvChange = new EventEmitter();
        this.uid = uniqueId('colorpicker-range');
        this._hsv = { hue: 0, saturation: 0, value: 0 };
    }
    set hsv(hsv) {
        if (hsv) {
            this._hsv = hsv;
        }
    }
    get hsv() {
        return this._hsv;
    }
    get hex() {
        return getHexFromHsv(this.hsv);
    }
    ngAfterViewInit() {
        this.dragSubscription = this.setupDrag().subscribe((mm) => this.emitChange(mm));
    }
    hueSliderChange(value) {
        this.emitChange({ hue: value });
    }
    rangeIndicatorKeyboard(evt) {
        let saturation = this.hsv.saturation;
        let value = this.hsv.value;
        switch (evt.keyCode) {
            case LEFT_ARROW:
                saturation = this.limit(saturation - 1);
                break;
            case RIGHT_ARROW:
                saturation = this.limit(saturation + 1);
                break;
            case UP_ARROW:
                value = this.limit(value + 1);
                break;
            case DOWN_ARROW:
                value = this.limit(value - 1);
                break;
            default:
                return;
        }
        trapEvent(evt);
        this.emitChange({ saturation, value });
    }
    indicatorStyle() {
        return {
            'bottom.%': this.hsv.value,
            'left.%': this.hsv.saturation,
            'background': this.hex,
        };
    }
    ngOnDestroy() {
        if (this.dragSubscription) {
            this.dragSubscription.unsubscribe();
            this.dragSubscription = null;
        }
    }
    emitChange(hsv) {
        this.hsvChange.emit(Object.assign(Object.assign({}, this.hsv), hsv));
    }
    limit(value) {
        return Math.min(Math.max(value, 0), 100);
    }
    setupDrag() {
        const dragTarget = this.rangeIndicatorContainer.nativeElement;
        const pressEnd = merge(fromEvent(this.document, 'mouseup'), fromEvent(this.document, 'touchend'));
        const pressMove = merge(fromEvent(this.document, 'mousemove'), fromEvent(this.document, 'touchmove'));
        const pressStart = merge(fromEvent(dragTarget, 'mousedown'), fromEvent(dragTarget, 'touchstart'));
        return pressStart.pipe(flatMap((md) => {
            this.rangeIndicator.nativeElement.focus();
            const rect = dragTarget.getBoundingClientRect();
            return pressMove.pipe(startWith(md), map((mm) => {
                mm.preventDefault();
                const saturation = Math.round((mm.clientX - rect.left) / rect.width * 100);
                const value = Math.round((rect.bottom - mm.clientY) / rect.height * 100);
                return { saturation: this.limit(saturation), value: this.limit(value) };
            }), takeUntil(pressEnd));
        }));
    }
}
NglColorpickerRange.ɵfac = function NglColorpickerRange_Factory(t) { return new (t || NglColorpickerRange)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); };
NglColorpickerRange.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglColorpickerRange, selectors: [["ngl-colorpicker-range"]], viewQuery: function NglColorpickerRange_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c13, 5);
        ɵngcc0.ɵɵviewQuery(_c14, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rangeIndicator = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rangeIndicatorContainer = _t.first);
    } }, inputs: { hsv: "hsv" }, outputs: { hsvChange: "hsvChange" }, decls: 14, vars: 11, consts: [[1, "slds-assistive-text"], [1, "slds-color-picker__custom-range"], ["rangeIndicatorContainer", ""], ["href", "javascript:void(0);", "aria-live", "assertive", "aria-atomic", "true", 1, "slds-color-picker__range-indicator", 3, "ngStyle", "keydown"], ["rangeIndicator", ""], [1, "slds-color-picker__hue-and-preview"], ["type", "range", "min", "0", "max", "360", 1, "slds-color-picker__hue-slider", 3, "id", "value", "input"], ["hueSlider", ""], ["nglColorpickerSwatch", "", 3, "color"]], template: function NglColorpickerRange_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "p", 0);
        ɵngcc0.ɵɵtext(1, "Use arrow keys to select a saturation and brightness, on an x and y axis.");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1, 2);
        ɵngcc0.ɵɵelementStart(4, "a", 3, 4);
        ɵngcc0.ɵɵlistener("keydown", function NglColorpickerRange_Template_a_keydown_4_listener($event) { return ctx.rangeIndicatorKeyboard($event); });
        ɵngcc0.ɵɵelementStart(6, "span", 0);
        ɵngcc0.ɵɵtext(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "div", 5);
        ɵngcc0.ɵɵelementStart(9, "label", 0);
        ɵngcc0.ɵɵtext(10, "Select Hue");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(11, "input", 6, 7);
        ɵngcc0.ɵɵlistener("input", function NglColorpickerRange_Template_input_input_11_listener($event) { return ctx.hueSliderChange($event.target.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(13, "span", 8);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.uid + "-instructions");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("background", "hsl(" + ctx.hsv.hue + ", 100%, 50%)");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngStyle", ctx.indicatorStyle());
        ɵngcc0.ɵɵattribute("aria-describedby", ctx.uid + "-instructions");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate2("Saturation: ", ctx.hsv.saturation, "%. Brightness: ", ctx.hsv.value, "%.");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("for", ctx.uid + "-hue");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("id", ctx.uid + "-hue")("value", ctx.hsv.hue);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("color", ctx.hex);
    } }, directives: [ɵngcc1.NgStyle, NglColorpickerSwatch], encapsulation: 2, changeDetection: 0 });
NglColorpickerRange.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
NglColorpickerRange.propDecorators = {
    hsv: [{ type: Input }],
    hsvChange: [{ type: Output }],
    rangeIndicator: [{ type: ViewChild, args: ['rangeIndicator',] }],
    rangeIndicatorContainer: [{ type: ViewChild, args: ['rangeIndicatorContainer',] }]
};

class NglColorpickerInputs {
    constructor() {
        this.hexChange = new EventEmitter();
        this.red = 0;
        this.green = 0;
        this.blue = 0;
        this.uid = uniqueId('colorpicker-inputs');
    }
    set hex(hex) {
        if (hex) {
            this._hex = hex;
            const { red, green, blue } = getRgbFromHex(this.hex);
            this.red = red;
            this.green = green;
            this.blue = blue;
        }
    }
    get hex() {
        return this._hex;
    }
    updateHex(value) {
        const isValid = isValidHex(value);
        if (!isValid) {
            this.red = this.green = this.blue = null;
        }
        this.hexChange.emit(isValid ? value : null);
    }
    onRGB(key, value) {
        this[key] = value;
        const hex = this.isRGBValid() ? getHexFromRgb({ red: this.red, green: this.green, blue: this.blue }) : null;
        this.hexChange.emit(hex);
    }
    get isHexInvalid() {
        return this.red === null && this.green === null && this.blue === null;
    }
    isColorNumberValid(key) {
        const value = this[key];
        return _isNumberValue(value) && value >= 0 && value <= 255;
    }
    isRGBValid() {
        return ['red', 'green', 'blue'].every((prop) => this.isColorNumberValid(prop));
    }
}
NglColorpickerInputs.ɵfac = function NglColorpickerInputs_Factory(t) { return new (t || NglColorpickerInputs)(); };
NglColorpickerInputs.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglColorpickerInputs, selectors: [["ngl-colorpicker-inputs"]], inputs: { hex: "hex" }, outputs: { hexChange: "hexChange" }, decls: 28, vars: 22, consts: [[1, "slds-color-picker__custom-inputs"], [1, "slds-form-element", "slds-color-picker__input-custom-hex"], [1, "slds-form-element__label"], [1, "slds-form-element__control"], ["type", "text", "maxlength", "7", 1, "slds-input", 3, "id", "value", "input"], [1, "slds-form-element"], ["title", "red"], ["type", "text", "maxlength", "3", 1, "slds-input", 3, "id", "value", "input"], ["title", "green"], ["title", "blue"], [1, "slds-color-picker"], ["class", "slds-form-error slds-color-picker__input-custom-error", 4, "ngIf", "ngIfElse"], ["rgbError", ""], [1, "slds-form-error", "slds-color-picker__input-custom-error"], ["class", "slds-form-error slds-color-picker__input-custom-error", 4, "ngIf"]], template: function NglColorpickerInputs_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "label", 2);
        ɵngcc0.ɵɵtext(3, "Hex");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵelementStart(5, "input", 4);
        ɵngcc0.ɵɵlistener("input", function NglColorpickerInputs_Template_input_input_5_listener($event) { return ctx.updateHex($event.target.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "div", 5);
        ɵngcc0.ɵɵelementStart(7, "label", 2);
        ɵngcc0.ɵɵelementStart(8, "abbr", 6);
        ɵngcc0.ɵɵtext(9, "R");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(10, "div", 3);
        ɵngcc0.ɵɵelementStart(11, "input", 7);
        ɵngcc0.ɵɵlistener("input", function NglColorpickerInputs_Template_input_input_11_listener($event) { return ctx.onRGB("red", $event.target.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "div", 5);
        ɵngcc0.ɵɵelementStart(13, "label", 2);
        ɵngcc0.ɵɵelementStart(14, "abbr", 8);
        ɵngcc0.ɵɵtext(15, "G");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(16, "div", 3);
        ɵngcc0.ɵɵelementStart(17, "input", 7);
        ɵngcc0.ɵɵlistener("input", function NglColorpickerInputs_Template_input_input_17_listener($event) { return ctx.onRGB("green", $event.target.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(18, "div", 5);
        ɵngcc0.ɵɵelementStart(19, "label", 2);
        ɵngcc0.ɵɵelementStart(20, "abbr", 9);
        ɵngcc0.ɵɵtext(21, "B");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(22, "div", 3);
        ɵngcc0.ɵɵelementStart(23, "input", 7);
        ɵngcc0.ɵɵlistener("input", function NglColorpickerInputs_Template_input_input_23_listener($event) { return ctx.onRGB("blue", $event.target.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(24, "div", 10);
        ɵngcc0.ɵɵtemplate(25, NglColorpickerInputs_p_25_Template, 2, 0, "p", 11);
        ɵngcc0.ɵɵtemplate(26, NglColorpickerInputs_ng_template_26_Template, 1, 1, "ng-template", null, 12, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(27);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("slds-has-error", ctx.isHexInvalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("for", ctx.uid + "hex");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("id", ctx.uid + "hex")("value", ctx.hex);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("slds-has-error", !ctx.isColorNumberValid("red"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("for", ctx.uid + "red");
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("id", ctx.uid + "red")("value", ctx.red);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("slds-has-error", !ctx.isColorNumberValid("green"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("for", ctx.uid + "green");
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("id", ctx.uid + "green")("value", ctx.green);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("slds-has-error", !ctx.isColorNumberValid("blue"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("for", ctx.uid + "blue");
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("id", ctx.uid + "blue")("value", ctx.blue);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isHexInvalid)("ngIfElse", _r1);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
NglColorpickerInputs.propDecorators = {
    hex: [{ type: Input }],
    hexChange: [{ type: Output }]
};

class NglColorpickerSwatchTrigger {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.selectedChange = new EventEmitter();
        this.renderer.addClass(this.el.nativeElement, 'slds-color-picker__swatch-trigger');
        this.renderer.setAttribute(this.el.nativeElement, 'role', 'option');
    }
    onSelect() {
        return this.selectedChange.emit();
    }
    focus() {
        this.el.nativeElement.focus();
        this.onSelect();
    }
}
NglColorpickerSwatchTrigger.ɵfac = function NglColorpickerSwatchTrigger_Factory(t) { return new (t || NglColorpickerSwatchTrigger)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglColorpickerSwatchTrigger.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglColorpickerSwatchTrigger, selectors: [["", "nglColorpickerSwatchTrigger", ""]], hostVars: 2, hostBindings: function NglColorpickerSwatchTrigger_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NglColorpickerSwatchTrigger_click_HostBindingHandler() { return ctx.onSelect(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("ngl-color-picker__swatch-selected", ctx.selected);
    } }, inputs: { selected: "selected" }, outputs: { selectedChange: "selectedChange" } });
NglColorpickerSwatchTrigger.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglColorpickerSwatchTrigger.propDecorators = {
    selected: [{ type: HostBinding, args: ['class.ngl-color-picker__swatch-selected',] }, { type: Input }],
    selectedChange: [{ type: Output }],
    onSelect: [{ type: HostListener, args: ['click',] }]
};

class NglColorpickerSwatches {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.hexChange = new EventEmitter();
        this.swatchColors = [];
        this.renderer.addClass(this.el.nativeElement, 'slds-color-picker__swatches');
    }
    ngOnChanges() {
        this.activeIndex = Math.max(this.swatchColors.indexOf(this.hex), 0);
    }
    onSelectViaInteraction(evt) {
        let direction = 0;
        switch (evt.keyCode) {
            case LEFT_ARROW:
            case UP_ARROW:
                direction = -1;
                break;
            case RIGHT_ARROW:
            case DOWN_ARROW:
                direction = 1;
                break;
            default:
                return;
        }
        trapEvent(evt);
        const activeIndex = this.swatchColors.indexOf(this.hex);
        const index = (this.triggers.length + activeIndex + direction) % this.triggers.length;
        const trigger = this.triggers.toArray()[index];
        trigger.focus();
    }
    isSelected(hex) {
        return hex === this.hex;
    }
    onSelect(hex) {
        this.hexChange.emit(hex);
    }
}
NglColorpickerSwatches.ɵfac = function NglColorpickerSwatches_Factory(t) { return new (t || NglColorpickerSwatches)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglColorpickerSwatches.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglColorpickerSwatches, selectors: [["ngl-colorpicker-swatches"]], viewQuery: function NglColorpickerSwatches_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NglColorpickerSwatchTrigger, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.triggers = _t);
    } }, hostBindings: function NglColorpickerSwatches_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function NglColorpickerSwatches_keydown_HostBindingHandler($event) { return ctx.onSelectViaInteraction($event); });
    } }, inputs: { swatchColors: "swatchColors", hex: "hex" }, outputs: { hexChange: "hexChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 1, consts: [["class", "slds-color-picker__swatch", "role", "presentation", 4, "ngFor", "ngForOf"], ["role", "presentation", 1, "slds-color-picker__swatch"], ["nglColorpickerSwatchTrigger", "", "href", "javascript:void(0);", 3, "selected", "selectedChange"], ["nglColorpickerSwatch", "", 3, "color"]], template: function NglColorpickerSwatches_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglColorpickerSwatches_li_0_Template, 3, 3, "li", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.swatchColors);
    } }, directives: [ɵngcc1.NgForOf, NglColorpickerSwatchTrigger, NglColorpickerSwatch], styles: [".ngl-color-picker__swatch-selected[_ngcontent-%COMP%] {\n      box-shadow: rgb(117, 112, 112) 1px 1px 1px;\n    }"], changeDetection: 0 });
NglColorpickerSwatches.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglColorpickerSwatches.propDecorators = {
    hex: [{ type: Input }],
    hexChange: [{ type: Output }],
    swatchColors: [{ type: Input }],
    triggers: [{ type: ViewChildren, args: [NglColorpickerSwatchTrigger,] }],
    onSelectViaInteraction: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

const DIRECTIVES$8 = [
    NglColorpicker,
];
class NglColorpickerModule {
}
NglColorpickerModule.ɵfac = function NglColorpickerModule_Factory(t) { return new (t || NglColorpickerModule)(); };
NglColorpickerModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglColorpickerModule });
NglColorpickerModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            NglIconsModule,
            NglTabsModule,
            NglPopoversModule,
            NglFormsModule,
            NglInternalOutletModule,
        ]] });

class NglOverlaynglOverlayScrolledOutsideViewDirective {
    constructor(cdkOverlay, ngZone, scrollDispatcher) {
        this.cdkOverlay = cdkOverlay;
        this.ngZone = ngZone;
        this.scrollDispatcher = scrollDispatcher;
        this.overlayOutside = new EventEmitter();
    }
    ngOnInit() {
        const elementRef = this.cdkOverlay.origin.elementRef;
        const scrollableAncestors = this.scrollDispatcher.getAncestorScrollContainers(elementRef).map(container => container.getElementRef());
        if (!scrollableAncestors || !scrollableAncestors.length)
            return;
        this.subscription = this.cdkOverlay.positionChange.subscribe(() => {
            const bounds = elementRef.nativeElement.getBoundingClientRect();
            for (let i = 0, n = scrollableAncestors.length; i < n; i++) {
                const ancestorsBounds = scrollableAncestors[i].nativeElement.getBoundingClientRect();
                if (isElementOutside(bounds, ancestorsBounds)) {
                    this.ngZone.run(() => this.overlayOutside.emit());
                    return;
                }
            }
        });
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
    }
}
NglOverlaynglOverlayScrolledOutsideViewDirective.ɵfac = function NglOverlaynglOverlayScrolledOutsideViewDirective_Factory(t) { return new (t || NglOverlaynglOverlayScrolledOutsideViewDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.CdkConnectedOverlay, 2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.ScrollDispatcher)); };
NglOverlaynglOverlayScrolledOutsideViewDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglOverlaynglOverlayScrolledOutsideViewDirective, selectors: [["", "nglOverlayScrolledOutsideView", ""]], outputs: { overlayOutside: "nglOverlayScrolledOutsideView" } });
NglOverlaynglOverlayScrolledOutsideViewDirective.ctorParameters = () => [
    { type: CdkConnectedOverlay, decorators: [{ type: Self }] },
    { type: NgZone },
    { type: ScrollDispatcher }
];
NglOverlaynglOverlayScrolledOutsideViewDirective.propDecorators = {
    overlayOutside: [{ type: Output, args: ['nglOverlayScrolledOutsideView',] }]
};
/**
 * Gets whether an element is scrolled outside of view by its parent scrolling container.
 * @param element Dimensions of the element (from getBoundingClientRect)
 * @param container Dimensions of element's scrolling container (from getBoundingClientRect)
 * @returns Whether the element is scrolled out of view
 */
function isElementOutside(element, container) {
    return (element.bottom < container.top || element.top > container.bottom ||
        element.right < container.left || element.left > container.right);
}

const DIRECTIVES$7 = [
    NglOverlaynglOverlayScrolledOutsideViewDirective,
];
class NglOverlayModule {
}
NglOverlayModule.ɵfac = function NglOverlayModule_Factory(t) { return new (t || NglOverlayModule)(); };
NglOverlayModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglOverlayModule });
NglOverlayModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

class NglComboboxService {
}
NglComboboxService.ɵfac = function NglComboboxService_Factory(t) { return new (t || NglComboboxService)(); };
NglComboboxService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: NglComboboxService, factory: NglComboboxService.ɵfac });

class NglComboboxOption {
    constructor(element, service, cd, ngZone, renderer) {
        this.element = element;
        this.service = service;
        this.cd = cd;
        this.ngZone = ngZone;
        this.disabled = false;
        this.uid = uniqueId('combo-option');
        this._active = false;
        // Flag to disable scrolling into view when option is activated using mouse
        this.disableNextScrollIntoView = false;
        this.destroyed = false;
        renderer.addClass(element.nativeElement, 'slds-listbox__item');
        renderer.setAttribute(element.nativeElement, 'role', 'presentation');
    }
    // Whether or not the option is currently active and ready to be selected
    set active(active) {
        if (this.active === active || this.destroyed) {
            return;
        }
        this._active = active;
        this.cd.detectChanges();
        if (active) {
            this.service.combobox.inputEl.setAriaActiveDescendant(this.uid);
            this.scrollIntoView();
        }
        else {
            clearTimeout(this.scrollTimer);
        }
    }
    get active() {
        return this._active;
    }
    onSelectViaInteraction(evt) {
        trapEvent(evt);
        if (!this.disabled) {
            this.service.combobox.onOptionSelection(this);
        }
    }
    hover() {
        if (!this.disabled) {
            this.disableNextScrollIntoView = true;
            this.service.combobox.keyManager.setActiveItem(this);
        }
    }
    setActiveStyles() {
        this.active = true;
    }
    setInactiveStyles() {
        this.active = false;
    }
    scrollIntoView() {
        if (this.disableNextScrollIntoView) {
            this.disableNextScrollIntoView = false;
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.scrollTimer = setTimeout(() => {
                const li = this.element.nativeElement;
                menuItemScroll(li.parentElement.parentElement, li);
            }, 0);
        });
    }
    ngOnDestroy() {
        this.destroyed = true;
        clearTimeout(this.scrollTimer);
    }
}
NglComboboxOption.ɵfac = function NglComboboxOption_Factory(t) { return new (t || NglComboboxOption)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NglComboboxService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglComboboxOption.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglComboboxOption, selectors: [["ngl-combobox-option"], ["", "nglComboboxOption", ""]], hostBindings: function NglComboboxOption_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousedown", function NglComboboxOption_mousedown_HostBindingHandler($event) { return ctx.onSelectViaInteraction($event); })("mouseenter", function NglComboboxOption_mouseenter_HostBindingHandler() { return ctx.hover(); });
    } }, inputs: { disabled: "disabled", value: "value", label: "label", selected: "selected" }, decls: 7, vars: 10, consts: [["role", "option", 1, "slds-media", "slds-listbox__option", "slds-listbox__option_plain", "slds-media_small", "slds-media_center"], [1, "slds-media__figure", "slds-listbox__option-icon"], ["class", "slds-icon_container slds-icon-utility-check slds-current-color", 4, "ngIf"], [1, "slds-media__body"], [1, "slds-truncate"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-icon_container", "slds-icon-utility-check", "slds-current-color"], ["nglIconName", "utility:check", 1, "slds-icon", "slds-icon_x-small"], [1, "slds-assistive-text"]], template: function NglComboboxOption_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵtemplate(2, NglComboboxOption_span_2_Template, 2, 0, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "span", 3);
        ɵngcc0.ɵɵelementStart(4, "span", 4);
        ɵngcc0.ɵɵtemplate(5, NglComboboxOption_span_5_Template, 2, 0, "span", 5);
        ɵngcc0.ɵɵtext(6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-has-focus", ctx.active)("slds-is-selected", ctx.selected);
        ɵngcc0.ɵɵattribute("id", ctx.uid)("aria-selected", ctx.selected || null)("aria-disabled", ctx.disabled || null);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.selected);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.selected);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
    } }, directives: [ɵngcc1.NgIf, NglIconSvg], encapsulation: 2, changeDetection: 0 });
NglComboboxOption.ctorParameters = () => [
    { type: ElementRef },
    { type: NglComboboxService },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: Renderer2 }
];
NglComboboxOption.propDecorators = {
    value: [{ type: Input }],
    label: [{ type: Input }],
    selected: [{ type: Input }],
    disabled: [{ type: Input }],
    onSelectViaInteraction: [{ type: HostListener, args: ['mousedown', ['$event'],] }],
    hover: [{ type: HostListener, args: ['mouseenter',] }]
};
__decorate([
    InputBoolean()
], NglComboboxOption.prototype, "selected", void 0);

const MAX_INTERVAL_BETWEEN_KEYSTROKES = 300; // ms
class NglComboboxInput {
    constructor(service, el, renderer) {
        this.service = service;
        this.el = el;
        this.renderer = renderer;
        const { nativeElement } = this.el;
        this.renderer.addClass(nativeElement, 'slds-input');
        this.renderer.addClass(nativeElement, 'slds-combobox__input');
        this.renderer.setAttribute(nativeElement, 'autoComplete', 'off');
        this.renderer.setAttribute(nativeElement, 'role', 'textbox');
        this.renderer.setAttribute(nativeElement, 'aria-controls', this.service.combobox.uid);
        if (!nativeElement.id) {
            this.renderer.setAttribute(nativeElement, 'id', uniqueId('combobox-input'));
        }
        const keyboardEvent$ = fromEvent(nativeElement, 'keypress').pipe(map((e) => e.keyCode));
        this.keyboardBuffer$ = keyboardEvent$.pipe(buffer(keyboardEvent$.pipe(debounceTime(MAX_INTERVAL_BETWEEN_KEYSTROKES))), map((keyCodes) => keyCodes.map((c) => String.fromCharCode(c)).join('')));
    }
    get isReadonly() {
        return this.service.combobox.variant === 'base' || this.service.combobox.hasLookupSingleSelection;
    }
    get ariaAutocomplete() {
        return this.service.combobox.isLookup ? 'list' : null;
    }
    get hasReadonlyValue() {
        return this.service.combobox.hasLookupSingleSelection;
    }
    get id() {
        return this.el.nativeElement.id;
    }
    setAriaActiveDescendant(uid) {
        if (uid) {
            this.renderer.setAttribute(this.el.nativeElement, 'aria-activedescendant', uid);
        }
        else {
            this.renderer.removeAttribute(this.el.nativeElement, 'aria-activedescendant');
        }
    }
    setValue(value) {
        this.renderer.setProperty(this.el.nativeElement, 'value', value !== null ? value : '');
    }
    focus() {
        this.el.nativeElement.focus();
    }
    onMouseInteraction() {
        if (this.service.combobox.hasLookupSingleSelection || (this.service.combobox.open && this.service.combobox.isLookup)) {
            return;
        }
        this.service.combobox.openChange.emit(!this.service.combobox.open);
    }
    onBlur() {
        this.service.combobox.openChange.emit(false);
    }
    onKeyboard(evt) {
        const keyCode = evt.keyCode;
        if (keyCode === ESCAPE) {
            // This is handled by CDK, and detaches overlay
            return;
        }
        if (this.service.combobox.open) {
            switch (keyCode) {
                // User selects currently active option by pressing the `Enter` key
                case ENTER:
                    trapEvent(evt);
                    this.service.combobox.onOptionSelection();
                    return;
                // Propagate to keymanager
                default:
                    this.service.combobox.keyManager.onKeydown(evt);
                    return;
            }
        }
        else {
            // Do nothing if readonly Lookup
            if (this.service.combobox.hasLookupSingleSelection) {
                return;
            }
            // Pressing the `Down` or `Enter` key will expand the collapsed menu
            if (keyCode === DOWN_ARROW || keyCode === ENTER) {
                trapEvent(evt);
                this.service.combobox.openChange.emit(true);
                return;
            }
            // Any key on Lookup should expand the collapsed menu
            if (this.service.combobox.isLookup) {
                // Delay emission so actual value of the input has been updated
                setTimeout(() => this.service.combobox.openChange.emit(true), 0);
            }
        }
    }
}
NglComboboxInput.ɵfac = function NglComboboxInput_Factory(t) { return new (t || NglComboboxInput)(ɵngcc0.ɵɵdirectiveInject(NglComboboxService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglComboboxInput.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglComboboxInput, selectors: [["input", "nglCombobox", ""]], hostVars: 4, hostBindings: function NglComboboxInput_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NglComboboxInput_click_HostBindingHandler() { return ctx.onMouseInteraction(); })("blur", function NglComboboxInput_blur_HostBindingHandler() { return ctx.onBlur(); })("keydown", function NglComboboxInput_keydown_HostBindingHandler($event) { return ctx.onKeyboard($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("readOnly", ctx.isReadonly);
        ɵngcc0.ɵɵattribute("aria-autocomplete", ctx.ariaAutocomplete);
        ɵngcc0.ɵɵclassProp("slds-combobox__input-value", ctx.hasReadonlyValue);
    } } });
NglComboboxInput.ctorParameters = () => [
    { type: NglComboboxService },
    { type: ElementRef },
    { type: Renderer2 }
];
NglComboboxInput.propDecorators = {
    isReadonly: [{ type: HostBinding, args: ['readOnly',] }],
    ariaAutocomplete: [{ type: HostBinding, args: ['attr.aria-autocomplete',] }],
    hasReadonlyValue: [{ type: HostBinding, args: ['class.slds-combobox__input-value',] }],
    onMouseInteraction: [{ type: HostListener, args: ['click',] }],
    onBlur: [{ type: HostListener, args: ['blur',] }],
    onKeyboard: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

/** Injection token that can be used to specify default options. */
const NGL_COMBOBOX_CONFIG = new InjectionToken('ngl-combobox-config');
class NglComboboxConfig {
    constructor() {
        this.loadingLabel = 'Loading';
        this.noOptionsFound = 'No matches found.';
        this.removeSelectedLabel = 'Remove selected option';
    }
}

class NglCombobox {
    constructor(defaultConfig, ngZone, cd, service) {
        this.ngZone = ngZone;
        this.cd = cd;
        this.service = service;
        this.variant = 'base';
        this.uid = uniqueId('combobox');
        this.open = false;
        this.openChange = new EventEmitter();
        this.selectionChange = new EventEmitter();
        this.multiple = false;
        this.visibleLength = 5;
        this.closeOnSelection = true;
        this.overlayWidth = 0;
        this.overlayPositions = [...DEFAULT_DROPDOWN_POSITIONS['left']];
        this.selectionValueFn = (selection) => {
            if (selection.length > 0) {
                if (this.multiple && this.isLookup) {
                    return '';
                }
                return selection.length === 1 ? selection[0] : `${selection.length} options selected`;
            }
            return '';
        };
        const config = Object.assign(Object.assign({}, new NglComboboxConfig()), defaultConfig);
        this.loadingLabel = config.loadingLabel;
        this.noOptionsFound = config.noOptionsFound;
        this.removeSelectedLabel = config.removeSelectedLabel;
        this.service.combobox = this;
        // this.service.openChange = this.openChange;
    }
    set data(data) {
        this._data = (data || []).map((d) => {
            if (typeof d === 'string') {
                // Support array of strings as options, by mapping to NglComboboxOptionItem
                return { value: d, label: d };
            }
            else if (!d.label) {
                // Use `value` if missing `label`
                return Object.assign(Object.assign({}, d), { label: d.value });
            }
            return d;
        });
    }
    get data() {
        return this._data;
    }
    get activeOption() {
        return this.keyManager ? this.keyManager.activeItem : null;
    }
    get selectedOptions() {
        return this.data ? this.data.filter(d => this.isSelected(d.value)) : [];
    }
    get isLookup() {
        return this.variant === 'lookup';
    }
    get hasLookupSingleSelection() {
        return this.isLookup && !this.multiple && this.selectedOptions.length > 0;
    }
    ngOnChanges(changes) {
        if (changes.selection) {
            this.calculateDisplayValue();
        }
    }
    onAttach() {
        // Same width as the trigger element
        this.overlayWidth = this.overlayOrigin.elementRef.nativeElement.offsetWidth;
        this.cd.detectChanges();
        this.keyManager = new ActiveDescendantKeyManager(this.options).withWrap();
        // Activate selected item or first option
        const selectedOption = this.options.find(o => o.selected);
        if (selectedOption) {
            this.keyManager.setActiveItem(selectedOption);
        }
        else {
            this.keyManager.setFirstItemActive();
        }
        // Listen to button presses if picklist to activate matching option
        this.keyboardSubscribe(this.variant === 'base');
        // When it is open we listen for option changes in order to fix active option and handle scroll
        this.optionChangesSubscription = this.options.changes.subscribe(() => {
            if (!this.activeOption || this.options.toArray().indexOf(this.activeOption) === -1) {
                // Activate first option if active one is destroyed
                this.keyManager.setFirstItemActive();
            }
            else {
                this.activeOption.scrollIntoView();
            }
            this.updateMenuHeight();
        });
        this.updateMenuHeight();
    }
    onDetach() {
        if (this.open) {
            this.close();
            return;
        }
        // Clear aria-activedescendant when menu is closed
        this.inputEl.setAriaActiveDescendant(null);
        this.detach();
    }
    trackByOption(index, option) {
        return option.value;
    }
    dropdownClass() {
        return {
            [`slds-dropdown_length-${this.visibleLength}`]: this.visibleLength > 0,
        };
    }
    inputIconRight() {
        return this.isLookup ? 'utility:search' : 'utility:down';
    }
    hasNoMatches() {
        return this.isLookup && this.data.length === 0 && !this.loadingMore;
    }
    onOptionSelection(option = this.activeOption) {
        const selection = addOptionToSelection(option.value, this.selection, this.multiple);
        this.selectionChange.emit(selection);
        if (this.closeOnSelection) {
            this.close();
        }
    }
    // Trigger by clear button on Lookup
    onClearSelection() {
        this.selectionChange.emit(null);
        setTimeout(() => this.inputEl.focus(), 0);
    }
    /**
     * Check whether value is currently selected.
     *
     * @param value The value in test, whether is (part of) selection or not
     */
    isSelected(value) {
        return isOptionSelected(value, this.selection, this.multiple);
    }
    ngOnDestroy() {
        this.detach();
    }
    close() {
        this.openChange.emit(false);
    }
    detach() {
        this.keyboardSubscribe(false);
        this.keyManager = null;
        if (this.optionChangesSubscription) {
            this.optionChangesSubscription.unsubscribe();
            this.optionChangesSubscription = null;
        }
    }
    calculateDisplayValue() {
        const value = this.selectionValueFn(this.selectedOptions.map(option => option.label));
        this.inputEl.setValue(value);
    }
    keyboardSubscribe(listen) {
        if (this.keyboardSubscription) {
            this.keyboardSubscription.unsubscribe();
            this.keyboardSubscription = null;
        }
        if (listen) {
            this.keyboardSubscription = this.inputEl.keyboardBuffer$.subscribe((pattern) => {
                pattern = pattern.toLocaleLowerCase();
                const options = this.options.toArray();
                const activeIndex = this.activeOption ? this.keyManager.activeItemIndex + 1 : 0;
                for (let i = 0, n = options.length; i < n; i++) {
                    const index = (activeIndex + i) % n;
                    const option = options[index];
                    if (!option.disabled && option.label.toLocaleLowerCase().substr(0, pattern.length) === pattern) {
                        this.keyManager.setActiveItem(option);
                        break;
                    }
                }
            });
        }
    }
    updateMenuHeight() {
        this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
            const { overlayRef } = this.cdkOverlay;
            const height = this.dropdownElementRef.nativeElement.offsetHeight;
            overlayRef.updateSize({
                minHeight: height + 4,
            });
            overlayRef.updatePosition();
        });
    }
}
NglCombobox.ɵfac = function NglCombobox_Factory(t) { return new (t || NglCombobox)(ɵngcc0.ɵɵdirectiveInject(NGL_COMBOBOX_CONFIG, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NglComboboxService)); };
NglCombobox.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglCombobox, selectors: [["ngl-combobox"]], contentQueries: function NglCombobox_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglComboboxInput, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputEl = _t.first);
    } }, viewQuery: function NglCombobox_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c15, 7);
        ɵngcc0.ɵɵviewQuery(_c16, 5);
        ɵngcc0.ɵɵviewQuery(_c17, 5);
        ɵngcc0.ɵɵviewQuery(NglComboboxOption, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.overlayOrigin = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cdkOverlay = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropdownElementRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.options = _t);
    } }, hostAttrs: ["class.slds-form-element", "true"], inputs: { variant: "variant", open: "open", multiple: "multiple", visibleLength: "visibleLength", closeOnSelection: "closeOnSelection", selectionValueFn: "selectionValueFn", loadingLabel: "loadingLabel", noOptionsFound: "noOptionsFound", removeSelectedLabel: "removeSelectedLabel", data: ["options", "data"], label: "label", selection: "selection", loading: "loading", loadingMore: "loadingMore" }, outputs: { openChange: "openChange", selectionChange: "selectionChange" }, features: [ɵngcc0.ɵɵProvidersFeature([NglComboboxService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c19, decls: 14, vars: 18, consts: [[3, "nglFormLabel"], [1, "slds-form-element__control"], [1, "slds-combobox_container"], ["aria-haspopup", "listbox", "role", "combobox", 1, "slds-combobox", "slds-dropdown-trigger", "slds-dropdown-trigger_click"], ["role", "none", "cdkOverlayOrigin", "", 1, "slds-combobox__form-element", "slds-input-has-icon"], ["overlayOrigin", "cdkOverlayOrigin"], ["class", "slds-input__icon-group slds-input__icon-group_right", 4, "ngIf", "ngIfElse"], ["iconRight", ""], ["iconTpl", ""], ["cdkConnectedOverlay", "", 3, "cdkConnectedOverlayPositions", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayMinWidth", "cdkConnectedOverlayOpen", "nglOverlayScrolledOutsideView", "attach", "detach"], ["cdkOverlay", "cdkConnectedOverlay"], [1, "slds-input__icon-group", "slds-input__icon-group_right"], ["role", "status", 1, "slds-spinner", "slds-spinner_brand", "slds-spinner_x-small", "slds-input__spinner"], [1, "slds-assistive-text"], [1, "slds-spinner__dot-a"], [1, "slds-spinner__dot-b"], [3, "ngTemplateOutlet"], ["class", "slds-button slds-button_icon slds-input__icon slds-input__icon_right", "type", "button", 3, "title", "click", 4, "ngIf", "ngIfElse"], ["type", "button", 1, "slds-button", "slds-button_icon", "slds-input__icon", "slds-input__icon_right", 3, "title", "click"], ["nglIconName", "utility:close", 1, "slds-button__icon"], [1, "slds-icon_container", "slds-input__icon", "slds-input__icon_right"], [1, "slds-icon", "slds-icon_x-small", "slds-icon-text-default", 3, "nglIconName"], ["role", "listbox", 1, "slds-dropdown", "slds-dropdown_fluid", 3, "ngClass", "mousedown"], ["dropdown", ""], ["role", "presentation", 1, "slds-listbox", "slds-listbox_vertical"], ["nglComboboxOption", "", 3, "value", "label", "disabled", "selected", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "slds-listbox__item", "role", "presentation", 4, "ngIf"], ["class", "slds-listbox__item", "role", "presentation", "aria-live", "polite", 4, "ngIf"], ["nglComboboxOption", "", 3, "value", "label", "disabled", "selected"], ["role", "presentation", 1, "slds-listbox__item"], [1, "slds-align_absolute-center", "slds-p-top_medium"], ["role", "status", 1, "slds-spinner", "slds-spinner_x-small", "slds-spinner_inline"], ["role", "presentation", "aria-live", "polite", 1, "slds-listbox__item"], [1, "slds-align_absolute-center"], ["role", "status"]], template: function NglCombobox_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c18);
        ɵngcc0.ɵɵelement(0, "label", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵelementStart(4, "div", 4, 5);
        ɵngcc0.ɵɵprojection(6);
        ɵngcc0.ɵɵtemplate(7, NglCombobox_div_7_Template, 7, 2, "div", 6);
        ɵngcc0.ɵɵtemplate(8, NglCombobox_ng_template_8_Template, 1, 2, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(10, NglCombobox_ng_template_10_Template, 2, 1, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(12, NglCombobox_ng_template_12_Template, 6, 6, "ng-template", 9, 10, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵlistener("nglOverlayScrolledOutsideView", function NglCombobox_Template_ng_template_nglOverlayScrolledOutsideView_12_listener() { return ctx.close(); })("attach", function NglCombobox_Template_ng_template_attach_12_listener() { return ctx.onAttach(); })("detach", function NglCombobox_Template_ng_template_detach_12_listener() { return ctx.onDetach(); });
    } if (rf & 2) {
        const _r0 = ɵngcc0.ɵɵreference(5);
        const _r2 = ɵngcc0.ɵɵreference(9);
        ɵngcc0.ɵɵproperty("nglFormLabel", ctx.label);
        ɵngcc0.ɵɵattribute("for", ctx.inputEl.id);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("slds-has-selection", ctx.hasLookupSingleSelection);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("slds-is-open", ctx.open);
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.open)("aria-owns", ctx.uid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("slds-input-has-icon_group-right", ctx.loading)("slds-input-has-icon_right", !ctx.loading);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.loading)("ngIfElse", _r2);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("cdkConnectedOverlayPositions", ctx.overlayPositions)("cdkConnectedOverlayOrigin", _r0)("cdkConnectedOverlayMinWidth", ctx.overlayWidth)("cdkConnectedOverlayOpen", ctx.open);
    } }, directives: [NglFormLabel, ɵngcc3.CdkOverlayOrigin, ɵngcc1.NgIf, ɵngcc3.CdkConnectedOverlay, NglOverlaynglOverlayScrolledOutsideViewDirective, ɵngcc1.NgTemplateOutlet, NglIconSvg, ɵngcc1.NgClass, ɵngcc1.NgForOf, NglComboboxOption], encapsulation: 2, changeDetection: 0 });
NglCombobox.ctorParameters = () => [
    { type: NglComboboxConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_COMBOBOX_CONFIG,] }] },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: NglComboboxService }
];
NglCombobox.propDecorators = {
    variant: [{ type: Input }],
    label: [{ type: Input }],
    open: [{ type: Input }],
    openChange: [{ type: Output }],
    selection: [{ type: Input }],
    selectionChange: [{ type: Output }],
    multiple: [{ type: Input }],
    visibleLength: [{ type: Input }],
    inputEl: [{ type: ContentChild, args: [NglComboboxInput, { static: true },] }],
    loading: [{ type: Input }],
    loadingMore: [{ type: Input }],
    closeOnSelection: [{ type: Input }],
    loadingLabel: [{ type: Input }],
    noOptionsFound: [{ type: Input }],
    removeSelectedLabel: [{ type: Input }],
    options: [{ type: ViewChildren, args: [NglComboboxOption,] }],
    data: [{ type: Input, args: ['options',] }],
    overlayOrigin: [{ type: ViewChild, args: ['overlayOrigin', { static: true },] }],
    cdkOverlay: [{ type: ViewChild, args: ['cdkOverlay',] }],
    dropdownElementRef: [{ type: ViewChild, args: ['dropdown',] }],
    selectionValueFn: [{ type: Input }]
};
__decorate([
    InputBoolean()
], NglCombobox.prototype, "open", void 0);
__decorate([
    InputBoolean()
], NglCombobox.prototype, "multiple", void 0);
__decorate([
    InputNumber()
], NglCombobox.prototype, "visibleLength", void 0);
__decorate([
    InputBoolean()
], NglCombobox.prototype, "loading", void 0);
__decorate([
    InputBoolean()
], NglCombobox.prototype, "loadingMore", void 0);
__decorate([
    InputBoolean()
], NglCombobox.prototype, "closeOnSelection", void 0);

const DIRECTIVES$6 = [
    NglCombobox,
    NglComboboxOption,
    NglComboboxInput,
];
class NglComboboxesModule {
}
NglComboboxesModule.ɵfac = function NglComboboxesModule_Factory(t) { return new (t || NglComboboxesModule)(); };
NglComboboxesModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglComboboxesModule });
NglComboboxesModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglInternalOutletModule, NglIconsModule, NglFormsModule, OverlayModule, NglOverlayModule]] });

class NglDatatableCell {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NglDatatableCell.ɵfac = function NglDatatableCell_Factory(t) { return new (t || NglDatatableCell)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglDatatableCell.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglDatatableCell, selectors: [["", "nglDatatableCell", ""]] });
NglDatatableCell.ctorParameters = () => [
    { type: TemplateRef }
];

class NglDatatableHeadingTemplate {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NglDatatableHeadingTemplate.ɵfac = function NglDatatableHeadingTemplate_Factory(t) { return new (t || NglDatatableHeadingTemplate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglDatatableHeadingTemplate.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglDatatableHeadingTemplate, selectors: [["", "nglDatatableHeading", ""]] });
NglDatatableHeadingTemplate.ctorParameters = () => [
    { type: TemplateRef }
];

class NglDatatableColumn {
    constructor() {
        this.sortable = false;
        this.truncate = false;
    }
}
NglDatatableColumn.ɵfac = function NglDatatableColumn_Factory(t) { return new (t || NglDatatableColumn)(); };
NglDatatableColumn.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglDatatableColumn, selectors: [["ngl-datatable-column"]], contentQueries: function NglDatatableColumn_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglDatatableCell, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglDatatableHeadingTemplate, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cellTpl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headingTpl = _t.first);
    } }, inputs: { sortable: "sortable", truncate: "truncate", heading: "heading", key: "key", headClass: "headClass", cellClass: "cellClass" } });
NglDatatableColumn.propDecorators = {
    heading: [{ type: Input }],
    key: [{ type: Input }],
    headClass: [{ type: Input }],
    cellClass: [{ type: Input }],
    sortable: [{ type: Input }],
    truncate: [{ type: Input }],
    cellTpl: [{ type: ContentChild, args: [NglDatatableCell,] }],
    headingTpl: [{ type: ContentChild, args: [NglDatatableHeadingTemplate,] }]
};
__decorate([
    InputBoolean()
], NglDatatableColumn.prototype, "sortable", void 0);
__decorate([
    InputBoolean()
], NglDatatableColumn.prototype, "truncate", void 0);

class NglDatatableLoadingOverlay {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NglDatatableLoadingOverlay.ɵfac = function NglDatatableLoadingOverlay_Factory(t) { return new (t || NglDatatableLoadingOverlay)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglDatatableLoadingOverlay.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglDatatableLoadingOverlay, selectors: [["", "nglLoadingOverlay", ""]] });
NglDatatableLoadingOverlay.ctorParameters = () => [
    { type: TemplateRef }
];
class NglDatatableNoRowsOverlay {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NglDatatableNoRowsOverlay.ɵfac = function NglDatatableNoRowsOverlay_Factory(t) { return new (t || NglDatatableNoRowsOverlay)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglDatatableNoRowsOverlay.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglDatatableNoRowsOverlay, selectors: [["", "nglNoRowsOverlay", ""]] });
NglDatatableNoRowsOverlay.ctorParameters = () => [
    { type: TemplateRef }
];

class NglDatatable {
    constructor(detector) {
        this.detector = detector;
        this.data = [];
        this.sortChange = new EventEmitter();
        this.loading = false;
        this.rowClick = new EventEmitter();
        this.dataTrackBy = (index, data) => {
            return this.trackByKey ? data[this.trackByKey] : index;
        };
    }
    get showLoading() {
        return this.loading && this.loadingOverlay;
    }
    columnTrackBy(index, column) {
        return column.key || index;
    }
    onColumnSort(column, order) {
        const key = column.key;
        if (!key) {
            throw new Error(`ng-lightning: No "key" property is set for sortable column "${column.heading}"`);
        }
        this.sortChange.emit({ key, order });
    }
    getColumnSortOrder(column) {
        return this.sort && column.key === this.sort.key ? this.sort.order : null;
    }
    onRowClick(event, data) {
        this.rowClick.emit({ event, data });
    }
    ngAfterContentInit() {
        this._columnsSubscription = this.columns.changes.subscribe(() => this.detector.markForCheck());
    }
    ngOnDestroy() {
        if (this._columnsSubscription) {
            this._columnsSubscription.unsubscribe();
            this._columnsSubscription = null;
        }
    }
}
NglDatatable.ɵfac = function NglDatatable_Factory(t) { return new (t || NglDatatable)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglDatatable.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglDatatable, selectors: [["table", "ngl-datatable", ""]], contentQueries: function NglDatatable_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglDatatableLoadingOverlay, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglDatatableNoRowsOverlay, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglDatatableColumn, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.loadingOverlay = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.noRowsOverlay = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columns = _t);
    } }, hostVars: 4, hostBindings: function NglDatatable_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-table", true)("slds-is-relative", ctx.loading);
    } }, inputs: { data: "data", loading: "loading", trackByKey: "trackByKey", sort: "sort" }, outputs: { sortChange: "sortChange", rowClick: "rowClick" }, attrs: _c20, decls: 8, vars: 5, consts: [[1, "slds-line-height_reset"], ["nglDatatableHead", "", "scope", "col", 3, "heading", "headingTpl", "sortable", "sortOrder", "ngClass", "sort", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["noData", ""], [4, "ngIf", "ngIfElse"], ["class", "ngl-datatable-loading slds-align_absolute-center", 4, "ngIf"], ["nglDatatableHead", "", "scope", "col", 3, "heading", "headingTpl", "sortable", "sortOrder", "ngClass", "sort"], [3, "ngTemplateOutlet"], [3, "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "click"], ["nglDatatatableCell_", "", 3, "ngClass", "row", "column", "index", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["nglDatatatableCell_", "", 3, "ngClass", "row", "column", "index"], [1, "ngl-datatable-loading", "slds-align_absolute-center"]], template: function NglDatatable_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "thead");
        ɵngcc0.ɵɵelementStart(1, "tr", 0);
        ɵngcc0.ɵɵtemplate(2, NglDatatable_th_2_Template, 1, 5, "th", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "tbody");
        ɵngcc0.ɵɵtemplate(4, NglDatatable_ng_template_4_Template, 3, 2, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, NglDatatable_ng_container_6_Template, 2, 2, "ng-container", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, NglDatatable_div_7_Template, 2, 1, "div", 4);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(5);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.columns)("ngForTrackBy", ctx.columnTrackBy);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.data && ctx.data.length > 0)("ngIfElse", _r1);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLoading);
    } }, directives: function () { return [ɵngcc1.NgForOf, ɵngcc1.NgIf, NglInternalDatatableHeadCell, ɵngcc1.NgClass, ɵngcc1.NgTemplateOutlet, NglInternalDatatableCell]; }, styles: [".ngl-datatable-loading[_ngcontent-%COMP%] {\n      position: absolute;\n      z-index: 1;\n      top: 0; left: 0; right: 0; bottom: 0;\n      background: rgba(255, 255, 255, 0.5)\n    }"] });
NglDatatable.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NglDatatable.propDecorators = {
    data: [{ type: Input }],
    trackByKey: [{ type: Input }],
    sort: [{ type: Input }],
    sortChange: [{ type: Output }],
    loading: [{ type: HostBinding, args: ['class.slds-is-relative',] }, { type: Input }],
    loadingOverlay: [{ type: ContentChild, args: [NglDatatableLoadingOverlay,] }],
    noRowsOverlay: [{ type: ContentChild, args: [NglDatatableNoRowsOverlay,] }],
    columns: [{ type: ContentChildren, args: [NglDatatableColumn,] }],
    rowClick: [{ type: Output }]
};

class NglInternalDatatableHeadCell {
    constructor() {
        this.sort = new EventEmitter();
    }
    get header() {
        return this.headingTpl || this.heading;
    }
    get attrTitle() {
        return this.heading || null;
    }
    get ariaSort() {
        return this.sortOrder ? `${this.sortOrder}ending` : 'none';
    }
    sortChange() {
        this.sort.emit(this.sortOrder === 'desc' ? 'asc' : 'desc');
    }
}
NglInternalDatatableHeadCell.ɵfac = function NglInternalDatatableHeadCell_Factory(t) { return new (t || NglInternalDatatableHeadCell)(); };
NglInternalDatatableHeadCell.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglInternalDatatableHeadCell, selectors: [["th", "nglDatatableHead", ""]], hostVars: 9, hostBindings: function NglInternalDatatableHeadCell_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-sort", ctx.ariaSort);
        ɵngcc0.ɵɵclassProp("slds-is-sorted_asc", ctx.sortOrder === "asc")("slds-is-sorted_desc", ctx.sortOrder === "desc")("slds-is-sorted", !!ctx.sortOrder)("slds-is-sortable", ctx.sortable);
    } }, inputs: { heading: "heading", headingTpl: "headingTpl", sortable: "sortable", sortOrder: "sortOrder" }, outputs: { sort: "sort" }, attrs: _c21, decls: 3, vars: 2, consts: [["class", "slds-th__action slds-text-link_reset", "role", "button", "tabindex", "0", 3, "click", 4, "ngIf", "ngIfElse"], ["baseTpl", ""], ["role", "button", "tabindex", "0", 1, "slds-th__action", "slds-text-link_reset", 3, "click"], [1, "slds-assistive-text"], [1, "slds-grid", "slds-grid_vertical-align-center", "slds-has-flexi-truncate"], [1, "slds-truncate", 3, "nglInternalOutlet"], [1, "slds-icon_container", "slds-icon-utility-arrowdown"], ["nglIconName", "arrowdown", 1, "slds-icon", "slds-icon-text-default", "slds-is-sortable__icon"]], template: function NglInternalDatatableHeadCell_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglInternalDatatableHeadCell_a_0_Template, 7, 2, "a", 0);
        ɵngcc0.ɵɵtemplate(1, NglInternalDatatableHeadCell_ng_template_1_Template, 1, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.sortable)("ngIfElse", _r1);
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet, NglIconSvg], encapsulation: 2, changeDetection: 0 });
NglInternalDatatableHeadCell.propDecorators = {
    heading: [{ type: Input }],
    headingTpl: [{ type: Input }],
    sortable: [{ type: HostBinding, args: ['class.slds-is-sortable',] }, { type: Input }],
    sortOrder: [{ type: Input }],
    ariaSort: [{ type: HostBinding, args: ['attr.aria-sort',] }],
    sort: [{ type: Output }]
};

class NglInternalDatatableCell {
    get dataLabel() {
        return this.column.heading;
    }
    ngOnChanges() {
        this.context = {
            $implicit: this.value,
            row: this.row,
            index: this.index,
        };
    }
    get value() {
        const { key } = this.column;
        return key ? this.row[key] : null;
    }
}
NglInternalDatatableCell.ɵfac = function NglInternalDatatableCell_Factory(t) { return new (t || NglInternalDatatableCell)(); };
NglInternalDatatableCell.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglInternalDatatableCell, selectors: [["td", "nglDatatatableCell_", ""]], hostVars: 1, hostBindings: function NglInternalDatatableCell_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-label", ctx.dataLabel);
    } }, inputs: { row: "row", column: "column", index: "index" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c22, decls: 4, vars: 5, consts: [[3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf", "ngIfElse"], ["stringTpl", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function NglInternalDatatableCell_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵtemplate(1, NglInternalDatatableCell_ng_container_1_Template, 1, 2, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(2, NglInternalDatatableCell_ng_template_2_Template, 1, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(3);
        ɵngcc0.ɵɵclassProp("slds-truncate", ctx.column.truncate);
        ɵngcc0.ɵɵattribute("title", ctx.column.truncate ? ctx.value : null);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.column.cellTpl)("ngIfElse", _r1);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
NglInternalDatatableCell.propDecorators = {
    row: [{ type: Input }],
    column: [{ type: Input }],
    index: [{ type: Input }],
    dataLabel: [{ type: HostBinding, args: ['attr.data-label',] }]
};

const NGL_DATATABLE_DIRECTIVES = [
    NglDatatable,
    NglDatatableColumn,
    NglDatatableCell,
    NglDatatableHeadingTemplate,
    NglDatatableLoadingOverlay, NglDatatableNoRowsOverlay,
];
class NglDatatablesModule {
}
NglDatatablesModule.ɵfac = function NglDatatablesModule_Factory(t) { return new (t || NglDatatablesModule)(); };
NglDatatablesModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglDatatablesModule });
NglDatatablesModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglIconsModule, NglInternalOutletModule]] });

class NglClickOutsideDirective {
    constructor(document, element) {
        this.document = document;
        this.element = element;
        this.clickOutside = new EventEmitter();
    }
    ngAfterViewInit() {
        this.subscription = fromEvent(this.document, 'click').subscribe((e) => {
            if (this.shouldClose(e)) {
                this.clickOutside.emit();
            }
        });
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
    }
    shouldClose(event) {
        const element = event.target;
        if ((event instanceof MouseEvent && event.button === 2) || isContainedIn(element, this.ignore)) {
            return false;
        }
        return !isContainedIn(element, this.element.nativeElement);
    }
}
NglClickOutsideDirective.ɵfac = function NglClickOutsideDirective_Factory(t) { return new (t || NglClickOutsideDirective)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NglClickOutsideDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglClickOutsideDirective, selectors: [["", "nglClickOutside", ""]], inputs: { ignore: ["nglClickOutsideIgnore", "ignore"] }, outputs: { clickOutside: "nglClickOutside" } });
NglClickOutsideDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ElementRef }
];
NglClickOutsideDirective.propDecorators = {
    clickOutside: [{ type: Output, args: ['nglClickOutside',] }],
    ignore: [{ type: Input, args: ['nglClickOutsideIgnore',] }]
};
function isContainedIn(el, container) {
    if (!container) {
        return false;
    }
    return Array.isArray(container) ? container.some(c => c.contains(el)) : container.contains(el);
}

const DIRECTIVES$5 = [NglClickOutsideDirective];
class NglClickOutsideModule {
}
NglClickOutsideModule.ɵfac = function NglClickOutsideModule_Factory(t) { return new (t || NglClickOutsideModule)(); };
NglClickOutsideModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglClickOutsideModule });
NglClickOutsideModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

class NglDateAdapterBase {
}

const PATTERNS = {
    'big-endian': 'yyyy/MM/dd',
    'little-endian': 'dd/MM/yyyy',
    'middle-endian': 'MM/dd/yyyy',
};
class NglDateAdapter extends NglDateAdapterBase {
    parse(value, format) {
        const date = parse(value, format, new Date());
        return this.isValidDate(date) ? date : null;
    }
    format(date, format$1) {
        return format(date, format$1);
    }
    pattern(name, delimiter) {
        const pattern = PATTERNS[name];
        return (delimiter && delimiter !== '/') ? pattern.replace(/\//g, delimiter) : pattern;
    }
    isValidDate(value) {
        const dateWrapper = new Date(value);
        return !isNaN(dateWrapper.getDate());
    }
}
NglDateAdapter.ɵfac = /*@__PURE__*/ function () { let ɵNglDateAdapter_BaseFactory; return function NglDateAdapter_Factory(t) { return (ɵNglDateAdapter_BaseFactory || (ɵNglDateAdapter_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglDateAdapter)))(t || NglDateAdapter); }; }();
NglDateAdapter.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: NglDateAdapter, factory: NglDateAdapter.ɵfac });

/** Injection token that can be used to specify default options. */
const NGL_DATEPICKER_CONFIG = new InjectionToken('ngl-datepicker-config');
class NglDatepickerConfig {
    constructor(locale) {
        this.format = 'big-endian';
        this.delimiter = '/';
        this.dropdownAlign = 'left';
        this.showToday = true;
        this.relativeYearFrom = -100;
        this.relativeYearTo = 10;
        this.openOnInputClick = true;
        this.todayLabel = 'Today';
        this.previousMonthLabel = 'Previous Month';
        this.nextMonthLabel = 'Next Month';
        this.patternPlaceholder = false;
        this.monthNames = getLocaleMonthNames(locale, FormStyle.Standalone, TranslationWidth.Wide);
        this.dayNamesShort = getLocaleDayNames(locale, FormStyle.Standalone, TranslationWidth.Abbreviated);
        this.dayNamesLong = getLocaleDayNames(locale, FormStyle.Standalone, TranslationWidth.Wide);
        this.firstDayOfWeek = getLocaleFirstDayOfWeek(locale);
    }
}

function parseDate(date) {
    if (!date) {
        return null;
    }
    return { year: date.getFullYear(), month: date.getMonth(), day: date.getDate() };
}
function isEqualDate(d1, d2) {
    return d1 && d2 && d1.day === d2.day && d1.month === d2.month && d1.year === d2.year;
}
function getToday() {
    const today = new Date();
    return { year: today.getFullYear(), month: today.getMonth(), day: today.getDate() };
}
function numberOfDaysInMonth(year, month) {
    return new Date(year, month + 1, 0).getDate();
}
// Split array into smaller arrays
function split(arr, size = 7) {
    const arrays = [];
    while (arr.length > 0) {
        arrays.push(arr.splice(0, size));
    }
    return arrays;
}
function isDisabled(d, disabledCallback, min, max) {
    const date = new Date(d.year, d.month, d.day);
    return (disabledCallback && disabledCallback(date)) ||
        (min && compareDate(d, min) < 0) ||
        (max && compareDate(d, max) > 0);
}
function compareDate(d1, d2) {
    if (isEqualDate(d1, d2)) {
        return 0;
    }
    const keys = ['year', 'month', 'day'];
    for (let i = 0; i < 3; i++) {
        const key = keys[i];
        const diff = d1[key] - d2[key];
        if (diff !== 0) {
            return diff > 0 ? 1 : -1;
        }
    }
}
function isSameMonth(d1, d2) {
    return d1.year === d2.year && d1.month === d2.month;
}

const NGL_DATEPICKER_INPUT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NglDatepickerInput),
    multi: true
};
const NGL_DATEPICKER_INPUT_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => NglDatepickerInput),
    multi: true
};
class NglDatepickerInput {
    constructor(defaultConfig, locale, element, renderer, cd, hostService, ngZone, focusTrapFactory, adapter) {
        this.element = element;
        this.renderer = renderer;
        this.cd = cd;
        this.hostService = hostService;
        this.ngZone = ngZone;
        this.focusTrapFactory = focusTrapFactory;
        this.adapter = adapter;
        /**
         * Emits when selected date changes.
         */
        this.valueChange = new EventEmitter();
        /**
         * Text for button to open calendar.
         */
        this.selectDateLabel = 'Select a date';
        this.dateDisabled = null;
        this.uid = uniqueId('datepicker-input');
        this._open = new BehaviorSubject(false);
        this._value = null;
        this.onChange = null;
        this.onTouched = () => { };
        this.validatorChange = () => { };
        this.renderer.addClass(this.element.nativeElement, 'slds-form-element');
        this.renderer.addClass(this.element.nativeElement, 'slds-dropdown-trigger');
        this.renderer.addClass(this.element.nativeElement, 'slds-dropdown-trigger_click');
        this.config = Object.assign(Object.assign({}, new NglDatepickerConfig(locale)), defaultConfig);
        this.format = this.config.format;
        this.delimiter = this.config.delimiter;
        this.setPositions(this.config.dropdownAlign);
        this.monthNames = this.config.monthNames;
        this.dayNamesShort = this.config.dayNamesShort;
        this.dayNamesLong = this.config.dayNamesLong;
        this.firstDayOfWeek = this.config.firstDayOfWeek;
        this.showToday = this.config.showToday;
        this.relativeYearFrom = this.config.relativeYearFrom;
        this.relativeYearTo = this.config.relativeYearTo;
        this.openOnInputClick = this.config.openOnInputClick;
        this.todayLabel = this.config.todayLabel;
        this.previousMonthLabel = this.config.previousMonthLabel;
        this.nextMonthLabel = this.config.nextMonthLabel;
        this.patternPlaceholder = this.config.patternPlaceholder;
    }
    /**
     * The date value.
     */
    set value(value) {
        if (value === this._value) {
            return;
        }
        this._value = value;
        if (this.value instanceof Date) {
            this.date = this.value;
            this.formatInputValue();
        }
        else {
            this.updateInputValue(value || '');
        }
    }
    get value() {
        return this._value;
    }
    set open(open) {
        this._open.next(open);
    }
    get open() {
        return this._open.value;
    }
    validate(c) {
        const value = c.value;
        if (!value) {
            return null;
        }
        if (!(this.value instanceof Date)) {
            return { 'nglDatepickerInput': { invalid: c.value } };
        }
        const date = parseDate(value);
        if (isDisabled(date, this.dateDisabled, parseDate(this.min), parseDate(this.max))) {
            return { 'nglDatepickerInput': { disabled: c.value } };
        }
        return null;
    }
    writeValue(value) {
        this.value = value;
        this.cd.markForCheck();
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouched = fn; }
    registerOnValidatorChange(fn) { this.validatorChange = fn; }
    setDisabledState(disabled) { this.disabled = disabled; }
    onBlur() {
        if (this.value instanceof Date) {
            this.updateInputValue();
        }
        this.onTouched();
    }
    ngOnInit() {
        this._open.subscribe(() => {
            this.setHostClass();
            this.cd.markForCheck();
        });
    }
    ngOnChanges(changes) {
        if (changes.format || changes.delimiter) {
            this.setPattern();
            if (this.value instanceof Date) {
                this.updateInputValue();
            }
        }
        if (changes.dropdownAlign) {
            this.setPositions(this.dropdownAlign);
        }
        if (changes.min || changes.max) {
            this.validatorChange();
        }
        if ((changes.patternPlaceholder || changes.format || changes.delimiter) && this.patternPlaceholder) {
            this.inputEl.setPlaceholder(this.getPattern().toLocaleUpperCase());
        }
        if (changes.disabled) {
            this.inputEl.setDisabled(this.disabled);
        }
    }
    ngOnDestroy() {
        this.closeCalendar(false);
    }
    onKeyboardInput(evt) {
        const keyCode = evt.keyCode;
        if (!this.open && (keyCode === DOWN_ARROW || keyCode === UP_ARROW)) {
            this.openCalendar();
        }
    }
    onInputChange() {
        const value = this.inputEl.element.nativeElement.value;
        const date = this.dateParse(value);
        this.emitSelection(date || value);
    }
    openCalendar() {
        this.open = true;
    }
    onAttach() {
        this.focusTrap = this.focusTrapFactory.create(this.cdkOverlay.overlayRef.overlayElement);
    }
    onDetach() {
        if (this.open) {
            this.closeCalendar();
        }
    }
    closeCalendar(focusInput = true) {
        this.open = false;
        if (this.focusTrap) {
            this.focusTrap.destroy();
            this.focusTrap = null;
        }
        if (focusInput) {
            this.inputEl.element.nativeElement.focus();
        }
    }
    onTriggerClick(origin) {
        if (origin === 'input' && !this.openOnInputClick) {
            return;
        }
        if (!this.open) {
            this.openCalendar();
        }
        else {
            this.closeCalendar(false);
        }
    }
    pickerSelection(date) {
        this.emitSelection(date);
        this.closeCalendar();
    }
    updateDatepickerSize(width, height) {
        this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
            const { overlayRef } = this.cdkOverlay;
            overlayRef.updateSize({
                minWidth: width,
                minHeight: height + 4,
            });
            overlayRef.updatePosition();
        });
    }
    setPositions(align) {
        this.overlayPositions = [...DEFAULT_DROPDOWN_POSITIONS[align]];
    }
    formatInputValue() {
        const inputValue = this.inputEl.element.nativeElement.value;
        if (!inputValue) {
            this.updateInputValue();
        }
        else {
            const date = this.value;
            const dateNow = this.dateParse(inputValue);
            if (!dateNow || dateNow.getFullYear() !== date.getFullYear() || dateNow.getMonth() !== date.getMonth() || dateNow.getDate() !== date.getDate()) {
                this.updateInputValue();
            }
        }
    }
    updateInputValue(value = this.dateFormat(this.value)) {
        this.renderer.setProperty(this.inputEl.element.nativeElement, 'value', value || '');
    }
    dateParse(value) {
        return this.adapter.parse(value, this.getPattern());
    }
    dateFormat(date) {
        return this.adapter.format(date, this.getPattern());
    }
    getPattern() {
        if (!this.pattern) {
            this.setPattern();
        }
        return this.pattern;
    }
    setPattern() {
        this.pattern = this.adapter.pattern(this.format || this.config.format, this.delimiter || this.config.delimiter);
    }
    emitSelection(value) {
        this.valueChange.emit(value);
        if (this.onChange) {
            this.value = value;
            this.onChange(value);
        }
    }
    setHostClass() {
        this.hostService.updateClass(this.element, {
            [`slds-is-open`]: this.open,
        });
    }
}
NglDatepickerInput.ɵfac = function NglDatepickerInput_Factory(t) { return new (t || NglDatepickerInput)(ɵngcc0.ɵɵdirectiveInject(NGL_DATEPICKER_CONFIG, 8), ɵngcc0.ɵɵdirectiveInject(LOCALE_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(HostService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FocusTrapFactory), ɵngcc0.ɵɵdirectiveInject(NglDateAdapter)); };
NglDatepickerInput.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglDatepickerInput, selectors: [["ngl-datepicker-input"]], viewQuery: function NglDatepickerInput_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c16, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cdkOverlay = _t.first);
    } }, inputs: { selectDateLabel: "selectDateLabel", dateDisabled: "dateDisabled", format: "format", delimiter: "delimiter", monthNames: "monthNames", dayNamesShort: "dayNamesShort", dayNamesLong: "dayNamesLong", firstDayOfWeek: "firstDayOfWeek", showToday: "showToday", relativeYearFrom: "relativeYearFrom", relativeYearTo: "relativeYearTo", openOnInputClick: "openOnInputClick", todayLabel: "todayLabel", previousMonthLabel: "previousMonthLabel", nextMonthLabel: "nextMonthLabel", patternPlaceholder: "patternPlaceholder", value: "value", disabled: "disabled", label: "label", dropdownAlign: "dropdownAlign", min: "min", max: "max" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([NGL_DATEPICKER_INPUT_VALUE_ACCESSOR, NGL_DATEPICKER_INPUT_VALIDATOR, HostService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 11, vars: 7, consts: [["class", "slds-form-element__label", 3, "nglInternalOutlet", 4, "ngIf"], ["cdkOverlayOrigin", "", 1, "slds-form-element__control", "slds-input-has-icon", "slds-input-has-icon_right"], ["formEl", "", "overlayOrigin", "cdkOverlayOrigin"], ["type", "button", 1, "slds-button", "slds-button_icon", "slds-input__icon", "slds-input__icon_right", 3, "title", "disabled", "click"], ["nglIconName", "utility:event", 1, "slds-button__icon"], [1, "slds-assistive-text"], ["cdkConnectedOverlay", "", 3, "cdkConnectedOverlayPositions", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen", "nglOverlayScrolledOutsideView", "attach", "detach"], ["cdkOverlay", "cdkConnectedOverlay"], [1, "slds-form-element__label", 3, "nglInternalOutlet"], [1, "slds-dropdown", 3, "date", "monthNames", "dayNamesShort", "dayNamesLong", "firstDayOfWeek", "showToday", "min", "max", "relativeYearFrom", "relativeYearTo", "todayLabel", "previousMonthLabel", "nextMonthLabel", "dateDisabled", "nglClickOutsideIgnore", "dateChange", "nglClickOutside"]], template: function NglDatepickerInput_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NglDatepickerInput_label_0_Template, 1, 2, "label", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementStart(5, "button", 3);
        ɵngcc0.ɵɵlistener("click", function NglDatepickerInput_Template_button_click_5_listener() { return ctx.onTriggerClick("button"); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(6, "svg", 4);
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(7, "span", 5);
        ɵngcc0.ɵɵtext(8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(9, NglDatepickerInput_ng_template_9_Template, 1, 16, "ng-template", 6, 7, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵlistener("nglOverlayScrolledOutsideView", function NglDatepickerInput_Template_ng_template_nglOverlayScrolledOutsideView_9_listener() { return ctx.closeCalendar(false); })("attach", function NglDatepickerInput_Template_ng_template_attach_9_listener() { return ctx.onAttach(); })("detach", function NglDatepickerInput_Template_ng_template_detach_9_listener() { return ctx.onDetach(); });
    } if (rf & 2) {
        const _r2 = ɵngcc0.ɵɵreference(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.label);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("title", ctx.selectDateLabel)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.selectDateLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("cdkConnectedOverlayPositions", ctx.overlayPositions)("cdkConnectedOverlayOrigin", _r2)("cdkConnectedOverlayOpen", ctx.open);
    } }, directives: function () { return [ɵngcc1.NgIf, ɵngcc3.CdkOverlayOrigin, NglIconSvg, ɵngcc3.CdkConnectedOverlay, NglOverlaynglOverlayScrolledOutsideViewDirective, NglInternalOutlet, NglDatepicker, NglClickOutsideDirective]; }, encapsulation: 2, changeDetection: 0 });
NglDatepickerInput.ctorParameters = () => [
    { type: NglDatepickerConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_DATEPICKER_CONFIG,] }] },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: HostService },
    { type: NgZone },
    { type: FocusTrapFactory },
    { type: NglDateAdapter }
];
NglDatepickerInput.propDecorators = {
    label: [{ type: Input }],
    format: [{ type: Input }],
    delimiter: [{ type: Input }],
    disabled: [{ type: Input }],
    dropdownAlign: [{ type: Input }],
    value: [{ type: Input }],
    openOnInputClick: [{ type: Input }],
    valueChange: [{ type: Output }],
    cdkOverlay: [{ type: ViewChild, args: ['cdkOverlay',] }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    selectDateLabel: [{ type: Input }],
    patternPlaceholder: [{ type: Input }],
    monthNames: [{ type: Input }],
    dayNamesShort: [{ type: Input }],
    dayNamesLong: [{ type: Input }],
    firstDayOfWeek: [{ type: Input }],
    showToday: [{ type: Input }],
    dateDisabled: [{ type: Input }],
    relativeYearFrom: [{ type: Input }],
    relativeYearTo: [{ type: Input }],
    todayLabel: [{ type: Input }],
    previousMonthLabel: [{ type: Input }],
    nextMonthLabel: [{ type: Input }]
};
__decorate([
    InputBoolean()
], NglDatepickerInput.prototype, "disabled", void 0);
__decorate([
    InputBoolean()
], NglDatepickerInput.prototype, "openOnInputClick", void 0);
__decorate([
    InputBoolean()
], NglDatepickerInput.prototype, "patternPlaceholder", void 0);
__decorate([
    InputBoolean()
], NglDatepickerInput.prototype, "showToday", void 0);

class NglDay {
    constructor(el) {
        this.el = el;
    }
    get tabindex() {
        return this.isActive ? 0 : -1;
    }
    focus() {
        this.el.nativeElement.focus();
    }
}
NglDay.ɵfac = function NglDay_Factory(t) { return new (t || NglDay)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NglDay.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglDay, selectors: [["td", "nglDay", ""]], hostVars: 7, hostBindings: function NglDay_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex)("aria-disabled", ctx.nglDayDisabled)("aria-selected", ctx.nglDaySelected);
        ɵngcc0.ɵɵclassProp("slds-disabled-text", ctx.nglDayDisabled)("slds-is-selected", ctx.nglDaySelected);
    } }, inputs: { date: ["nglDay", "date"], nglDayDisabled: "nglDayDisabled", nglDaySelected: "nglDaySelected", isActive: "isActive" } });
NglDay.ctorParameters = () => [
    { type: ElementRef }
];
NglDay.propDecorators = {
    date: [{ type: Input, args: ['nglDay',] }],
    nglDayDisabled: [{ type: HostBinding, args: ['class.slds-disabled-text',] }, { type: HostBinding, args: ['attr.aria-disabled',] }, { type: Input }],
    nglDaySelected: [{ type: HostBinding, args: ['class.slds-is-selected',] }, { type: HostBinding, args: ['attr.aria-selected',] }, { type: Input }],
    isActive: [{ type: Input }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }]
};

class NglDatepickerMonth {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.dateDisabled = null;
        this.selectDate = new EventEmitter();
    }
    indexTrackBy(index) {
        return index;
    }
    dateTrackBy(index, { year, month, day }) {
        return `${day}-${month}-${year}`;
    }
    onSelect(date) {
        if (date.disabled)
            return;
        this.selectDate.emit(date);
    }
    ngOnChanges(changes) {
        if (changes.year || changes.month || changes.firstDayOfWeek) {
            this.renderView();
            return;
        }
        if (changes.day) {
            this.updateActive();
        }
        if (changes.selected) {
            this.updateSelected();
        }
        if (changes.minDate || changes.maxDate || changes.dateDisabled) {
            this.updateDisabled();
        }
    }
    focusActiveDay() {
        this.ngZone.runOutsideAngular(() => {
            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                const active = this.days.find((d) => d.isActive);
                if (active) {
                    active.focus();
                }
            });
        });
    }
    renderView() {
        const days = this.daysInMonth(this.year, this.month);
        Array.prototype.unshift.apply(days, this.daysInPreviousMonth(this.year, this.month));
        const nextMonth = this.daysInNextMonth(this.year, this.month + 1, days.length);
        if (nextMonth) {
            Array.prototype.push.apply(days, nextMonth);
        }
        this.weeks = split(days);
    }
    daysInMonth(year, month) {
        const last = numberOfDaysInMonth(year, month);
        return this.getDayObjects(year, month, 1, last);
    }
    daysInPreviousMonth(year, month) {
        const firstIndex = (new Date(year, month, 1)).getDay();
        const last = new Date(year, month, 0).getDate();
        const numDays = (7 + firstIndex - this.firstDayOfWeek) % 7;
        return this.getDayObjects(year, month - 1, last - numDays + 1, last, false);
    }
    daysInNextMonth(year, month, numOfDays) {
        if (numOfDays % 7 === 0) {
            return;
        }
        return this.getDayObjects(year, month, 1, 7 - (numOfDays % 7), false);
    }
    getDayObjects(year, month, from, to, isCurrentMonth = true) {
        const today = getToday();
        const days = [];
        for (let day = from; day <= to; day++) {
            const d = {
                year,
                month,
                day,
                isCurrentMonth,
                today: isEqualDate(today, { year, month, day }),
            };
            d.active = this.isActive(d);
            d.selected = this.isSelected(d);
            d.disabled = this.isDisabled(d);
            days.push(d);
        }
        return days;
    }
    updateActive() {
        this.weeks.forEach((days) => {
            days.forEach(day => {
                day.active = this.isActive(day);
            });
        });
    }
    isActive(day) {
        return day.isCurrentMonth && day.day === this.day;
    }
    updateSelected() {
        this.weeks.forEach((days) => {
            days.forEach((day) => {
                day.selected = this.isSelected(day);
            });
        });
    }
    isSelected(day) {
        return isEqualDate(this.selected, day);
    }
    updateDisabled() {
        this.weeks.forEach((days) => {
            days.forEach(day => {
                day.disabled = this.isDisabled(day);
            });
        });
    }
    /** Date filter for the month */
    isDisabled(d) {
        return !d.isCurrentMonth || isDisabled(d, this.dateDisabled, this.minDate, this.maxDate);
    }
}
NglDatepickerMonth.ɵfac = function NglDatepickerMonth_Factory(t) { return new (t || NglDatepickerMonth)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
NglDatepickerMonth.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglDatepickerMonth, selectors: [["", "nglDatepickerMonth", ""]], viewQuery: function NglDatepickerMonth_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NglDay, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.days = _t);
    } }, inputs: { dateDisabled: "dateDisabled", selected: "selected", year: "year", month: "month", day: "day", firstDayOfWeek: "firstDayOfWeek", minDate: "minDate", maxDate: "maxDate" }, outputs: { selectDate: "selectDate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c23, decls: 1, vars: 2, consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "gridcell", 3, "slds-is-today", "isActive", "nglDay", "nglDaySelected", "nglDayDisabled", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "gridcell", 3, "isActive", "nglDay", "nglDaySelected", "nglDayDisabled", "click"], [1, "slds-day"]], template: function NglDatepickerMonth_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglDatepickerMonth_tr_0_Template, 2, 2, "tr", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.weeks)("ngForTrackBy", ctx.indexTrackBy);
    } }, directives: [ɵngcc1.NgForOf, NglDay], encapsulation: 2, changeDetection: 0 });
NglDatepickerMonth.ctorParameters = () => [
    { type: NgZone }
];
NglDatepickerMonth.propDecorators = {
    selected: [{ type: Input }],
    year: [{ type: Input }],
    month: [{ type: Input }],
    day: [{ type: Input }],
    firstDayOfWeek: [{ type: Input }],
    minDate: [{ type: Input }],
    maxDate: [{ type: Input }],
    dateDisabled: [{ type: Input }],
    selectDate: [{ type: Output }],
    days: [{ type: ViewChildren, args: [NglDay,] }]
};

const KEYBOARD_MOVES = {
    [UP_ARROW]: ['Move', -7],
    [LEFT_ARROW]: ['Move', -1],
    [DOWN_ARROW]: ['Move', 7],
    [RIGHT_ARROW]: ['Move', 1],
    [PAGE_UP]: ['MoveMonth', -1],
    [PAGE_DOWN]: ['MoveMonth', 1],
    [HOME]: ['MoveTo', 1],
    [END]: ['MoveTo', 31],
};
class NglDatepicker {
    constructor(dtInput, defaultConfig, locale, element) {
        this.dtInput = dtInput;
        this.element = element;
        this.dateDisabled = null;
        this.dateChange = new EventEmitter();
        this.uid = uniqueId('datepicker');
        const config = Object.assign(Object.assign({}, new NglDatepickerConfig(locale)), defaultConfig);
        this.monthNames = config.monthNames;
        this.dayNamesShort = config.dayNamesShort;
        this.dayNamesLong = config.dayNamesLong;
        this.firstDayOfWeek = config.firstDayOfWeek;
        this.showToday = config.showToday;
        this.relativeYearFrom = config.relativeYearFrom;
        this.relativeYearTo = config.relativeYearTo;
        this.todayLabel = config.todayLabel;
        this.previousMonthLabel = config.previousMonthLabel;
        this.nextMonthLabel = config.nextMonthLabel;
    }
    set date(date) {
        this._date = parseDate(date);
    }
    ngOnInit() {
        this.setMinMaxDates();
        this.setCurrent(this._date || getToday());
    }
    ngOnChanges(changes) {
        if ((changes.date && changes.date.isFirstChange()) ||
            changes.relativeYearFrom || changes.relativeYearTo ||
            changes.min || changes.max) {
            this.setMinMaxDates();
        }
        if (changes.date) {
            this.setCurrent(this._date);
        }
    }
    moveYear(year) {
        this.setCurrent({ year: +year });
    }
    moveMonth(diff) {
        this.moveCalendar('MoveMonth', diff);
    }
    keyboardHandler(evt) {
        const keyCode = evt.keyCode;
        if (keyCode === ENTER) {
            trapEvent(evt);
            if (!this.isDisabledDate(this.current)) {
                this.select(this.current);
            }
            return;
        }
        const move = KEYBOARD_MOVES[keyCode];
        if (!move) {
            return;
        }
        // Handle keyboard event inside datepicker
        trapEvent(evt);
        const [code, param] = move;
        this.moveCalendar(code, param);
        this.focusActiveDay();
    }
    select(date) {
        if (date.disabled) {
            return;
        }
        const { year, month, day } = date;
        this.dateChange.emit(new Date(year, month, day));
    }
    selectToday() {
        const today = getToday();
        if (this.isDisabledDate(today)) {
            this.setCurrent(today);
        }
        else {
            this.dateChange.emit(new Date());
        }
    }
    ngAfterViewInit() {
        if (this.dtInput) {
            const el = this.element.nativeElement;
            this.dtInput.updateDatepickerSize(el.offsetWidth, el.offsetHeight);
            this.focusActiveDay();
        }
    }
    /** Whether the previous period button is disabled. */
    previousDisabled() {
        return this.minDate && isSameMonth(this.current, this.minDate);
    }
    /** Whether the next period button is disabled. */
    nextDisabled() {
        return this.maxDate && isSameMonth(this.current, this.maxDate);
    }
    focusActiveDay() {
        this.monthView.focusActiveDay();
    }
    moveCalendar(code, param) {
        const { year, month, day } = this.current;
        const date = new Date(year, month, day, 12);
        if (code === 'Move') {
            date.setDate(day + (+param));
            this.setCurrent({ year: date.getFullYear(), month: date.getMonth(), day: date.getDate() });
        }
        else if (code === 'MoveMonth') {
            date.setMonth(month + (+param), 1);
            this.setCurrent({ year: date.getFullYear(), month: date.getMonth(), day });
        }
        else if (code === 'MoveTo') {
            this.setCurrent({ day: +param });
        }
    }
    setCurrent(d, doRender = true) {
        this.current = Object.assign(Object.assign({}, this.current), d);
        // Keep current inside minimum/maximum range
        if (compareDate(this.current, this.minDate) < 0) {
            this.current = this.minDate;
        }
        else if (compareDate(this.current, this.maxDate) > 0) {
            this.current = this.maxDate;
        }
        if (doRender) {
            this.render();
        }
    }
    render() {
        const { year, month, day } = this.current;
        this.monthLabel = this.monthNames[month];
        // Keep current day inside limits of this month
        this.setCurrent({ day: Math.min(day, numberOfDaysInMonth(year, month)) }, false);
    }
    /** Date filter for the month */
    isDisabledDate(date) {
        return isDisabled(date, this.dateDisabled, this.minDate, this.maxDate);
    }
    setMinMaxDates() {
        const { year } = getToday();
        this.minDate = this.min ? parseDate(this.min) : { year: year + this.relativeYearFrom, month: 0, day: 1 };
        this.maxDate = this.max ? parseDate(this.max) : { year: year + this.relativeYearTo, month: 11, day: 31 };
    }
}
NglDatepicker.ɵfac = function NglDatepicker_Factory(t) { return new (t || NglDatepicker)(ɵngcc0.ɵɵdirectiveInject(NglDatepickerInput, 8), ɵngcc0.ɵɵdirectiveInject(NGL_DATEPICKER_CONFIG, 8), ɵngcc0.ɵɵdirectiveInject(LOCALE_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NglDatepicker.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglDatepicker, selectors: [["ngl-datepicker"]], viewQuery: function NglDatepicker_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NglDatepickerMonth, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthView = _t.first);
    } }, hostVars: 2, hostBindings: function NglDatepicker_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-datepicker", true);
    } }, inputs: { dateDisabled: "dateDisabled", monthNames: "monthNames", dayNamesShort: "dayNamesShort", dayNamesLong: "dayNamesLong", firstDayOfWeek: "firstDayOfWeek", showToday: "showToday", relativeYearFrom: "relativeYearFrom", relativeYearTo: "relativeYearTo", todayLabel: "todayLabel", previousMonthLabel: "previousMonthLabel", nextMonthLabel: "nextMonthLabel", date: "date", min: "min", max: "max" }, outputs: { dateChange: "dateChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 20, vars: 17, consts: [[1, "slds-datepicker__filter", "slds-grid"], [1, "slds-datepicker__filter_month", "slds-grid", "slds-grid_align-spread", "slds-grow"], [1, "slds-align-middle"], ["type", "button", 1, "slds-button", "slds-button_icon-container", 3, "disabled", "title", "click"], ["nglIconName", "left", 1, "slds-button__icon"], [1, "slds-assistive-text"], ["aria-live", "assertive", "aria-atomic", "true", 1, "slds-align-middle", 3, "id"], ["nglIconName", "right", 1, "slds-button__icon"], [1, "slds-shrink-none", 3, "year", "from", "to", "yearChange"], ["role", "grid", 1, "datepicker__month", 3, "keydown"], ["nglWeekdays", "", 3, "firstDayOfWeek", "dayNamesShort", "dayNamesLong"], ["nglDatepickerMonth", "", 3, "year", "month", "day", "selected", "firstDayOfWeek", "minDate", "maxDate", "dateDisabled", "selectDate", 4, "ngIf"], ["class", "slds-button slds-align_absolute-center slds-text-link", 3, "click", 4, "ngIf"], ["nglDatepickerMonth", "", 3, "year", "month", "day", "selected", "firstDayOfWeek", "minDate", "maxDate", "dateDisabled", "selectDate"], [1, "slds-button", "slds-align_absolute-center", "slds-text-link", 3, "click"]], template: function NglDatepicker_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "button", 3);
        ɵngcc0.ɵɵlistener("click", function NglDatepicker_Template_button_click_3_listener() { return ctx.moveMonth(-1); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(4, "svg", 4);
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(5, "span", 5);
        ɵngcc0.ɵɵtext(6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "h2", 6);
        ɵngcc0.ɵɵtext(8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "div", 2);
        ɵngcc0.ɵɵelementStart(10, "button", 3);
        ɵngcc0.ɵɵlistener("click", function NglDatepicker_Template_button_click_10_listener() { return ctx.moveMonth(1); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(11, "svg", 7);
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(12, "span", 5);
        ɵngcc0.ɵɵtext(13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(14, "ngl-date-year", 8);
        ɵngcc0.ɵɵlistener("yearChange", function NglDatepicker_Template_ngl_date_year_yearChange_14_listener($event) { return ctx.moveYear($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(15, "table", 9);
        ɵngcc0.ɵɵlistener("keydown", function NglDatepicker_Template_table_keydown_15_listener($event) { return ctx.keyboardHandler($event); });
        ɵngcc0.ɵɵelementStart(16, "thead");
        ɵngcc0.ɵɵelement(17, "tr", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(18, NglDatepicker_tbody_18_Template, 1, 8, "tbody", 11);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(19, NglDatepicker_button_19_Template, 2, 1, "button", 12);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("disabled", ctx.previousDisabled())("title", ctx.previousMonthLabel);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.previousMonthLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.uid + "_month");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.monthLabel);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("disabled", ctx.nextDisabled())("title", ctx.nextMonthLabel);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.nextMonthLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("year", ctx.current.year)("from", ctx.minDate)("to", ctx.maxDate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("aria-labelledby", ctx.uid + "_month");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("firstDayOfWeek", ctx.firstDayOfWeek)("dayNamesShort", ctx.dayNamesShort)("dayNamesLong", ctx.dayNamesLong);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.current);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showToday);
    } }, directives: function () { return [NglIconSvg, NglDatepickerYear, NglDatepickerWeekdays, ɵngcc1.NgIf, NglDatepickerMonth]; }, styles: ["[_nghost-%COMP%] { display: block; }"], changeDetection: 0 });
NglDatepicker.ctorParameters = () => [
    { type: NglDatepickerInput, decorators: [{ type: Optional }, { type: Inject, args: [NglDatepickerInput,] }] },
    { type: NglDatepickerConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_DATEPICKER_CONFIG,] }] },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
    { type: ElementRef }
];
NglDatepicker.propDecorators = {
    monthNames: [{ type: Input }],
    dayNamesShort: [{ type: Input }],
    dayNamesLong: [{ type: Input }],
    dateDisabled: [{ type: Input }],
    date: [{ type: Input }],
    dateChange: [{ type: Output }],
    showToday: [{ type: Input }],
    firstDayOfWeek: [{ type: Input }],
    relativeYearFrom: [{ type: Input }],
    relativeYearTo: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    todayLabel: [{ type: Input }],
    previousMonthLabel: [{ type: Input }],
    nextMonthLabel: [{ type: Input }],
    monthView: [{ type: ViewChild, args: [NglDatepickerMonth,] }]
};
__decorate([
    InputBoolean()
], NglDatepicker.prototype, "showToday", void 0);
__decorate([
    InputNumber()
], NglDatepicker.prototype, "firstDayOfWeek", void 0);

class NglDatepickerInputDirective {
    constructor(element, renderer, datepickerInput) {
        this.element = element;
        this.renderer = renderer;
        this.datepickerInput = datepickerInput;
        renderer.addClass(element.nativeElement, 'slds-input');
        renderer.setAttribute(element.nativeElement, 'autocomplete', 'off');
        renderer.setAttribute(element.nativeElement, 'id', this.datepickerInput.uid);
        this.datepickerInput.inputEl = this;
    }
    onClick() {
        this.datepickerInput.onTriggerClick('input');
    }
    onKeydown(evt) {
        this.datepickerInput.onKeyboardInput(evt);
    }
    onInput() {
        setTimeout(() => this.datepickerInput.onInputChange(), 0);
    }
    onBlur() {
        this.datepickerInput.onBlur();
    }
    setPlaceholder(placeholder) {
        this.renderer.setAttribute(this.element.nativeElement, 'placeholder', placeholder);
    }
    setDisabled(disabled) {
        this.renderer.setProperty(this.element.nativeElement, 'disabled', disabled);
    }
    ngOnDestroy() {
        this.datepickerInput.inputEl = null;
    }
}
NglDatepickerInputDirective.ɵfac = function NglDatepickerInputDirective_Factory(t) { return new (t || NglDatepickerInputDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(NglDatepickerInput)); };
NglDatepickerInputDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglDatepickerInputDirective, selectors: [["input", "nglDatepickerInput", ""]], hostBindings: function NglDatepickerInputDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NglDatepickerInputDirective_click_HostBindingHandler() { return ctx.onClick(); })("keydown", function NglDatepickerInputDirective_keydown_HostBindingHandler($event) { return ctx.onKeydown($event); })("input", function NglDatepickerInputDirective_input_HostBindingHandler() { return ctx.onInput(); })("blur", function NglDatepickerInputDirective_blur_HostBindingHandler() { return ctx.onBlur(); });
    } }, exportAs: ["nglDatepickerInput"] });
NglDatepickerInputDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NglDatepickerInput }
];
NglDatepickerInputDirective.propDecorators = {
    onClick: [{ type: HostListener, args: ['click',] }],
    onKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    onInput: [{ type: HostListener, args: ['input',] }],
    onBlur: [{ type: HostListener, args: ['blur',] }]
};

class NglDatepickerWeekdays {
    constructor() {
        this.weekdays = [];
    }
    ngOnChanges(changes) {
        this.weekdays = [];
        for (let i = 0; i < 7; i++) {
            const offset = (this.firstDayOfWeek + i) % 7;
            this.weekdays.push({
                id: `weekday-${i}`,
                label: this.dayNamesShort[offset],
                title: this.dayNamesLong[offset],
            });
        }
    }
}
NglDatepickerWeekdays.ɵfac = function NglDatepickerWeekdays_Factory(t) { return new (t || NglDatepickerWeekdays)(); };
NglDatepickerWeekdays.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglDatepickerWeekdays, selectors: [["tr", "nglWeekdays", ""]], inputs: { dayNamesShort: "dayNamesShort", dayNamesLong: "dayNamesLong", firstDayOfWeek: "firstDayOfWeek" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c24, decls: 1, vars: 1, consts: [["scope", "col", 3, "id", 4, "ngFor", "ngForOf"], ["scope", "col", 3, "id"], [3, "title"]], template: function NglDatepickerWeekdays_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglDatepickerWeekdays_th_0_Template, 3, 3, "th", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.weekdays);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
NglDatepickerWeekdays.propDecorators = {
    dayNamesShort: [{ type: Input }],
    dayNamesLong: [{ type: Input }],
    firstDayOfWeek: [{ type: Input }]
};

class NglDatepickerYear {
    constructor() {
        this.uid = uniqueId('datepicker_year');
        this.yearChange = new EventEmitter();
    }
    change($event) {
        this.yearChange.emit($event);
    }
    ngOnChanges() {
        this.range = this.getRange();
    }
    getRange() {
        const minYear = Math.min(this.from.year, this.year);
        const maxYear = Math.max(this.to.year, this.year);
        const size = maxYear - minYear;
        return Array.apply(null, { length: size + 1 }).map((value, index) => minYear + index);
    }
}
NglDatepickerYear.ɵfac = function NglDatepickerYear_Factory(t) { return new (t || NglDatepickerYear)(); };
NglDatepickerYear.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglDatepickerYear, selectors: [["ngl-date-year"]], inputs: { from: "from", to: "to", year: "year" }, outputs: { yearChange: "yearChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 5, vars: 4, consts: [[1, "slds-assistive-text"], [1, "slds-select_container"], [1, "slds-select", 3, "id", "ngModel", "ngModelChange"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"]], template: function NglDatepickerYear_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵtext(1, "Pick a Year");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "select", 2);
        ɵngcc0.ɵɵlistener("ngModelChange", function NglDatepickerYear_Template_select_ngModelChange_3_listener($event) { return ctx.change($event); });
        ɵngcc0.ɵɵtemplate(4, NglDatepickerYear_option_4_Template, 2, 2, "option", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("for", ctx.uid);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("id", ctx.uid)("ngModel", ctx.year);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.range);
    } }, directives: [ɵngcc4.SelectControlValueAccessor, ɵngcc4.NgControlStatus, ɵngcc4.NgModel, ɵngcc1.NgForOf, ɵngcc4.NgSelectOption, ɵngcc4.ɵNgSelectMultipleOption], encapsulation: 2, changeDetection: 0 });
NglDatepickerYear.propDecorators = {
    from: [{ type: Input }],
    to: [{ type: Input }],
    year: [{ type: Input }],
    yearChange: [{ type: Output }]
};
__decorate([
    InputNumber()
], NglDatepickerYear.prototype, "year", void 0);

const EXPORTS = [
    NglDatepicker, NglDatepickerInput, NglDatepickerInputDirective,
];
class NglDatepickersModule {
}
NglDatepickersModule.ɵfac = function NglDatepickersModule_Factory(t) { return new (t || NglDatepickersModule)(); };
NglDatepickersModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglDatepickersModule });
NglDatepickersModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [NglDateAdapter], imports: [[
            CommonModule,
            FormsModule,
            NglIconsModule,
            NglInternalOutletModule,
            OverlayModule,
            NglClickOutsideModule,
            NglOverlayModule,
        ]] });

class BaseDynamicIconComponent {
}
BaseDynamicIconComponent.ɵfac = function BaseDynamicIconComponent_Factory(t) { return new (t || BaseDynamicIconComponent)(); };
BaseDynamicIconComponent.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: BaseDynamicIconComponent, inputs: { alternativeText: "alternativeText" } });
BaseDynamicIconComponent.propDecorators = {
    alternativeText: [{ type: Input }]
};

class NglDynamicIcon extends BaseDynamicIconComponent {
}
NglDynamicIcon.ɵfac = /*@__PURE__*/ function () { let ɵNglDynamicIcon_BaseFactory; return function NglDynamicIcon_Factory(t) { return (ɵNglDynamicIcon_BaseFactory || (ɵNglDynamicIcon_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglDynamicIcon)))(t || NglDynamicIcon); }; }();
NglDynamicIcon.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglDynamicIcon, selectors: [["ngl-dynamic-icon"]], inputs: { type: "type", option: "option" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 5, consts: [[3, "ngSwitch"], [3, "alternativeText", 4, "ngSwitchCase"], [3, "option", "alternativeText", 4, "ngSwitchCase"], [3, "alternativeText"], [3, "option", "alternativeText"]], template: function NglDynamicIcon_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵtemplate(1, NglDynamicIcon_ngl_dynamic_icon_ellie_1_Template, 1, 1, "ngl-dynamic-icon-ellie", 1);
        ɵngcc0.ɵɵtemplate(2, NglDynamicIcon_ngl_dynamic_icon_eq_2_Template, 1, 2, "ngl-dynamic-icon-eq", 2);
        ɵngcc0.ɵɵtemplate(3, NglDynamicIcon_ngl_dynamic_icon_score_3_Template, 1, 2, "ngl-dynamic-icon-score", 2);
        ɵngcc0.ɵɵtemplate(4, NglDynamicIcon_ngl_dynamic_icon_waffle_4_Template, 1, 1, "ngl-dynamic-icon-waffle", 1);
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.type);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "ellie");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "eq");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "score");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "waffle");
    } }, directives: function () { return [ɵngcc1.NgSwitch, ɵngcc1.NgSwitchCase, NglDynamicIconEllie, NglDynamicIconEq, NglDynamicIconScore, NglDynamicIconWaffle]; }, encapsulation: 2, changeDetection: 0 });
NglDynamicIcon.propDecorators = {
    type: [{ type: Input }],
    option: [{ type: Input }]
};

class NglDynamicIconEllie extends BaseDynamicIconComponent {
}
NglDynamicIconEllie.ɵfac = /*@__PURE__*/ function () { let ɵNglDynamicIconEllie_BaseFactory; return function NglDynamicIconEllie_Factory(t) { return (ɵNglDynamicIconEllie_BaseFactory || (ɵNglDynamicIconEllie_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglDynamicIconEllie)))(t || NglDynamicIconEllie); }; }();
NglDynamicIconEllie.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglDynamicIconEllie, selectors: [["ngl-dynamic-icon-ellie"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 43, vars: 1, consts: [[1, "slds-icon-ellie", "slds-is-animated"], ["viewbox", "0 0 280 14", "aria-hidden", "true"], ["cx", "7", "cy", "7", "r", "4"], ["cx", "7", "cy", "7", "r", "3"], ["cx", "21", "cy", "7", "r", "4"], ["cx", "21", "cy", "7", "r", "3"], ["cx", "35", "cy", "7", "r", "4"], ["cx", "35", "cy", "7", "r", "3"], ["cx", "49", "cy", "7", "r", "4"], ["cx", "49", "cy", "7", "r", "3"], ["cx", "63", "cy", "7", "r", "4"], ["cx", "63", "cy", "7", "r", "3"], ["cx", "77", "cy", "7", "r", "4"], ["cx", "77", "cy", "7", "r", "3"], ["cx", "91", "cy", "7", "r", "4"], ["cx", "91", "cy", "7", "r", "3"], ["cx", "105", "cy", "7", "r", "4"], ["cx", "105", "cy", "7", "r", "3"], ["cx", "119", "cy", "7", "r", "4"], ["cx", "119", "cy", "7", "r", "3"], ["cx", "133", "cy", "7", "r", "4"], ["cx", "133", "cy", "7", "r", "3"], ["cx", "147", "cy", "7", "r", "4"], ["cx", "147", "cy", "7", "r", "3"], ["cx", "161", "cy", "7", "r", "4"], ["cx", "161", "cy", "7", "r", "3"], ["cx", "175", "cy", "7", "r", "4"], ["cx", "175", "cy", "7", "r", "3"], ["cx", "189", "cy", "7", "r", "4"], ["cx", "189", "cy", "7", "r", "3"], ["cx", "203", "cy", "7", "r", "4"], ["cx", "203", "cy", "7", "r", "3"], ["cx", "217", "cy", "7", "r", "4"], ["cx", "217", "cy", "7", "r", "3"], ["cx", "231", "cy", "7", "r", "4"], ["cx", "231", "cy", "7", "r", "3"], ["cx", "245", "cy", "7", "r", "4"], ["cx", "245", "cy", "7", "r", "3"], ["cx", "259", "cy", "7", "r", "4"], ["cx", "259", "cy", "7", "r", "3"], ["cx", "273", "cy", "7", "r", "4"], ["cx", "273", "cy", "7", "r", "3"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-assistive-text"]], template: function NglDynamicIconEllie_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "svg", 1);
        ɵngcc0.ɵɵelement(2, "circle", 2);
        ɵngcc0.ɵɵelement(3, "circle", 3);
        ɵngcc0.ɵɵelement(4, "circle", 4);
        ɵngcc0.ɵɵelement(5, "circle", 5);
        ɵngcc0.ɵɵelement(6, "circle", 6);
        ɵngcc0.ɵɵelement(7, "circle", 7);
        ɵngcc0.ɵɵelement(8, "circle", 8);
        ɵngcc0.ɵɵelement(9, "circle", 9);
        ɵngcc0.ɵɵelement(10, "circle", 10);
        ɵngcc0.ɵɵelement(11, "circle", 11);
        ɵngcc0.ɵɵelement(12, "circle", 12);
        ɵngcc0.ɵɵelement(13, "circle", 13);
        ɵngcc0.ɵɵelement(14, "circle", 14);
        ɵngcc0.ɵɵelement(15, "circle", 15);
        ɵngcc0.ɵɵelement(16, "circle", 16);
        ɵngcc0.ɵɵelement(17, "circle", 17);
        ɵngcc0.ɵɵelement(18, "circle", 18);
        ɵngcc0.ɵɵelement(19, "circle", 19);
        ɵngcc0.ɵɵelement(20, "circle", 20);
        ɵngcc0.ɵɵelement(21, "circle", 21);
        ɵngcc0.ɵɵelement(22, "circle", 22);
        ɵngcc0.ɵɵelement(23, "circle", 23);
        ɵngcc0.ɵɵelement(24, "circle", 24);
        ɵngcc0.ɵɵelement(25, "circle", 25);
        ɵngcc0.ɵɵelement(26, "circle", 26);
        ɵngcc0.ɵɵelement(27, "circle", 27);
        ɵngcc0.ɵɵelement(28, "circle", 28);
        ɵngcc0.ɵɵelement(29, "circle", 29);
        ɵngcc0.ɵɵelement(30, "circle", 30);
        ɵngcc0.ɵɵelement(31, "circle", 31);
        ɵngcc0.ɵɵelement(32, "circle", 32);
        ɵngcc0.ɵɵelement(33, "circle", 33);
        ɵngcc0.ɵɵelement(34, "circle", 34);
        ɵngcc0.ɵɵelement(35, "circle", 35);
        ɵngcc0.ɵɵelement(36, "circle", 36);
        ɵngcc0.ɵɵelement(37, "circle", 37);
        ɵngcc0.ɵɵelement(38, "circle", 38);
        ɵngcc0.ɵɵelement(39, "circle", 39);
        ɵngcc0.ɵɵelement(40, "circle", 40);
        ɵngcc0.ɵɵelement(41, "circle", 41);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(42, NglDynamicIconEllie_span_42_Template, 2, 1, "span", 42);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(42);
        ɵngcc0.ɵɵproperty("ngIf", ctx.alternativeText);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });

class NglDynamicIconEq extends BaseDynamicIconComponent {
    set option(option) {
        this._option = option || 'play';
    }
    get option() {
        return this._option;
    }
    isAnimated() {
        return this.option !== 'stop';
    }
}
NglDynamicIconEq.ɵfac = /*@__PURE__*/ function () { let ɵNglDynamicIconEq_BaseFactory; return function NglDynamicIconEq_Factory(t) { return (ɵNglDynamicIconEq_BaseFactory || (ɵNglDynamicIconEq_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglDynamicIconEq)))(t || NglDynamicIconEq); }; }();
NglDynamicIconEq.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglDynamicIconEq, selectors: [["ngl-dynamic-icon-eq"]], inputs: { option: "option" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 3, consts: [[1, "slds-icon-eq"], [1, "slds-icon-eq__bar"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-assistive-text"]], template: function NglDynamicIconEq_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelement(1, "div", 1);
        ɵngcc0.ɵɵelement(2, "div", 1);
        ɵngcc0.ɵɵelement(3, "div", 1);
        ɵngcc0.ɵɵtemplate(4, NglDynamicIconEq_span_4_Template, 2, 1, "span", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-is-animated", ctx.isAnimated());
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.alternativeText);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
NglDynamicIconEq.propDecorators = {
    option: [{ type: Input }]
};

class NglDynamicIconScore extends BaseDynamicIconComponent {
    set option(option) {
        this._option = option || 'positive';
    }
    get option() {
        return this._option;
    }
}
NglDynamicIconScore.ɵfac = /*@__PURE__*/ function () { let ɵNglDynamicIconScore_BaseFactory; return function NglDynamicIconScore_Factory(t) { return (ɵNglDynamicIconScore_BaseFactory || (ɵNglDynamicIconScore_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglDynamicIconScore)))(t || NglDynamicIconScore); }; }();
NglDynamicIconScore.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglDynamicIconScore, selectors: [["ngl-dynamic-icon-score"]], inputs: { option: "option" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 2, consts: [[1, "slds-icon-score"], ["viewBox", "0 0 5 5", "aria-hidden", "true", 1, "slds-icon-score__positive"], ["cx", "50%", "cy", "50%", "r", "1.875"], ["viewBox", "0 0 5 5", "aria-hidden", "true", 1, "slds-icon-score__negative"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-assistive-text"]], template: function NglDynamicIconScore_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "svg", 1);
        ɵngcc0.ɵɵelement(2, "circle", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "svg", 3);
        ɵngcc0.ɵɵelement(4, "circle", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, NglDynamicIconScore_span_5_Template, 2, 1, "span", 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-slds-state", ctx.option);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.alternativeText);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
NglDynamicIconScore.propDecorators = {
    option: [{ type: Input }]
};

class NglDynamicIconWaffle extends BaseDynamicIconComponent {
}
NglDynamicIconWaffle.ɵfac = /*@__PURE__*/ function () { let ɵNglDynamicIconWaffle_BaseFactory; return function NglDynamicIconWaffle_Factory(t) { return (ɵNglDynamicIconWaffle_BaseFactory || (ɵNglDynamicIconWaffle_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglDynamicIconWaffle)))(t || NglDynamicIconWaffle); }; }();
NglDynamicIconWaffle.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglDynamicIconWaffle, selectors: [["ngl-dynamic-icon-waffle"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 12, vars: 1, consts: [["type", "button", 1, "slds-button", "slds-icon-waffle_container"], [1, "slds-icon-waffle"], [1, "slds-r1"], [1, "slds-r2"], [1, "slds-r3"], [1, "slds-r4"], [1, "slds-r5"], [1, "slds-r6"], [1, "slds-r7"], [1, "slds-r8"], [1, "slds-r9"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-assistive-text"]], template: function NglDynamicIconWaffle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵelement(3, "span", 3);
        ɵngcc0.ɵɵelement(4, "span", 4);
        ɵngcc0.ɵɵelement(5, "span", 5);
        ɵngcc0.ɵɵelement(6, "span", 6);
        ɵngcc0.ɵɵelement(7, "span", 7);
        ɵngcc0.ɵɵelement(8, "span", 8);
        ɵngcc0.ɵɵelement(9, "span", 9);
        ɵngcc0.ɵɵelement(10, "span", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, NglDynamicIconWaffle_span_11_Template, 2, 1, "span", 11);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(11);
        ɵngcc0.ɵɵproperty("ngIf", ctx.alternativeText);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });

const NGL_DYNAMIC_ICON_DIRECTIVES = [
    NglDynamicIcon,
    NglDynamicIconEllie,
    NglDynamicIconEq,
    NglDynamicIconScore,
    NglDynamicIconWaffle,
];
class NglDynamicIconsModule {
}
NglDynamicIconsModule.ɵfac = function NglDynamicIconsModule_Factory(t) { return new (t || NglDynamicIconsModule)(); };
NglDynamicIconsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglDynamicIconsModule });
NglDynamicIconsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

class NglFile {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.renderer.addClass(this.element.nativeElement, 'slds-file');
        this.renderer.addClass(this.element.nativeElement, 'slds-file_card');
    }
}
NglFile.ɵfac = function NglFile_Factory(t) { return new (t || NglFile)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglFile.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglFile, selectors: [["ngl-file"]], hostVars: 2, hostBindings: function NglFile_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-has-title", ctx.text);
    } }, inputs: { text: "text", iconName: "iconName" }, ngContentSelectors: _c0, decls: 3, vars: 1, consts: [["class", "slds-file__title slds-file__title_card", 4, "ngIf"], [1, "slds-file__title", "slds-file__title_card"], [1, "slds-media", "slds-media_small", "slds-media_center"], ["class", "slds-media__figure slds-line-height_reset", 4, "ngIf"], [1, "slds-media__body"], [1, "slds-file__text", "slds-truncate", 3, "title", "nglInternalOutlet"], [1, "slds-media__figure", "slds-line-height_reset"], [3, "iconName"]], template: function NglFile_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "figure");
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, NglFile_figcaption_2_Template, 5, 3, "figcaption", 0);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.text);
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet, NglIcon], encapsulation: 2, changeDetection: 0 });
NglFile.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglFile.propDecorators = {
    text: [{ type: HostBinding, args: ['class.slds-has-title',] }, { type: Input }],
    iconName: [{ type: Input }]
};

class NglFileCrop {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.cropClass = 'slds-file__crop';
        // this.renderer.addClass(this.element.nativeElement, this.cropClass);
    }
    set nglFileCrop(ratio) {
        const nativeElement = this.element.nativeElement;
        if (this.currentRatio) {
            this.renderer.removeClass(nativeElement, `${this.cropClass}`);
            this.renderer.removeClass(nativeElement, `${this.cropClass}_${this.currentRatio}`);
        }
        if (ratio) {
            this.renderer.addClass(nativeElement, `${this.cropClass}`);
            this.renderer.addClass(nativeElement, `${this.cropClass}_${ratio}`);
        }
        this.currentRatio = ratio;
    }
}
NglFileCrop.ɵfac = function NglFileCrop_Factory(t) { return new (t || NglFileCrop)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglFileCrop.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglFileCrop, selectors: [["", "nglFileCrop", ""]], inputs: { nglFileCrop: "nglFileCrop" } });
NglFileCrop.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglFileCrop.propDecorators = {
    nglFileCrop: [{ type: Input }]
};

class NglFilesModule {
}
NglFilesModule.ɵfac = function NglFilesModule_Factory(t) { return new (t || NglFilesModule)(); };
NglFilesModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglFilesModule });
NglFilesModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglIconsModule, NglInternalOutletModule]] });

const FILE_EXT_REG = /(^[.]\w*)$/m;
function isFileTypeAccepted(accept, file) {
    if (typeof accept === 'string') {
        accept = accept.split(',');
    }
    return accept.some((acc) => {
        if (FILE_EXT_REG.test(acc)) {
            return acc === `.${file.name.split('.').pop()}`;
        }
        else {
            return (new RegExp(acc.replace('*', '.\*'))).test(file.type);
        }
    });
}

class NglFileUpload {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        /**
         * File types that can be accepted. See [input accept Attribute](https://www.w3schools.com/tags/att_input_accept.asp).
         */
        this.accept = null;
        /**
         * Whether file selection is disabled.
         */
        this.disabled = false;
        /**
          * How many files can be selected simultaneously. `0` means unlimited.
          */
        this.maxFiles = 1;
        /**
         * File size limit in bytes. `0` means unlimited.
         */
        this.maxFilesize = 0;
        /**
         * Message to display when there is in an error state.
         */
        this.error = null;
        /**
         * Text for button to open file selector.
         */
        this.uploadButtonLabel = 'Upload Files';
        /**
         * Text to display inside drop zone.
         */
        this.dropZoneLabel = 'or Drop Files';
        this.uid = uniqueId('file-upload');
        this.isDragOver = false;
        this.files = [];
        this.onChange = null;
        this.onTouched = () => { };
        this.validatorChange = () => { };
        this.renderer.addClass(this.element.nativeElement, 'slds-form-element');
    }
    writeValue(value) {
        this.files = value;
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouched = fn; }
    registerOnValidatorChange(fn) { this.validatorChange = fn; }
    setDisabledState(isDisabled) { this.disabled = isDisabled; }
    validate(c) {
        const files = c.value;
        if (!files || files.length === 0) {
            return null;
        }
        if (this.maxFiles > 0 && files.length > this.maxFiles) {
            return { nglFileUpload: { maxFiles: files.length } };
        }
        for (let i = 0, n = files.length; i < n; i++) {
            const file = files[i];
            if (this.accept && !isFileTypeAccepted(this.accept, file)) {
                return { nglFileUpload: { invalidType: file } };
            }
            if (this.maxFilesize && file.size > this.maxFilesize) {
                return { nglFileUpload: { maxFilesize: file } };
            }
        }
        return null;
    }
    ngOnChanges(changes) {
        if (changes['maxFiles'] || changes['maxFilesize'] || changes['accept']) {
            this.validatorChange();
        }
    }
    onDropZone(evt) {
        trapEvent(evt);
        if (this.disabled) {
            return;
        }
        this.isDragOver = evt.type === 'dragover';
        if (evt.type === 'drop' && evt.dataTransfer) {
            this.select(evt.dataTransfer.files);
        }
    }
    onInputChange(files) {
        this.select(files);
    }
    select(files) {
        this.onChange(Array.from(files));
    }
}
NglFileUpload.ɵfac = function NglFileUpload_Factory(t) { return new (t || NglFileUpload)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglFileUpload.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglFileUpload, selectors: [["ngl-file-upload"]], hostVars: 2, hostBindings: function NglFileUpload_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-has-error", ctx.error);
    } }, inputs: { accept: "accept", disabled: "disabled", maxFiles: "maxFiles", maxFilesize: "maxFilesize", error: "error", uploadButtonLabel: "uploadButtonLabel", dropZoneLabel: "dropZoneLabel", label: "label" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: NglFileUpload,
                multi: true
            },
            {
                provide: NG_VALIDATORS,
                useExisting: NglFileUpload,
                multi: true
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 12, vars: 14, consts: [["class", "slds-form-element__label", 3, "id", "nglInternalOutlet", 4, "ngIf"], [1, "slds-form-element__control"], [1, "slds-file-selector", "slds-file-selector_files"], [1, "slds-file-selector__dropzone", 3, "dragover", "dragleave", "drop"], ["type", "file", 1, "slds-file-selector__input", "slds-assistive-text", 3, "id", "disabled", "multiple", "change"], [1, "slds-file-selector__body", 3, "id"], [1, "slds-file-selector__button", "slds-button", "slds-button_neutral"], ["nglIconName", "utility:upload", 1, "slds-button__icon", "slds-button__icon_left"], [1, "slds-file-selector__text", "slds-medium-show"], ["class", "slds-form-element__help", 3, "id", "nglInternalOutlet", 4, "ngIf"], [1, "slds-form-element__label", 3, "id", "nglInternalOutlet"], [1, "slds-form-element__help", 3, "id", "nglInternalOutlet"]], template: function NglFileUpload_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglFileUpload_span_0_Template, 1, 2, "span", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵlistener("dragover", function NglFileUpload_Template_div_dragover_3_listener($event) { return ctx.onDropZone($event); })("dragleave", function NglFileUpload_Template_div_dragleave_3_listener($event) { return ctx.onDropZone($event); })("drop", function NglFileUpload_Template_div_drop_3_listener($event) { return ctx.onDropZone($event); });
        ɵngcc0.ɵɵelementStart(4, "input", 4);
        ɵngcc0.ɵɵlistener("change", function NglFileUpload_Template_input_change_4_listener($event) { return ctx.onInputChange($event.target.files); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "label", 5);
        ɵngcc0.ɵɵelementStart(6, "span", 6);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(7, "svg", 7);
        ɵngcc0.ɵɵtext(8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(9, "span", 8);
        ɵngcc0.ɵɵtext(10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, NglFileUpload_div_11_Template, 1, 2, "div", 9);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.label);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵclassProp("slds-has-drag-over", ctx.isDragOver);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.uid)("disabled", ctx.disabled)("multiple", ctx.maxFiles !== 1);
        ɵngcc0.ɵɵattribute("accept", ctx.accept)("aria-describedby", ctx.error ? ctx.uid + "-error" : null)("aria-labelledby", ctx.uid + "-primary-label " + ctx.uid + "-secondary-label");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.uid + "-secondary-label");
        ɵngcc0.ɵɵattribute("for", ctx.uid);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.uploadButtonLabel);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.dropZoneLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.error);
    } }, directives: [ɵngcc1.NgIf, NglIconSvg, NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglFileUpload.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglFileUpload.propDecorators = {
    label: [{ type: Input }],
    accept: [{ type: Input }],
    disabled: [{ type: Input }],
    maxFiles: [{ type: Input }],
    maxFilesize: [{ type: Input }],
    error: [{ type: HostBinding, args: ['class.slds-has-error',] }, { type: Input }],
    uploadButtonLabel: [{ type: Input }],
    dropZoneLabel: [{ type: Input }]
};
__decorate([
    InputBoolean()
], NglFileUpload.prototype, "disabled", void 0);
__decorate([
    InputNumber()
], NglFileUpload.prototype, "maxFiles", void 0);
__decorate([
    InputNumber()
], NglFileUpload.prototype, "maxFilesize", void 0);

class NglFileUploadModule {
}
NglFileUploadModule.ɵfac = function NglFileUploadModule_Factory(t) { return new (t || NglFileUploadModule)(); };
NglFileUploadModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglFileUploadModule });
NglFileUploadModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglIconsModule, NglInternalOutletModule]] });

class NglInputElement {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.ɵRequiredSubject = new BehaviorSubject(false);
        if (!this.el.nativeElement.id) {
            this.renderer.setAttribute(this.el.nativeElement, 'id', uniqueId('input'));
        }
    }
    set required(required) {
        this.ɵRequiredSubject.next(toBoolean(required));
    }
    get id() {
        return this.el.nativeElement.id;
    }
}
NglInputElement.ɵfac = function NglInputElement_Factory(t) { return new (t || NglInputElement)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglInputElement.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglInputElement, selectors: [["input", "ngl", "", 3, "type", "checkbox", 3, "type", "radio"]], hostVars: 3, hostBindings: function NglInputElement_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-describedby", ctx.describedBy);
        ɵngcc0.ɵɵclassProp("slds-input", true);
    } }, inputs: { required: "required" } });
NglInputElement.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglInputElement.propDecorators = {
    describedBy: [{ type: HostBinding, args: ['attr.aria-describedby',] }],
    required: [{ type: Input }]
};

class NglInput {
    constructor(cd) {
        this.cd = cd;
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this._uid}`;
    }
    ngOnChanges() {
        this.input.describedBy = this.error ? this.errorId : null;
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <input> with [ngl] attribute inside NglInput`);
        }
        this.ɵRequiredSubscription = this.input.ɵRequiredSubject.subscribe((required) => {
            this.required = required;
            this.cd.detectChanges();
        });
        this._uid = this.input.id;
        this.cd.detectChanges();
    }
    ngOnDestroy() {
        if (this.ɵRequiredSubscription) {
            this.ɵRequiredSubscription.unsubscribe();
            this.ɵRequiredSubscription = null;
        }
    }
}
NglInput.ɵfac = function NglInput_Factory(t) { return new (t || NglInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglInput.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglInput, selectors: [["ngl-input"], ["", "ngl-input", ""]], contentQueries: function NglInput_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglInputElement, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 4, hostBindings: function NglInput_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-form-element", true)("slds-has-error", ctx.hasError);
    } }, inputs: { label: "label", error: "error", stacked: "stacked", fieldLevelHelpTooltip: "fieldLevelHelpTooltip" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 5, vars: 5, consts: [[3, "nglFormLabel", "required"], [3, "content", 4, "ngIf"], [1, "slds-form-element__control"], ["class", "slds-form-element__help", 3, "id", "nglInternalOutlet", 4, "ngIf"], [3, "content"], [1, "slds-form-element__help", 3, "id", "nglInternalOutlet"]], template: function NglInput_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelement(0, "label", 0);
        ɵngcc0.ɵɵtemplate(1, NglInput_ngl_form_help_1_Template, 1, 1, "ngl-form-help", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(4, NglInput_div_4_Template, 1, 2, "div", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("nglFormLabel", ctx.label)("required", ctx.required);
        ɵngcc0.ɵɵattribute("for", ctx._uid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.fieldLevelHelpTooltip);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasError);
    } }, directives: [NglFormLabel, ɵngcc1.NgIf, NglFormHelp, NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglInput.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NglInput.propDecorators = {
    input: [{ type: ContentChild, args: [NglInputElement, { static: true },] }],
    label: [{ type: Input }],
    error: [{ type: Input }],
    stacked: [{ type: Input }],
    fieldLevelHelpTooltip: [{ type: Input }],
    hasError: [{ type: HostBinding, args: ['class.slds-has-error',] }]
};
__decorate([
    InputBoolean()
], NglInput.prototype, "stacked", void 0);

const DIRECTIVES$4 = [
    NglInput,
    NglInputElement,
];
class NglInputModule {
}
NglInputModule.ɵfac = function NglInputModule_Factory(t) { return new (t || NglInputModule)(); };
NglInputModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglInputModule });
NglInputModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglFormsModule, NglInternalOutletModule]] });

class NglDropdownItem {
    constructor(element) {
        this.element = element;
        this.isFocused = false;
    }
    onFocus() {
        this.isFocused = true;
    }
    onBlur() {
        this.isFocused = false;
    }
    hasFocus() {
        return this.isFocused;
    }
    focus() {
        this.element.nativeElement.focus();
    }
}
NglDropdownItem.ɵfac = function NglDropdownItem_Factory(t) { return new (t || NglDropdownItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NglDropdownItem.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglDropdownItem, selectors: [["", "nglDropdownItem", ""]], hostAttrs: ["tabindex", "0"], hostBindings: function NglDropdownItem_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focus", function NglDropdownItem_focus_HostBindingHandler() { return ctx.onFocus(); })("blur", function NglDropdownItem_blur_HostBindingHandler() { return ctx.onBlur(); });
    } } });
NglDropdownItem.ctorParameters = () => [
    { type: ElementRef }
];
NglDropdownItem.propDecorators = {
    onFocus: [{ type: HostListener, args: ['focus',] }],
    onBlur: [{ type: HostListener, args: ['blur',] }]
};

const openEventEmitter = new EventEmitter();
class NglDropdown {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.handlePageEvents = true;
        this.isOpenChange = new EventEmitter();
        this.triggerFocusEventEmitter = new EventEmitter();
        this._isOpen = false;
        this.globalClickEventUnsubscriber = null;
        this.clickEventUnsubscriber = null;
    }
    set isOpen(isOpen) {
        this._isOpen = toBoolean(isOpen);
        if (this.isOpen) {
            this.clearGlobalClickTimeout();
            this.globalClickTimeout = setTimeout(() => {
                if (this.handlePageEvents) {
                    this._subscribeToClickEvents();
                }
            });
            this.renderer.addClass(this.element.nativeElement, 'slds-is-open');
        }
        else {
            this._unsubscribeFromClickEvents();
            this.renderer.removeClass(this.element.nativeElement, 'slds-is-open');
        }
        this.renderer.setAttribute(this.element.nativeElement, 'aria-expanded', `${this.isOpen}`);
    }
    get isOpen() {
        return this._isOpen;
    }
    onKeydownClose(eventName) {
        this.toggle(false);
        if (eventName === 'esc') {
            this.triggerFocusEventEmitter.emit(null);
        }
    }
    onKeydownFocusNext($event, direction) {
        $event.preventDefault();
        this.focusItem(direction);
    }
    ngOnInit() {
        this.openEventSubscription = openEventEmitter.subscribe(this.handleDropdownOpenEvent.bind(this));
    }
    ngOnDestroy() {
        this.clearGlobalClickTimeout();
        if (this.openEventSubscription) {
            this.openEventSubscription.unsubscribe();
        }
        this._unsubscribeFromClickEvents();
    }
    toggle(toggle = !this.isOpen, focus = false) {
        if (toggle === this.isOpen) {
            return;
        }
        this.isOpenChange.emit(toggle);
        if (toggle) {
            openEventEmitter.emit(this);
            if (focus) {
                this.focusItem('next');
            }
        }
    }
    handleGlobalClickEvent($event) {
        if (!this.handlePageEvents || $event.$nglStop) {
            return;
        }
        this.toggle(false);
    }
    _subscribeToClickEvents() {
        this._unsubscribeFromClickEvents();
        // Prevent document listener to close it, since click happened inside
        this.clickEventUnsubscriber = this.renderer.listen(this.element.nativeElement, 'click', ($event) => $event.$nglStop = true);
        this.globalClickEventUnsubscriber = this.renderer.listen('document', 'click', this.handleGlobalClickEvent.bind(this));
    }
    _unsubscribeFromClickEvents() {
        if (this.clickEventUnsubscriber) {
            this.clickEventUnsubscriber();
            this.clickEventUnsubscriber = null;
        }
        if (this.globalClickEventUnsubscriber) {
            this.globalClickEventUnsubscriber();
            this.globalClickEventUnsubscriber = null;
        }
    }
    clearGlobalClickTimeout() {
        clearTimeout(this.globalClickTimeout);
    }
    focusItem(direction) {
        if (!this.items.length) {
            return;
        }
        const items = this.items.toArray();
        const activeElementIndex = items.findIndex(item => item.hasFocus()) + (direction === 'next' ? 1 : -1);
        if (activeElementIndex === items.length || activeElementIndex < 0) {
            return;
        }
        items[activeElementIndex].focus();
    }
    handleDropdownOpenEvent(dropdown) {
        if (dropdown !== this) {
            this.toggle(false);
        }
    }
}
NglDropdown.ɵfac = function NglDropdown_Factory(t) { return new (t || NglDropdown)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglDropdown.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglDropdown, selectors: [["", "nglDropdown", ""]], contentQueries: function NglDropdown_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglDropdownItem, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);
    } }, hostVars: 4, hostBindings: function NglDropdown_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.esc", function NglDropdown_keydown_esc_HostBindingHandler() { return ctx.onKeydownClose("esc"); })("keydown.tab", function NglDropdown_keydown_tab_HostBindingHandler() { return ctx.onKeydownClose("tab"); })("keydown.arrowdown", function NglDropdown_keydown_arrowdown_HostBindingHandler($event) { return ctx.onKeydownFocusNext($event, "next"); })("keydown.arrowup", function NglDropdown_keydown_arrowup_HostBindingHandler($event) { return ctx.onKeydownFocusNext($event, "previous"); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-dropdown-trigger", true)("slds-dropdown-trigger_click", true);
    } }, inputs: { handlePageEvents: "handlePageEvents", isOpen: ["open", "isOpen"] }, outputs: { isOpenChange: "openChange" } });
NglDropdown.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglDropdown.propDecorators = {
    isOpen: [{ type: Input, args: ['open',] }],
    handlePageEvents: [{ type: Input }],
    items: [{ type: ContentChildren, args: [NglDropdownItem, { descendants: true },] }],
    isOpenChange: [{ type: Output, args: ['openChange',] }],
    onKeydownClose: [{ type: HostListener, args: ['keydown.esc', ['"esc"'],] }, { type: HostListener, args: ['keydown.tab', ['"tab"'],] }],
    onKeydownFocusNext: [{ type: HostListener, args: ['keydown.arrowdown', ['$event', '"next"'],] }, { type: HostListener, args: ['keydown.arrowup', ['$event', '"previous"'],] }]
};
__decorate([
    InputBoolean()
], NglDropdown.prototype, "handlePageEvents", void 0);

class NglDropdownTrigger {
    constructor(element, dropdown) {
        this.element = element;
        this.dropdown = dropdown;
        this.parentFocusEventSubscription = this.dropdown.triggerFocusEventEmitter.subscribe(this.focus.bind(this));
    }
    ngOnDestroy() {
        this.parentFocusEventSubscription.unsubscribe();
    }
    toggleOpen() {
        this.dropdown.toggle();
    }
    onKeyDownOpen($event) {
        $event.preventDefault();
        this.dropdown.toggle(true);
    }
    focus() {
        this.element.nativeElement.focus();
    }
}
NglDropdownTrigger.ɵfac = function NglDropdownTrigger_Factory(t) { return new (t || NglDropdownTrigger)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NglDropdown)); };
NglDropdownTrigger.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglDropdownTrigger, selectors: [["", "nglDropdownTrigger", ""]], hostAttrs: ["aria-haspopup", "true"], hostBindings: function NglDropdownTrigger_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NglDropdownTrigger_click_HostBindingHandler() { return ctx.toggleOpen(); })("keydown.arrowdown", function NglDropdownTrigger_keydown_arrowdown_HostBindingHandler($event) { return ctx.onKeyDownOpen($event); });
    } } });
NglDropdownTrigger.ctorParameters = () => [
    { type: ElementRef },
    { type: NglDropdown }
];
NglDropdownTrigger.propDecorators = {
    toggleOpen: [{ type: HostListener, args: ['click',] }],
    onKeyDownOpen: [{ type: HostListener, args: ['keydown.arrowdown', ['$event'],] }]
};

const NGL_DROPDOWN_DIRECTIVES = [
    NglDropdown,
    NglDropdownTrigger,
    NglDropdownItem,
];
class NglMenusModule {
}
NglMenusModule.ɵfac = function NglMenusModule_Factory(t) { return new (t || NglMenusModule)(); };
NglMenusModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglMenusModule });
NglMenusModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

class NglModalHeaderTemplate {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NglModalHeaderTemplate.ɵfac = function NglModalHeaderTemplate_Factory(t) { return new (t || NglModalHeaderTemplate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglModalHeaderTemplate.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglModalHeaderTemplate, selectors: [["", "nglModalHeader", ""]] });
NglModalHeaderTemplate.ctorParameters = () => [
    { type: TemplateRef }
];
class NglModalTaglineTemplate {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NglModalTaglineTemplate.ɵfac = function NglModalTaglineTemplate_Factory(t) { return new (t || NglModalTaglineTemplate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglModalTaglineTemplate.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglModalTaglineTemplate, selectors: [["", "nglModalTagline", ""]] });
NglModalTaglineTemplate.ctorParameters = () => [
    { type: TemplateRef }
];
class NglModalFooterTemplate {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NglModalFooterTemplate.ɵfac = function NglModalFooterTemplate_Factory(t) { return new (t || NglModalFooterTemplate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglModalFooterTemplate.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglModalFooterTemplate, selectors: [["", "nglModalFooter", ""]] });
NglModalFooterTemplate.ctorParameters = () => [
    { type: TemplateRef }
];

class NglModal {
    constructor(focusTrapFactory, document, overlay, element) {
        this.focusTrapFactory = focusTrapFactory;
        this.document = document;
        this.overlay = overlay;
        this.element = element;
        this.header = '';
        this.directional = false;
        this.headingId = uniqueId('modal-heading');
        this.contentId = uniqueId('modal-content');
        this.open = true;
        this.closeButtonAssistiveText = 'Close';
        this.openChange = new EventEmitter();
        this.dismissOnClickOutside = true;
        /** Element that was focused before the dialog was opened. Save this to restore upon close. */
        this.elementFocusedBeforeDialogWasOpened = null;
        this.scrollStrategy = this.overlay.scrollStrategies.block();
    }
    get hasHeader() {
        return this.header || this.headerTpl;
    }
    close(evt) {
        if (evt) {
            evt.stopPropagation();
        }
        this.openChange.emit(false);
    }
    ngOnChanges(changes) {
        if ('open' in changes) {
            this.handleOpen();
        }
    }
    ngAfterContentInit() {
        this.handleOpen();
    }
    clickOutside(evt) {
        if (!this.dismissOnClickOutside) {
            return;
        }
        const { classList } = evt.target;
        if (classList.contains('slds-modal') || classList.contains('slds-modal__container')) {
            this.close();
        }
    }
    ngOnDestroy() {
        this.handleOpen(false);
        this.scrollStrategy = null;
    }
    modalClass() {
        return {
            [`slds-modal_${this.size}`]: !!this.size,
            [`slds-fade-in-open`]: this.open,
            [`slds-modal_prompt`]: !!this.prompt,
        };
    }
    modalHeaderClass() {
        return {
            [`slds-modal__header_empty`]: !this.hasHeader,
            [`slds-theme_${this.prompt}`]: !!this.prompt,
        };
    }
    modalFooterClass() {
        return {
            [`slds-modal__footer_directional`]: !!this.directional,
            [`slds-theme_default`]: !!this.prompt,
        };
    }
    handleOpen(open = this.open) {
        if (open) {
            if (this.document) {
                this.elementFocusedBeforeDialogWasOpened = this.document.activeElement;
            }
            this.container = this.overlay.create();
            // Attach the dom to overlay, the view container is not changed
            this.container.overlayElement.appendChild(this.element.nativeElement);
            this.focusTrap = this.focusTrapFactory.create(this.element.nativeElement);
            this.focusTrap.focusInitialElementWhenReady();
            this.scrollStrategy.enable();
        }
        else {
            if (this.elementFocusedBeforeDialogWasOpened && typeof this.elementFocusedBeforeDialogWasOpened.focus === 'function') {
                this.elementFocusedBeforeDialogWasOpened.focus();
            }
            if (this.container) {
                this.container.dispose();
                this.container = null;
            }
            if (this.focusTrap) {
                this.focusTrap.destroy();
            }
            this.scrollStrategy.disable();
        }
    }
}
NglModal.ɵfac = function NglModal_Factory(t) { return new (t || NglModal)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FocusTrapFactory), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NglModal.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglModal, selectors: [["ngl-modal"]], contentQueries: function NglModal_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglModalHeaderTemplate, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglModalTaglineTemplate, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglModalFooterTemplate, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTpl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.taglineTpl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footer = _t.first);
    } }, hostBindings: function NglModal_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.esc", function NglModal_keydown_esc_HostBindingHandler($event) { return ctx.close($event); })("click", function NglModal_click_HostBindingHandler($event) { return ctx.clickOutside($event); });
    } }, inputs: { header: "header", directional: "directional", open: "open", closeButtonAssistiveText: "closeButtonAssistiveText", dismissOnClickOutside: "dismissOnClickOutside", size: "size", prompt: "prompt" }, outputs: { openChange: "openChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 12, vars: 14, consts: [["aria-modal", "true", "tabindex", "-1", 1, "slds-modal", 3, "ngClass"], [1, "slds-modal__container"], [1, "slds-modal__header", 3, "ngClass"], ["class", "slds-button slds-button_icon slds-button_icon-inverse slds-modal__close", "type", "button", 3, "click", 4, "ngIf"], ["localHeader", ""], [4, "ngIf", "ngIfElse"], ["class", "slds-m-top_x-small", 4, "ngIf"], ["cdkScrollable", "", 1, "slds-modal__content", 3, "id"], ["class", "slds-modal__footer", 3, "ngClass", 4, "ngIf"], [1, "slds-backdrop"], ["type", "button", 1, "slds-button", "slds-button_icon", "slds-button_icon-inverse", "slds-modal__close", 3, "click"], ["nglIconName", "utility:close", 1, "slds-button__icon", "slds-button__icon_large"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-assistive-text"], ["class", "slds-text-heading_medium slds-hyphenate", 3, "id", 4, "ngIf"], [1, "slds-text-heading_medium", "slds-hyphenate", 3, "id"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "slds-m-top_x-small"], [3, "ngTemplateOutlet"], [1, "slds-modal__footer", 3, "ngClass"]], template: function NglModal_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "section", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "header", 2);
        ɵngcc0.ɵɵtemplate(3, NglModal_button_3_Template, 3, 1, "button", 3);
        ɵngcc0.ɵɵtemplate(4, NglModal_ng_template_4_Template, 1, 1, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, NglModal_6_Template, 1, 4, undefined, 5);
        ɵngcc0.ɵɵtemplate(7, NglModal_p_7_Template, 2, 1, "p", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "div", 7);
        ɵngcc0.ɵɵprojection(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, NglModal_footer_10_Template, 2, 2, "footer", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(11, "div", 9);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(5);
        ɵngcc0.ɵɵproperty("ngClass", ctx.modalClass());
        ɵngcc0.ɵɵattribute("aria-hidden", !ctx.open)("aria-labelledby", ctx.headingId)("aria-describedby", ctx.contentId)("role", ctx.prompt ? "alertdialog" : "dialog");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngClass", ctx.modalHeaderClass());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showClose);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.headerTpl)("ngIfElse", _r1);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasHeader && ctx.taglineTpl);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.contentId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.footer);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("slds-backdrop_open", ctx.open);
    } }, directives: [ɵngcc1.NgClass, ɵngcc1.NgIf, ɵngcc5.CdkScrollable, NglIconSvg, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
NglModal.ctorParameters = () => [
    { type: FocusTrapFactory },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Overlay },
    { type: ElementRef }
];
NglModal.propDecorators = {
    header: [{ type: Input }],
    size: [{ type: Input }],
    directional: [{ type: Input }],
    open: [{ type: Input }],
    closeButtonAssistiveText: [{ type: Input }],
    openChange: [{ type: Output }],
    headerTpl: [{ type: ContentChild, args: [NglModalHeaderTemplate,] }],
    taglineTpl: [{ type: ContentChild, args: [NglModalTaglineTemplate,] }],
    footer: [{ type: ContentChild, args: [NglModalFooterTemplate,] }],
    dismissOnClickOutside: [{ type: Input }],
    prompt: [{ type: Input }],
    close: [{ type: HostListener, args: ['keydown.esc', ['$event'],] }],
    clickOutside: [{ type: HostListener, args: ['click', ['$event'],] }]
};
__decorate([
    InputBoolean()
], NglModal.prototype, "directional", void 0);
__decorate([
    InputBoolean()
], NglModal.prototype, "open", void 0);
__decorate([
    InputBoolean()
], NglModal.prototype, "dismissOnClickOutside", void 0);
__decorate([
    hasObservers('openChange')
], NglModal.prototype, "showClose", void 0);

const NGL_MODAL_DIRECTIVES = [
    NglModal,
    NglModalFooterTemplate,
    NglModalHeaderTemplate,
    NglModalTaglineTemplate,
];
class NglModalsModule {
}
NglModalsModule.ɵfac = function NglModalsModule_Factory(t) { return new (t || NglModalsModule)(); };
NglModalsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglModalsModule });
NglModalsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, A11yModule, OverlayModule, NglIconsModule]] });

class NglToast extends NglCommonNotify {
    constructor(element, renderer, cd) {
        super(element, renderer, cd, 'toast');
    }
}
NglToast.ɵfac = function NglToast_Factory(t) { return new (t || NglToast)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglToast.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglToast, selectors: [["ngl-toast"]], exportAs: ["nglToast"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 6, vars: 3, consts: [[1, "slds-assistive-text"], ["class", "slds-m-right_small slds-no-flex slds-align-top", "size", "small", "variant", "", 3, "iconName", 4, "ngIf"], [1, "slds-notify__content"], ["class", "slds-button slds-button_icon slds-notify__close slds-button_icon-inverse", "type", "button", 3, "click", 4, "ngIf"], ["size", "small", "variant", "", 1, "slds-m-right_small", "slds-no-flex", "slds-align-top", 3, "iconName"], ["type", "button", 1, "slds-button", "slds-button_icon", "slds-notify__close", "slds-button_icon-inverse", 3, "click"], ["nglIconName", "utility:close", 1, "slds-button__icon", "slds-button__icon_large"], ["class", "slds-assistive-text", 4, "ngIf"]], template: function NglToast_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NglToast_ngl_icon_2_Template, 1, 1, "ngl-icon", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, NglToast_button_5_Template, 3, 1, "button", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.assistiveText || ctx.variant);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconName);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.dismissible);
    } }, directives: [ɵngcc1.NgIf, NglIcon, NglIconSvg], encapsulation: 2, changeDetection: 0 });
NglToast.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];

class NglToastClose extends NglCommonNotifyClose {
    constructor(toast) {
        super(toast);
    }
}
NglToastClose.ɵfac = function NglToastClose_Factory(t) { return new (t || NglToastClose)(ɵngcc0.ɵɵdirectiveInject(NglToast)); };
NglToastClose.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglToastClose, selectors: [["ngl-toast", "close", ""], ["ngl-toast", "nglClose", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
NglToastClose.ctorParameters = () => [
    { type: NglToast }
];

const NGL_TOAST_DIRECTIVES = [
    NglToast,
    NglToastClose,
];
class NglToastModule {
}
NglToastModule.ɵfac = function NglToastModule_Factory(t) { return new (t || NglToastModule)(); };
NglToastModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglToastModule });
NglToastModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglIconsModule]] });

class NglPagination {
    constructor() {
        this.pages = [];
        this.pageChange = new EventEmitter();
        this.perPage = 10;
        this.limit = 0;
        this.boundaryNumbers = 0;
        this.firstText = 'First';
        this.previousText = 'Previous';
        this.nextText = 'Next';
        this.lastText = 'Last';
        this.boundaryLinks = false;
    }
    set page(page) {
        this.current = +page;
    }
    hasPrevious() {
        return this.current > 1;
    }
    hasNext() {
        return this.current < this.totalPages;
    }
    goto(page) {
        if (page === this.current) {
            return;
        }
        this.pageChange.emit(+page);
    }
    ngOnChanges() {
        this.totalPages = Math.ceil(+this.total / +this.perPage);
        const { start, end } = this.limits();
        this.pages = this.getPageArray(start, end);
        if (this.boundaryNumbers > 0) {
            if (start > 1) {
                const preGap = this.getPageArray(1, Math.min(start - 1, this.boundaryNumbers));
                const lastGapNumber = +preGap[preGap.length - 1].number;
                if (lastGapNumber < start - 1) {
                    this.pages.unshift(this.getGapPage(lastGapNumber, start));
                }
                this.pages.unshift(...preGap);
            }
            if (end < this.totalPages) {
                const postGap = this.getPageArray(Math.max(this.totalPages - this.boundaryNumbers + 1, end + 1), this.totalPages);
                const firstGapNumber = +postGap[0].number;
                if (firstGapNumber > end + 1) {
                    this.pages.push(this.getGapPage(end, firstGapNumber));
                }
                this.pages.push(...postGap);
            }
        }
        if (this.current > this.totalPages) {
            setTimeout(() => this.goto(this.totalPages));
        }
        else if (!this.current && this.totalPages > 0) {
            setTimeout(() => this.goto(1));
        }
    }
    pageTrackBy(index, page) {
        return page.number;
    }
    get start() {
        return Math.min(Math.max(1 + ((+this.current || 1) - 1) * +this.perPage, 0), +this.total);
    }
    get end() {
        return Math.min(this.start + (+this.perPage - 1), +this.total);
    }
    getPageArray(start, end) {
        return Array.apply(null, { length: end - start + 1 }).map((value, index) => this.getPage(start + index));
    }
    getPage(number, disabled = false) {
        return { number, disabled };
    }
    getGapPage(before, after) {
        const isConsecutive = before + 1 === after - 1;
        return this.getPage(isConsecutive ? before + 1 : '...', !isConsecutive);
    }
    /**
     * Calculate first and last visible page numbers
     */
    limits() {
        let start = 1, end = this.totalPages;
        if (this.limit < 1) {
            return { start, end };
        }
        // Current page is displayed in the middle of the visible ones
        start = Math.max(+this.current - Math.floor(+this.limit / 2), 1);
        end = start + +this.limit - 1;
        // Adjust if limit is exceeded
        if (end > this.totalPages) {
            end = this.totalPages;
            start = Math.max(end - +this.limit + 1, 1);
        }
        return { start, end };
    }
}
NglPagination.ɵfac = function NglPagination_Factory(t) { return new (t || NglPagination)(); };
NglPagination.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglPagination, selectors: [["ngl-pagination"]], inputs: { perPage: "perPage", limit: "limit", boundaryNumbers: "boundaryNumbers", firstText: "firstText", previousText: "previousText", nextText: "nextText", lastText: "lastText", boundaryLinks: "boundaryLinks", page: "page", total: "total" }, outputs: { pageChange: "pageChange" }, exportAs: ["nglPagination"], features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 8, vars: 8, consts: [["role", "group", 1, "slds-button-group"], ["class", "slds-button slds-button_neutral", 3, "disabled", "click", 4, "ngIf"], [1, "slds-button", "slds-button_neutral", 3, "disabled", "click"], ["class", "slds-button", 3, "ngClass", "disabled", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "slds-button", 3, "ngClass", "disabled", "click"]], template: function NglPagination_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, NglPagination_button_1_Template, 2, 2, "button", 1);
        ɵngcc0.ɵɵelementStart(2, "button", 2);
        ɵngcc0.ɵɵlistener("click", function NglPagination_Template_button_click_2_listener() { return ctx.goto(ctx.current - 1); });
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(4, NglPagination_button_4_Template, 2, 3, "button", 3);
        ɵngcc0.ɵɵelementStart(5, "button", 2);
        ɵngcc0.ɵɵlistener("click", function NglPagination_Template_button_click_5_listener() { return ctx.goto(ctx.current + 1); });
        ɵngcc0.ɵɵtext(6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, NglPagination_button_7_Template, 2, 2, "button", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.boundaryLinks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", !ctx.hasPrevious());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.previousText);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.pages)("ngForTrackBy", ctx.pageTrackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", !ctx.hasNext());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.nextText);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.boundaryLinks);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf, ɵngcc1.NgClass], encapsulation: 2, changeDetection: 0 });
NglPagination.propDecorators = {
    page: [{ type: Input }],
    pageChange: [{ type: Output }],
    total: [{ type: Input }],
    perPage: [{ type: Input }],
    limit: [{ type: Input }],
    boundaryNumbers: [{ type: Input }],
    firstText: [{ type: Input }],
    previousText: [{ type: Input }],
    nextText: [{ type: Input }],
    lastText: [{ type: Input }],
    boundaryLinks: [{ type: Input }]
};
__decorate([
    InputBoolean()
], NglPagination.prototype, "boundaryLinks", void 0);

class NglPaginationsModule {
}
NglPaginationsModule.ɵfac = function NglPaginationsModule_Factory(t) { return new (t || NglPaginationsModule)(); };
NglPaginationsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglPaginationsModule });
NglPaginationsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

class NglPick {
    constructor() {
        this.values = new BehaviorSubject(null);
        this.nglPickChange = new EventEmitter();
        this.nglOptionDestroyed = new EventEmitter();
        this.isMultiple = false;
    }
    set setSelected(selected) {
        this.selected = selected;
        this.ngAfterContentInit();
    }
    ngAfterContentInit() {
        this.values.next(this.selected);
    }
    selectOption(value) {
        let next;
        if (this.isMultiple) {
            if (Array.isArray(this.selected)) {
                // Remove if already there or add to selection
                const index = this.selected.indexOf(value);
                next = index > -1
                    ? [...this.selected.slice(0, index), ...this.selected.slice(index + 1)]
                    : [...this.selected, value];
            }
            else {
                next = Object.assign({}, this.selected, { [value]: !this.selected[value] });
            }
        }
        else {
            next = value;
        }
        this.nglPickChange.emit(next);
    }
    optionRemoved(value) {
        if (this.isMultiple && !this.selected) {
            return;
        }
        let emit;
        if (this.isMultiple) {
            emit = Array.isArray(this.selected) ? this.selected.indexOf(value) > -1 : !!this.selected[value];
        }
        else {
            emit = this.selected === value;
        }
        if (emit) {
            setTimeout(() => this.nglOptionDestroyed.emit(value));
        }
    }
}
NglPick.ɵfac = function NglPick_Factory(t) { return new (t || NglPick)(); };
NglPick.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglPick, selectors: [["", "nglPick", ""]], inputs: { isMultiple: ["nglPickMultiple", "isMultiple"], setSelected: ["nglPick", "setSelected"], nglPickActiveClass: "nglPickActiveClass" }, outputs: { nglPickChange: "nglPickChange", nglOptionDestroyed: "nglOptionDestroyed" } });
NglPick.propDecorators = {
    setSelected: [{ type: Input, args: ['nglPick',] }],
    nglPickActiveClass: [{ type: Input }],
    nglPickChange: [{ type: Output }],
    nglOptionDestroyed: [{ type: Output }],
    isMultiple: [{ type: Input, args: ['nglPickMultiple',] }]
};
__decorate([
    InputBoolean()
], NglPick.prototype, "isMultiple", void 0);

class NglPickOption {
    constructor(element, renderer, nglPick) {
        this.element = element;
        this.renderer = renderer;
        this.nglPick = nglPick;
        this._active = false;
    }
    // Use a getter to prevent direct altering
    get active() {
        return this._active;
    }
    set setValue(value) {
        this._value = value;
    }
    pick(evt) {
        if (evt) {
            evt.preventDefault();
        }
        this.nglPick.selectOption(this._value);
    }
    ngOnInit() {
        this._subscription = this.nglPick.values.subscribe(value => {
            this._active = this._isActive(value);
            const activeClass = this.nglPickActiveClass || this.nglPick.nglPickActiveClass;
            if (activeClass) {
                if (this.active) {
                    this.renderer.addClass(this.element.nativeElement, activeClass);
                }
                else {
                    this.renderer.removeClass(this.element.nativeElement, activeClass);
                }
            }
        });
    }
    ngOnDestroy() {
        this._subscription.unsubscribe();
        this.nglPick.optionRemoved(this._value);
    }
    _isActive(value) {
        if (this.nglPick.isMultiple) {
            if (!value) {
                return false;
            }
            return Array.isArray(value) ? value.indexOf(this._value) > -1 : !!value[this._value];
        }
        else {
            return this._value === value;
        }
    }
}
NglPickOption.ɵfac = function NglPickOption_Factory(t) { return new (t || NglPickOption)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(NglPick)); };
NglPickOption.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglPickOption, selectors: [["", "nglPickOption", ""]], hostAttrs: ["role", "button"], hostBindings: function NglPickOption_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NglPickOption_click_HostBindingHandler() { return ctx.pick(); })("keydown.Space", function NglPickOption_keydown_Space_HostBindingHandler($event) { return ctx.pick($event); })("keydown.Enter", function NglPickOption_keydown_Enter_HostBindingHandler($event) { return ctx.pick($event); });
    } }, inputs: { setValue: ["nglPickOption", "setValue"], nglPickActiveClass: "nglPickActiveClass" }, exportAs: ["nglPickOption"] });
NglPickOption.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NglPick }
];
NglPickOption.propDecorators = {
    setValue: [{ type: Input, args: ['nglPickOption',] }],
    nglPickActiveClass: [{ type: Input }],
    pick: [{ type: HostListener, args: ['click',] }, { type: HostListener, args: ['keydown.Space', ['$event'],] }, { type: HostListener, args: ['keydown.Enter', ['$event'],] }]
};

const NGL_PICK_DIRECTIVES = [
    NglPick,
    NglPickOption,
];
class NglPickModule {
}
NglPickModule.ɵfac = function NglPickModule_Factory(t) { return new (t || NglPickModule)(); };
NglPickModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglPickModule });
NglPickModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

class NglPill {
    constructor() {
        this.isTemplateRef = isTemplateRef;
        /**
           * Applies the error style to the component.
           */
        this.hasError = false;
        /**
           * Whether or not to override the remove button's visibility, if `remove` is set.
           */
        this.removable = true;
        /**
           * Remove button title (and assistive text).
           */
        this.removeTitle = 'Remove';
        /**
           * The event emitted when the remove button is clicked.
           */
        this.remove = new EventEmitter();
        this.linked = false;
    }
    ngOnInit() {
        this.canRemove = this.remove.observers.length > 0;
    }
    onRemove(e) {
        this.remove.emit(e);
    }
    get pillIcon() {
        return this.icon || this.avatar;
    }
}
NglPill.ɵfac = function NglPill_Factory(t) { return new (t || NglPill)(); };
NglPill.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglPill, selectors: [["ngl-pill"]], hostVars: 6, hostBindings: function NglPill_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-pill", true)("slds-has-error", ctx.hasError)("slds-pill_link", ctx.linked);
    } }, inputs: { hasError: "hasError", removable: "removable", removeTitle: "removeTitle", icon: "icon", avatar: "avatar" }, outputs: { remove: "remove" }, ngContentSelectors: _c27, decls: 5, vars: 4, consts: [["class", "slds-pill__icon_container", 4, "ngIf"], [4, "ngIf", "ngIfElse"], ["unlinked", ""], ["class", "slds-button slds-button_icon slds-pill__remove", "type", "button", 3, "title", "click", 4, "ngIf"], [1, "slds-pill__icon_container"], [3, "ngTemplateOutlet", 4, "ngIf", "ngIfElse"], ["defaultTpl", ""], [3, "ngTemplateOutlet"], [3, "iconName", 4, "ngIf", "ngIfElse"], ["avatarTpl", ""], [3, "iconName"], ["variant", "circle", 3, "src"], [1, "slds-pill__label"], ["type", "button", 1, "slds-button", "slds-button_icon", "slds-pill__remove", 3, "title", "click"], ["nglIconName", "close", 1, "slds-button__icon"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-assistive-text"]], template: function NglPill_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c26);
        ɵngcc0.ɵɵtemplate(0, NglPill_span_0_Template, 4, 2, "span", 0);
        ɵngcc0.ɵɵtemplate(1, NglPill_ng_container_1_Template, 2, 0, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(2, NglPill_ng_template_2_Template, 2, 0, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, NglPill_button_4_Template, 3, 2, "button", 3);
    } if (rf & 2) {
        const _r2 = ɵngcc0.ɵɵreference(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pillIcon);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.linked)("ngIfElse", _r2);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.canRemove && ctx.removable);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, NglIcon, NglAvatar, NglIconSvg], encapsulation: 2, changeDetection: 0 });
NglPill.propDecorators = {
    icon: [{ type: Input }],
    avatar: [{ type: Input }],
    hasError: [{ type: Input }, { type: HostBinding, args: ['class.slds-has-error',] }],
    removable: [{ type: Input }],
    removeTitle: [{ type: Input }],
    remove: [{ type: Output }],
    linked: [{ type: HostBinding, args: ['class.slds-pill_link',] }]
};
__decorate([
    InputBoolean()
], NglPill.prototype, "hasError", void 0);
__decorate([
    InputBoolean()
], NglPill.prototype, "removable", void 0);

class NglPillLink {
    constructor(pill) {
        pill.linked = true;
    }
}
NglPillLink.ɵfac = function NglPillLink_Factory(t) { return new (t || NglPillLink)(ɵngcc0.ɵɵdirectiveInject(NglPill)); };
NglPillLink.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglPillLink, selectors: [["a", "nglPillAction", ""]], hostVars: 2, hostBindings: function NglPillLink_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-pill__action", true);
    } }, attrs: _c28, ngContentSelectors: _c0, decls: 2, vars: 0, consts: [[1, "slds-pill__label"]], template: function NglPillLink_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
NglPillLink.ctorParameters = () => [
    { type: NglPill }
];

const NGL_PILL_DIRECTIVES = [
    NglPill,
    NglPillLink,
];
class NglPillsModule {
}
NglPillsModule.ɵfac = function NglPillsModule_Factory(t) { return new (t || NglPillsModule)(); };
NglPillsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglPillsModule });
NglPillsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglIconsModule, NglAvatarModule]] });

class NglProgressBar {
    constructor(element, renderer, hostService) {
        this.element = element;
        this.renderer = renderer;
        this.hostService = hostService;
        this.renderer.addClass(this.element.nativeElement, 'slds-progress-bar');
        this.renderer.setAttribute(this.element.nativeElement, 'role', 'progressbar');
        this.renderer.setAttribute(this.element.nativeElement, 'aria-valuemin', '0');
        this.renderer.setAttribute(this.element.nativeElement, 'aria-valuemax', '100');
    }
    /**
     * The percentage value of the progress bar.
     */
    set value(value) {
        this._value = Math.max(0, Math.min(value, 100)); // Trap on [0, 100]
        this.renderer.setAttribute(this.element.nativeElement, 'aria-valuenow', `${this.value}`);
    }
    get value() {
        return this._value;
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    setHostClass() {
        this.hostService.updateClass(this.element, {
            [`slds-progress-bar_${this.size}`]: !!this.size,
            [`slds-progress-bar_${this.variant}`]: !!this.variant,
        });
    }
}
NglProgressBar.ɵfac = function NglProgressBar_Factory(t) { return new (t || NglProgressBar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(HostService)); };
NglProgressBar.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglProgressBar, selectors: [["ngl-progress-bar"]], inputs: { value: "value", size: "size", variant: "variant" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 3, vars: 3, consts: [[1, "slds-progress-bar__value"], [1, "slds-assistive-text"]], template: function NglProgressBar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.value, "%");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1("Progress: ", ctx.value, "%");
    } }, encapsulation: 2, changeDetection: 0 });
NglProgressBar.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService }
];
NglProgressBar.propDecorators = {
    value: [{ type: Input }],
    size: [{ type: Input }],
    variant: [{ type: Input }]
};

class NglProgressBarModule {
}
NglProgressBarModule.ɵfac = function NglProgressBarModule_Factory(t) { return new (t || NglProgressBarModule)(); };
NglProgressBarModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglProgressBarModule });
NglProgressBarModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

class NglRadioGroup {
    constructor() {
        this.error = null;
        this.type = 'list';
        this.uid = uniqueId('radio-group');
        this.type$ = new BehaviorSubject(this.type);
        this.error$ = new BehaviorSubject(this.error);
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this.uid}`;
    }
    ngOnChanges(changes) {
        if (changes.type) {
            this.type$.next(this.type);
        }
        if (changes.error) {
            this.error$.next(this.hasError ? this.errorId : null);
        }
    }
}
NglRadioGroup.ɵfac = function NglRadioGroup_Factory(t) { return new (t || NglRadioGroup)(); };
NglRadioGroup.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglRadioGroup, selectors: [["ngl-radio-group"], ["", "ngl-radio-group", ""]], hostVars: 4, hostBindings: function NglRadioGroup_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-form-element", true)("slds-has-error", ctx.hasError);
    } }, inputs: { error: "error", type: "type", label: "label", required: "required" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 8, vars: 5, consts: [[1, "slds-form-element__legend", "slds-form-element__label"], ["class", "slds-required", "title", "required", 4, "ngIf"], [3, "nglInternalOutlet"], [1, "slds-form-element__control"], ["class", "slds-radio_button-group", 4, "ngIf", "ngIfElse"], ["class", "slds-form-element__help", 3, "id", 4, "ngIf"], ["contentTpl", ""], ["title", "required", 1, "slds-required"], [1, "slds-radio_button-group"], [4, "ngTemplateOutlet"], [1, "slds-form-element__help", 3, "id"]], template: function NglRadioGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "legend", 0);
        ɵngcc0.ɵɵtemplate(1, NglRadioGroup_abbr_1_Template, 2, 0, "abbr", 1);
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵtemplate(4, NglRadioGroup_div_4_Template, 2, 1, "div", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, NglRadioGroup_div_5_Template, 2, 2, "div", 5);
        ɵngcc0.ɵɵtemplate(6, NglRadioGroup_ng_template_6_Template, 1, 0, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r3 = ɵngcc0.ɵɵreference(7);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.required);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.label);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.type === "button")("ngIfElse", _r3);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.error);
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
NglRadioGroup.propDecorators = {
    label: [{ type: Input }],
    error: [{ type: Input }],
    hasError: [{ type: HostBinding, args: ['class.slds-has-error',] }],
    required: [{ type: Input }],
    type: [{ type: Input }]
};
__decorate([
    InputBoolean()
], NglRadioGroup.prototype, "required", void 0);

class NglRadioInput {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        if (!this.el.nativeElement.id) {
            this.renderer.setAttribute(this.el.nativeElement, 'id', uniqueId('radio'));
        }
    }
    get id() {
        return this.el.nativeElement.id;
    }
}
NglRadioInput.ɵfac = function NglRadioInput_Factory(t) { return new (t || NglRadioInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglRadioInput.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglRadioInput, selectors: [["input", "ngl", "", "type", "radio"]], hostVars: 2, hostBindings: function NglRadioInput_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("name", ctx.name)("aria-describedby", ctx.describedBy);
    } } });
NglRadioInput.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglRadioInput.propDecorators = {
    name: [{ type: HostBinding, args: ['attr.name',] }],
    describedBy: [{ type: HostBinding, args: ['attr.aria-describedby',] }]
};

class NglRadioOption {
    constructor(radioGroup, cd) {
        this.radioGroup = radioGroup;
        this.cd = cd;
        this.subscriptions = [];
    }
    get isTypeList() {
        return this.type === 'list';
    }
    get isTypeButton() {
        return this.type === 'button';
    }
    ngOnInit() {
        this.subscriptions.push(this.radioGroup.type$.subscribe((type) => {
            this.type = type;
            this.cd.detectChanges();
        }), this.radioGroup.error$.subscribe((errorId) => {
            this.input.describedBy = errorId;
        }));
    }
    ngAfterContentInit() {
        this.input.name = this.radioGroup.uid;
    }
    ngOnDestroy() {
        this.subscriptions.forEach((s) => s.unsubscribe());
    }
}
NglRadioOption.ɵfac = function NglRadioOption_Factory(t) { return new (t || NglRadioOption)(ɵngcc0.ɵɵdirectiveInject(NglRadioGroup), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglRadioOption.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglRadioOption, selectors: [["ngl-radio-option"]], contentQueries: function NglRadioOption_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglRadioInput, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 6, hostBindings: function NglRadioOption_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-radio", ctx.isTypeList)("slds-button", ctx.isTypeButton)("slds-radio_button", ctx.isTypeButton);
    } }, inputs: { label: "label" }, ngContentSelectors: _c0, decls: 3, vars: 2, consts: [["class", "slds-radio__label", 4, "ngIf"], ["class", "slds-radio_button__label", 4, "ngIf"], [1, "slds-radio__label"], [1, "slds-radio_faux"], [1, "slds-form-element__label", 3, "nglInternalOutlet"], [1, "slds-radio_button__label"], [1, "slds-radio_faux", 3, "nglInternalOutlet"]], template: function NglRadioOption_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, NglRadioOption_label_1_Template, 3, 2, "label", 0);
        ɵngcc0.ɵɵtemplate(2, NglRadioOption_label_2_Template, 2, 2, "label", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.type === "list");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.type === "button");
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglRadioOption.ctorParameters = () => [
    { type: NglRadioGroup },
    { type: ChangeDetectorRef }
];
NglRadioOption.propDecorators = {
    label: [{ type: Input }],
    input: [{ type: ContentChild, args: [NglRadioInput, { static: true },] }],
    isTypeList: [{ type: HostBinding, args: ['class.slds-radio',] }],
    isTypeButton: [{ type: HostBinding, args: ['class.slds-button',] }, { type: HostBinding, args: ['class.slds-radio_button',] }]
};

const DIRECTIVES$3 = [
    NglRadioGroup,
    NglRadioOption,
    NglRadioInput,
];
class NglRadiosModule {
}
NglRadiosModule.ɵfac = function NglRadiosModule_Factory(t) { return new (t || NglRadiosModule)(); };
NglRadiosModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglRadiosModule });
NglRadiosModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglInternalOutletModule]] });

class NglRatingIconTemplate {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NglRatingIconTemplate.ɵfac = function NglRatingIconTemplate_Factory(t) { return new (t || NglRatingIconTemplate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglRatingIconTemplate.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglRatingIconTemplate, selectors: [["", "nglRatingIcon", ""]] });
NglRatingIconTemplate.ctorParameters = () => [
    { type: TemplateRef }
];

/** Injection token that can be used to specify default options. */
const NGL_RATING_CONFIG = new InjectionToken('ngl-rating-config');
/**
 * Configuration service for the NglRating component.
 */
class NglRatingConfig {
    constructor() {
        /**
         * The color of the icon when status is "on"
         */
        this.colorOn = '#FFB75D';
        /**
         * The color of the icon when status is "off"
         */
        this.colorOff = '54698D';
    }
}

class NglRating {
    constructor(defaultConfig) {
        this.range = [];
        this.icon = 'favorite';
        this.readonly = false;
        this.rateChange = new EventEmitter();
        this.hover = new EventEmitter();
        this._max = 5;
        const config = Object.assign(Object.assign({}, new NglRatingConfig()), defaultConfig);
        this.colorOn = config.colorOn;
        this.colorOff = config.colorOff;
    }
    set rate(rate) {
        this.inputRate = rate;
        this.currentRate = rate;
    }
    set max(max) {
        this._max = +max;
        this.setRange();
    }
    get max() {
        return this._max;
    }
    ngOnInit() {
        this.setRange();
    }
    ngAfterContentInit() {
        this._template = this.iconTemplate ? this.iconTemplate.templateRef : this.defaultTemplate;
    }
    update(value) {
        if (value < 1 || value > this.max || this.readonly || value === this.inputRate) {
            return;
        }
        this.rateChange.emit(value);
    }
    enter(value) {
        if (this.readonly) {
            return;
        }
        this.currentRate = value;
        this.hover.emit(value);
    }
    getFill(value) {
        if (value <= this.currentRate) {
            return 100;
        }
        if (Math.ceil(this.currentRate) < value) {
            return 0;
        }
        return Math.round(100 * (this.currentRate % 1));
    }
    reset() {
        this.currentRate = this.inputRate;
    }
    // Keyboard interactions
    keyboardIncrease(evt) {
        evt.preventDefault();
        this.update(this.inputRate + 1);
    }
    keyboardDecrease(evt) {
        evt.preventDefault();
        this.update(this.inputRate - 1);
    }
    // ARIA
    get ariaValuenow() {
        return this.inputRate;
    }
    setRange() {
        this.range = Array.apply(null, { length: this.max }).map((value, index) => index + 1);
    }
}
NglRating.ɵfac = function NglRating_Factory(t) { return new (t || NglRating)(ɵngcc0.ɵɵdirectiveInject(NGL_RATING_CONFIG, 8)); };
NglRating.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglRating, selectors: [["ngl-rating"]], contentQueries: function NglRating_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglRatingIconTemplate, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.iconTemplate = _t.first);
    } }, viewQuery: function NglRating_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c29, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);
    } }, hostAttrs: ["tabindex", "0", "aria-valuemin", "0", 2, "white-space", "nowrap"], hostVars: 2, hostBindings: function NglRating_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function NglRating_mouseleave_HostBindingHandler() { return ctx.reset(); })("keydown.ArrowUp", function NglRating_keydown_ArrowUp_HostBindingHandler($event) { return ctx.keyboardIncrease($event); })("keydown.ArrowRight", function NglRating_keydown_ArrowRight_HostBindingHandler($event) { return ctx.keyboardIncrease($event); })("keydown.ArrowDown", function NglRating_keydown_ArrowDown_HostBindingHandler($event) { return ctx.keyboardDecrease($event); })("keydown.ArrowLeft", function NglRating_keydown_ArrowLeft_HostBindingHandler($event) { return ctx.keyboardDecrease($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-valuemax", ctx.max)("aria-valuenow", ctx.ariaValuenow);
    } }, inputs: { icon: "icon", readonly: ["isReadonly", "readonly"], colorOn: "colorOn", colorOff: "colorOff", rate: "rate", max: "max", size: "size" }, outputs: { rateChange: "rateChange", hover: "hover" }, decls: 3, vars: 1, consts: [["t", ""], ["class", "slds-show_inline-block", "style", "position: relative;", 3, "click", "mouseenter", 4, "ngFor", "ngForOf"], [1, "slds-icon", 3, "nglIconName", "ngClass"], ["class", "slds-icon", "style", "position:absolute; bottom:0;", 3, "nglIconName", "ngClass", "fill", "left", "xPos", 4, "ngIf"], [1, "slds-icon", 2, "position", "absolute", "bottom", "0", 3, "nglIconName", "ngClass", "xPos"], [1, "slds-show_inline-block", 2, "position", "relative", 3, "click", "mouseenter"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function NglRating_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglRating_ng_template_0_Template, 2, 5, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, NglRating_div_2_Template, 2, 6, "div", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.range);
    } }, directives: [ɵngcc1.NgForOf, NglIconSvg, ɵngcc1.NgClass, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
NglRating.ctorParameters = () => [
    { type: NglRatingConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_RATING_CONFIG,] }] }
];
NglRating.propDecorators = {
    icon: [{ type: Input }],
    size: [{ type: Input }],
    readonly: [{ type: Input, args: ['isReadonly',] }],
    rate: [{ type: Input }],
    defaultTemplate: [{ type: ViewChild, args: ['t', { static: true },] }],
    iconTemplate: [{ type: ContentChild, args: [NglRatingIconTemplate,] }],
    max: [{ type: Input }],
    colorOn: [{ type: Input }],
    colorOff: [{ type: Input }],
    rateChange: [{ type: Output }],
    hover: [{ type: Output }],
    reset: [{ type: HostListener, args: ['mouseleave',] }],
    keyboardIncrease: [{ type: HostListener, args: ['keydown.ArrowUp', ['$event'],] }, { type: HostListener, args: ['keydown.ArrowRight', ['$event'],] }],
    keyboardDecrease: [{ type: HostListener, args: ['keydown.ArrowDown', ['$event'],] }, { type: HostListener, args: ['keydown.ArrowLeft', ['$event'],] }],
    ariaValuenow: [{ type: HostBinding, args: ['attr.aria-valuenow',] }]
};
__decorate([
    InputBoolean()
], NglRating.prototype, "readonly", void 0);

const DIRECTIVES$2 = [
    NglRating,
    NglRatingIconTemplate,
];
class NglRatingsModule {
}
NglRatingsModule.ɵfac = function NglRatingsModule_Factory(t) { return new (t || NglRatingsModule)(); };
NglRatingsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglRatingsModule });
NglRatingsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglIconsModule]] });

class NglExpandableSection {
    constructor() {
        this.collapsable = true;
        this.open = false;
        this.openChange = new EventEmitter();
        this._uid = uniqueId('expandable-section');
    }
    get expanded() {
        return this.collapsable ? this.open : true;
    }
    get uid() {
        return this.collapsable ? this._uid : undefined;
    }
    toggle(event) {
        event.preventDefault();
        this.openChange.emit(!this.open);
    }
}
NglExpandableSection.ɵfac = function NglExpandableSection_Factory(t) { return new (t || NglExpandableSection)(); };
NglExpandableSection.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglExpandableSection, selectors: [["ngl-expandable-section"]], hostVars: 4, hostBindings: function NglExpandableSection_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-section", true)("slds-is-open", ctx.expanded);
    } }, inputs: { collapsable: "collapsable", open: "open", title: "title" }, outputs: { openChange: "openChange" }, ngContentSelectors: _c0, decls: 6, vars: 6, consts: [[1, "slds-section__title"], ["class", "slds-button slds-section__title-action", "type", "button", 3, "click", 4, "ngIf", "ngIfElse"], ["simple_title", ""], [1, "slds-section__content"], ["type", "button", 1, "slds-button", "slds-section__title-action", 3, "click"], ["nglIconName", "switch", 1, "slds-section__title-action-icon", "slds-button__icon", "slds-button__icon_left"], [1, "slds-truncate", 3, "title"], [1, "slds-truncate", "slds-p-horizontal_small", 3, "title"]], template: function NglExpandableSection_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "h3", 0);
        ɵngcc0.ɵɵtemplate(1, NglExpandableSection_button_1_Template, 4, 4, "button", 1);
        ɵngcc0.ɵɵtemplate(2, NglExpandableSection_ng_template_2_Template, 2, 2, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵprojection(5);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(3);
        ɵngcc0.ɵɵclassProp("slds-theme_shade", !ctx.collapsable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.collapsable)("ngIfElse", _r1);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵattribute("aria-hidden", !ctx.expanded)("id", ctx.uid);
    } }, directives: [ɵngcc1.NgIf, NglIconSvg], encapsulation: 2, changeDetection: 0 });
NglExpandableSection.propDecorators = {
    title: [{ type: Input }],
    collapsable: [{ type: Input }],
    open: [{ type: Input }],
    openChange: [{ type: Output }],
    expanded: [{ type: HostBinding, args: ['class.slds-is-open',] }]
};

class NglSectionsModule {
}
NglSectionsModule.ɵfac = function NglSectionsModule_Factory(t) { return new (t || NglSectionsModule)(); };
NglSectionsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglSectionsModule });
NglSectionsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglIconsModule]] });

class NglSelectInput {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.ɵRequiredSubject = new BehaviorSubject(false);
        if (!this.el.nativeElement.id) {
            this.renderer.setAttribute(this.el.nativeElement, 'id', uniqueId('select'));
        }
    }
    set required(required) {
        this.ɵRequiredSubject.next(toBoolean(required));
    }
    get id() {
        return this.el.nativeElement.id;
    }
}
NglSelectInput.ɵfac = function NglSelectInput_Factory(t) { return new (t || NglSelectInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglSelectInput.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglSelectInput, selectors: [["select", "ngl", ""]], hostVars: 3, hostBindings: function NglSelectInput_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-describedby", ctx.describedBy);
        ɵngcc0.ɵɵclassProp("slds-select", true);
    } }, inputs: { required: "required" } });
NglSelectInput.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglSelectInput.propDecorators = {
    describedBy: [{ type: HostBinding, args: ['attr.aria-describedby',] }],
    required: [{ type: Input }]
};

class NglSelect {
    constructor(cd) {
        this.cd = cd;
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this._uid}`;
    }
    ngOnChanges() {
        this.input.describedBy = this.error ? this.errorId : null;
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <select> with [ngl] attribute inside ngl-select`);
        }
        this.ɵRequiredSubscription = this.input.ɵRequiredSubject.subscribe((required) => {
            this.required = required;
            this.cd.detectChanges();
        });
        this._uid = this.input.id;
        this.cd.detectChanges();
    }
    ngOnDestroy() {
        if (this.ɵRequiredSubscription) {
            this.ɵRequiredSubscription.unsubscribe();
            this.ɵRequiredSubscription = null;
        }
    }
}
NglSelect.ɵfac = function NglSelect_Factory(t) { return new (t || NglSelect)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglSelect.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglSelect, selectors: [["ngl-select"], ["", "ngl-select", ""]], contentQueries: function NglSelect_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglSelectInput, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 4, hostBindings: function NglSelect_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-form-element", true)("slds-has-error", ctx.hasError);
    } }, inputs: { label: "label", fieldLevelHelpTooltip: "fieldLevelHelpTooltip", error: "error" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 6, vars: 5, consts: [[3, "nglFormLabel", "required"], [3, "content", 4, "ngIf"], [1, "slds-form-element__control"], [1, "slds-select_container"], ["class", "slds-form-element__help", 3, "id", "nglInternalOutlet", 4, "ngIf"], [3, "content"], [1, "slds-form-element__help", 3, "id", "nglInternalOutlet"]], template: function NglSelect_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelement(0, "label", 0);
        ɵngcc0.ɵɵtemplate(1, NglSelect_ngl_form_help_1_Template, 1, 1, "ngl-form-help", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, NglSelect_div_5_Template, 1, 2, "div", 4);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("nglFormLabel", ctx.label)("required", ctx.required);
        ɵngcc0.ɵɵattribute("for", ctx._uid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.fieldLevelHelpTooltip);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasError);
    } }, directives: [NglFormLabel, ɵngcc1.NgIf, NglFormHelp, NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglSelect.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NglSelect.propDecorators = {
    input: [{ type: ContentChild, args: [NglSelectInput, { static: true },] }],
    label: [{ type: Input }],
    fieldLevelHelpTooltip: [{ type: Input }],
    error: [{ type: Input }],
    hasError: [{ type: HostBinding, args: ['class.slds-has-error',] }]
};

const DIRECTIVES$1 = [
    NglSelect,
    NglSelectInput,
];
class NglSelectModule {
}
NglSelectModule.ɵfac = function NglSelectModule_Factory(t) { return new (t || NglSelectModule)(); };
NglSelectModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglSelectModule });
NglSelectModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglFormsModule, NglInternalOutletModule]] });

const NGL_SLIDER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NglSlider),
    multi: true
};
class NglSlider {
    constructor(element, renderer, cd) {
        this.element = element;
        this.renderer = renderer;
        this.cd = cd;
        /**
         * The minimum value that the slider can have.
         */
        this.min = 0;
        /**
         * The maximum value that the slider can have.
         */
        this.max = 100;
        /**
         * The granularity the slider can step through values.
         */
        this.step = 1;
        /**
         * Whether the slider will be displayed vertically.
         */
        this.vertical = false;
        this.valueChange = new EventEmitter();
        this.uid = uniqueId('slider');
        this._value = null;
        this.onChange = null;
        this.onTouched = () => { };
        this.renderer.addClass(this.element.nativeElement, 'slds-form-element');
    }
    get hasError() {
        return !!this.error;
    }
    set value(value) {
        if (value !== this._value) {
            this._value = this.limit(coerceNumberProperty(value));
        }
    }
    get value() {
        // If the value needs to be read and it is still uninitialized, initialize it to the min.
        if (this._value === null) {
            this._value = this.min;
        }
        return this._value;
    }
    writeValue(value) {
        this.value = value;
        this.cd.markForCheck();
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouched = fn; }
    setDisabledState(isDisabled) { this.disabled = isDisabled; }
    onInput(value) {
        // Make sure we always emit number
        this.valueChange.emit(coerceNumberProperty(value));
        if (this.onChange) {
            this.value = value;
            this.onChange(this.value);
        }
    }
    sliderClass() {
        return {
            [`slds-size_${this.size}`]: !!this.size,
            [`slds-slider_vertical`]: this.vertical,
        };
    }
    limit(value) {
        return Math.min(Math.max(value, this.min), this.max);
    }
}
NglSlider.ɵfac = function NglSlider_Factory(t) { return new (t || NglSlider)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglSlider.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglSlider, selectors: [["ngl-slider"]], hostVars: 2, hostBindings: function NglSlider_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-has-error", ctx.hasError);
    } }, inputs: { min: "min", max: "max", step: "step", vertical: "vertical", value: "value", disabled: "disabled", label: "label", size: "size", error: "error" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([NGL_SLIDER_VALUE_ACCESSOR])], decls: 11, vars: 14, consts: [[1, "slds-form-element__label"], [1, "slds-slider-label"], ["class", "slds-slider-label__label", 3, "nglInternalOutlet", 4, "ngIf"], [1, "slds-slider-label__range"], [1, "slds-form-element__control"], [1, "slds-slider", 3, "ngClass"], ["type", "range", 1, "slds-slider__range", 3, "id", "value", "min", "max", "step", "disabled", "input"], ["aria-hidden", "true", 1, "slds-slider__value"], ["class", "slds-form-element__help", 3, "id", "nglInternalOutlet", 4, "ngIf"], [1, "slds-slider-label__label", 3, "nglInternalOutlet"], [1, "slds-form-element__help", 3, "id", "nglInternalOutlet"]], template: function NglSlider_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵtemplate(2, NglSlider_span_2_Template, 1, 1, "span", 2);
        ɵngcc0.ɵɵelementStart(3, "span", 3);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵelementStart(6, "div", 5);
        ɵngcc0.ɵɵelementStart(7, "input", 6);
        ɵngcc0.ɵɵlistener("input", function NglSlider_Template_input_input_7_listener($event) { return ctx.onInput($event.target.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "span", 7);
        ɵngcc0.ɵɵtext(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, NglSlider_div_10_Template, 1, 2, "div", 8);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("for", ctx.uid);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.label);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate2("", ctx.min, " - ", ctx.max, "");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngClass", ctx.sliderClass());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.uid)("value", ctx.value)("min", ctx.min)("max", ctx.max)("step", ctx.step)("disabled", ctx.disabled);
        ɵngcc0.ɵɵattribute("aria-describedby", ctx.hasError ? ctx.uid + "-error" : null);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.value);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasError);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglSlider.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
NglSlider.propDecorators = {
    label: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    step: [{ type: Input }],
    vertical: [{ type: Input }],
    size: [{ type: Input }],
    disabled: [{ type: Input }],
    error: [{ type: Input }],
    hasError: [{ type: HostBinding, args: ['class.slds-has-error',] }],
    value: [{ type: Input }],
    valueChange: [{ type: Output }]
};
__decorate([
    InputNumber()
], NglSlider.prototype, "min", void 0);
__decorate([
    InputNumber()
], NglSlider.prototype, "max", void 0);
__decorate([
    InputNumber()
], NglSlider.prototype, "step", void 0);
__decorate([
    InputBoolean()
], NglSlider.prototype, "vertical", void 0);
__decorate([
    InputBoolean()
], NglSlider.prototype, "disabled", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HostService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.RendererFactory2 }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglIcon, [{
        type: Component,
        args: [{
                selector: 'ngl-icon, [ngl-icon]',
                template: "\n<svg class=\"slds-icon\" [nglIconName]=\"iconName\" [ngClass]=\"svgClasses()\"></svg>\n<ng-content></ng-content><span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{alternativeText}}</span>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: HostService }]; }, { variant: [{
            type: Input
        }], iconName: [{
            type: Input
        }], size: [{
            type: Input
        }], alternativeText: [{
            type: Input
        }], svgClass: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglIconSvg, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'svg[nglIconName]',
                template: "\n<svg:use [attr.xlink:href]=\"iconPath\" [attr.x]=\"xPos\"></svg:use>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NglIconConfig, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NGL_ICON_CONFIG]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { xPos: [{
            type: Input
        }], iconName: [{
            type: Input,
            args: ['nglIconName']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglIconsModule, [{
        type: NgModule,
        args: [{
                declarations: NGL_ICON_DIRECTIVES,
                exports: NGL_ICON_DIRECTIVES,
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglIconsModule, { declarations: function () { return [NglIcon, NglIconSvg]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglIcon, NglIconSvg]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglInternalOutlet, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: '[nglInternalOutlet]',
                template: `
    <ng-template [ngIf]="isTemplate()" [ngIfElse]="str">
      <ng-template [ngTemplateOutlet]="nglInternalOutlet" [ngTemplateOutletContext]="nglInternalOutletContext"></ng-template>
    </ng-template>
    <ng-template #str>{{nglInternalOutlet}}</ng-template>`,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { nglInternalOutlet: [{
            type: Input
        }], nglInternalOutletContext: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglInternalOutletModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [NglInternalOutlet],
                exports: [NglInternalOutlet]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglInternalOutletModule, { declarations: function () { return [NglInternalOutlet]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglInternalOutlet]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglAccordionSection, [{
        type: Directive,
        args: [{
                selector: '[nglAccordionSection]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, { name: [{
            type: Input
        }], label: [{
            type: Input
        }], labelContext: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglAccordion, [{
        type: Component,
        args: [{
                selector: 'ngl-accordion,[ngl-accordion]',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "\n<li *ngFor=\"let section of sections\" nglAccordionItem [isActive]=\"isActive(section)\" [section]=\"section\" (toggle)=\"toggle(section)\"></li>"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { activeNameChange: [{
            type: Output
        }], multiple: [{
            type: Input
        }], activeName: [{
            type: Input
        }], sections: [{
            type: ContentChildren,
            args: [NglAccordionSection]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglAccordionItem, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'li[nglAccordionItem]',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "\n<section class=\"slds-accordion__section\" [class.slds-is-open]=\"isActive\">\n  <div class=\"slds-accordion__summary\">\n    <h3 class=\"slds-accordion__summary-heading\" (click)=\"onToggle()\">\n      <button class=\"slds-button slds-button_reset slds-accordion__summary-action\" [attr.aria-controls]=\"uid\" [attr.aria-expanded]=\"isActive\" type=\"button\">\n        <svg class=\"slds-accordion__summary-action-icon slds-button__icon slds-button__icon_left\" nglIconName=\"utility:switch\"></svg><span class=\"slds-truncate\" [nglInternalOutlet]=\"section.label\" [nglInternalOutletContext]=\"{$implicit: section.labelContext}\"></span>\n      </button>\n    </h3>\n  </div>\n  <div class=\"slds-accordion__content\" [attr.hidden]=\"isActive ? null : ''\" [id]=\"uid\">\n    <ng-container *ngIf=\"isActive\">\n      <ng-template [ngTemplateOutlet]=\"section.templateRef\"></ng-template>\n    </ng-container>\n  </div>\n</section>"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { toggle: [{
            type: Output
        }], isActive: [{
            type: Input
        }], section: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglAccordionModule, [{
        type: NgModule,
        args: [{
                declarations: [...DIRECTIVES$c, NglAccordionItem],
                exports: DIRECTIVES$c,
                imports: [CommonModule, NglIconsModule, NglInternalOutletModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglAccordionModule, { declarations: function () { return [NglAccordion, NglAccordionSection, NglAccordionItem]; }, imports: function () { return [CommonModule, NglIconsModule, NglInternalOutletModule]; }, exports: function () { return [NglAccordion, NglAccordionSection]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglCommonNotify, [{
        type: Directive
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }, { type: String, decorators: [{
                type: Inject,
                args: ['type']
            }] }]; }, { closeButtonAssistiveText: [{
            type: Input
        }], closeEventEmitter: [{
            type: Output,
            args: ['close']
        }], variant: [{
            type: Input
        }], duration: [{
            type: Input
        }], iconName: [{
            type: Input
        }], assistiveText: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglAlert, [{
        type: Component,
        args: [{
                selector: 'ngl-alert',
                template: "<span class=\"slds-assistive-text\">{{assistiveText || variant}}</span>\n<ngl-icon class=\"slds-m-right_x-small\" *ngIf=\"iconName\" [iconName]=\"iconName\" size=\"x-small\" variant=\"\"></ngl-icon>\n<div class=\"slds-notify__content\">\n  <ng-content></ng-content>\n</div>\n<button class=\"slds-button slds-button_icon slds-notify__close slds-button_icon-inverse\" *ngIf=\"dismissible\" type=\"button\" (click)=\"close('button', $event)\">\n  <svg class=\"slds-button__icon\" nglIconName=\"utility:close\"></svg><span class=\"slds-assistive-text\" *ngIf=\"closeButtonAssistiveText\">{{closeButtonAssistiveText}}</span>\n</button>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'nglAlert'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglCommonNotifyClose, [{
        type: Directive
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: ['host']
            }] }]; }, { dismissible: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglAlertClose, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'ngl-alert[close]'
            }]
    }], function () { return [{ type: NglAlert }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglAlertModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_ALERT_DIRECTIVES],
                exports: [NGL_ALERT_DIRECTIVES],
                imports: [CommonModule, NglIconsModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglAlertModule, { declarations: function () { return [NglAlert, NglAlertClose]; }, imports: function () { return [CommonModule, NglIconsModule]; }, exports: function () { return [NglAlert, NglAlertClose]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglAvatar, [{
        type: Component,
        args: [{
                selector: 'ngl-avatar',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "<img *ngIf=\"shouldShowImage; else template_initials\" [src]=\"src\" [alt]=\"alternativeText\" (error)=\"onImgError()\">\n<ng-template #template_initials><abbr class=\"slds-avatar__initials\" [ngClass]=\"fallbackIconClass()\">{{ initials }}</abbr></ng-template>",
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: HostService }]; }, { src: [{
            type: Input
        }], alternativeText: [{
            type: HostBinding,
            args: ['attr.title']
        }, {
            type: Input
        }], fallbackIconName: [{
            type: Input
        }], error: [{
            type: Output
        }], size: [{
            type: Input
        }], variant: [{
            type: Input
        }], initials: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglAvatarModule, [{
        type: NgModule,
        args: [{
                declarations: [NglAvatar],
                exports: [NglAvatar],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglAvatarModule, { declarations: function () { return [NglAvatar]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglAvatar]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglBadge, [{
        type: Component,
        args: [{
                selector: 'ngl-badge',
                template: "<span class=\"slds-badge\" [ngClass]=\"theme ? 'slds-theme_' + theme : ''\">\n  <ng-content></ng-content></span>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { theme: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglBadgesModule, [{
        type: NgModule,
        args: [{
                declarations: [NglBadge],
                exports: [NglBadge],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglBadgesModule, { declarations: function () { return [NglBadge]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglBadge]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglBreadcrumb, [{
        type: Directive,
        args: [{
                selector: '[nglBreadcrumb]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglBreadcrumbs, [{
        type: Component,
        args: [{
                selector: 'ngl-breadcrumbs',
                template: "\n<nav role=\"navigation\" [attr.aria-label]=\"assistiveText\">\n  <ol class=\"slds-breadcrumb slds-list_horizontal slds-wrap\">\n    <li class=\"slds-breadcrumb__item\" *ngFor=\"let b of breadcrumbs\">\n      <ng-template [ngTemplateOutlet]=\"b.templateRef\"></ng-template>\n    </li>\n  </ol>\n</nav>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { assistiveText: [{
            type: Input
        }], breadcrumbs: [{
            type: ContentChildren,
            args: [NglBreadcrumb]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglBreadcrumbsModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_BREADCRUMB_DIRECTIVES],
                exports: [NGL_BREADCRUMB_DIRECTIVES],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglBreadcrumbsModule, { declarations: function () { return [NglBreadcrumbs, NglBreadcrumb]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglBreadcrumbs, NglBreadcrumb]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglButtonIcon, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: '[nglButtonIcon]',
                template: "\n<svg class=\"slds-button__icon\" *ngIf=\"iconName\" [nglIconName]=\"iconName\" [ngClass]=\"iconClass()\"></svg>\n<ng-content></ng-content><span class=\"slds-assistive-text\" *ngIf=\"altText as text\">{{ text }}</span>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: HostService }, { type: ɵngcc0.Renderer2 }]; }, { variant: [{
            type: Input
        }], iconName: [{
            type: Input
        }], title: [{
            type: Input
        }], alternativeText: [{
            type: Input
        }], size: [{
            type: Input
        }], svgClass: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglButtonIconStateful, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: '[nglButtonIconStateful]',
                template: "\n<svg class=\"slds-button__icon\" *ngIf=\"iconName\" [nglIconName]=\"iconName\"></svg>\n<ng-content></ng-content><span class=\"slds-assistive-text\" *ngIf=\"altText as text\">{{ text }}</span>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: HostService }, { type: ɵngcc0.Renderer2 }]; }, { selected: [{
            type: HostBinding,
            args: ['class.slds-is-selected']
        }, {
            type: HostBinding,
            args: ['attr.aria-pressed']
        }, {
            type: Input
        }], selectedChange: [{
            type: Output
        }], variant: [{
            type: Input
        }], size: [{
            type: Input
        }], onclick: [{
            type: HostListener,
            args: ['click']
        }], iconName: [{
            type: Input
        }], title: [{
            type: Input
        }], alternativeText: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglButtonIconsModule, [{
        type: NgModule,
        args: [{
                declarations: NGL_BUTTON_ICON_DIRECTIVES,
                exports: NGL_BUTTON_ICON_DIRECTIVES,
                imports: [CommonModule, NglIconsModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglButtonIconsModule, { declarations: function () { return [NglButtonIcon, NglButtonIconStateful]; }, imports: function () { return [CommonModule, NglIconsModule]; }, exports: function () { return [NglButtonIcon, NglButtonIconStateful]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglButton, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: '[nglButton]',
                template: "\n<svg class=\"slds-button__icon slds-button__icon_left\" *ngIf=\"hasLeftIcon()\" [nglIconName]=\"iconName\"></svg>\n<ng-content></ng-content>\n<svg class=\"slds-button__icon slds-button__icon_right\" *ngIf=\"hasRightIcon()\" [nglIconName]=\"iconName\"></svg>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: HostService }]; }, { variant: [{
            type: Input
        }], iconPosition: [{
            type: Input
        }], iconName: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglButtonStateful, [{
        type: Directive,
        args: [{
                selector: '[nglButtonStateful]',
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: HostService }]; }, { stateChange: [{
            type: Output
        }], variant: [{
            type: Input
        }], onSelectChange: [{
            type: HostListener,
            args: ['click']
        }], onFocusToggle: [{
            type: HostListener,
            args: ['focus', ['1']]
        }, {
            type: HostListener,
            args: ['blur', ['0']]
        }], state: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglButtonStateOn, [{
        type: Component,
        args: [{
                selector: 'ngl-state-on',
                template: "\n<svg class=\"slds-button__icon slds-button__icon_small slds-button__icon_left\" *ngIf=\"iconName\" [nglIconName]=\"iconName\"></svg>\n<ng-content></ng-content>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { iconName: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglButtonStateOff, [{
        type: Component,
        args: [{
                selector: 'ngl-state-off',
                template: "\n<svg class=\"slds-button__icon slds-button__icon_small slds-button__icon_left\" *ngIf=\"iconName\" [nglIconName]=\"iconName\"></svg>\n<ng-content></ng-content>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglButtonStateHover, [{
        type: Component,
        args: [{
                selector: 'ngl-state-hover',
                template: "\n<svg class=\"slds-button__icon slds-button__icon_small slds-button__icon_left\" *ngIf=\"iconName\" [nglIconName]=\"iconName\"></svg>\n<ng-content></ng-content>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglButtonsModule, [{
        type: NgModule,
        args: [{
                declarations: NGL_BUTTON_DIRECTIVES,
                exports: NGL_BUTTON_DIRECTIVES,
                imports: [CommonModule, NglIconsModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglButtonsModule, { declarations: function () { return [NglButton, NglButtonStateful, NglButtonStateOn, NglButtonStateOff, NglButtonStateHover]; }, imports: function () { return [CommonModule, NglIconsModule]; }, exports: function () { return [NglButton, NglButtonStateful, NglButtonStateOn, NglButtonStateOff, NglButtonStateHover]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglCarouselImage, [{
        type: Component,
        args: [{
                selector: 'ngl-carousel-image',
                template: "<a class=\"slds-carousel__panel-action slds-text-link_reset\" href=\"javascript:void(0);\" [attr.tabindex]=\"active ? 0 : -1\">\n  <div class=\"slds-carousel__image\"><img [src]=\"src\" [attr.alt]=\"alternativeText || null\"></div>\n  <div class=\"slds-carousel__content\">\n    <h2 class=\"slds-carousel__content-title\" [nglInternalOutlet]=\"header\"></h2>\n    <p [nglInternalOutlet]=\"description\"></p>\n  </div></a>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { src: [{
            type: Input
        }], header: [{
            type: Input
        }], description: [{
            type: Input
        }], alternativeText: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglCarouselIndicator, [{
        type: Directive,
        args: [{
                selector: '[nglCarouselIndicator]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { uid: [{
            type: HostBinding,
            args: ['attr.id']
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], isActive: [{
            type: HostBinding,
            args: ['class.slds-is-active']
        }, {
            type: HostBinding,
            args: ['attr.aria-selected']
        }, {
            type: Input
        }], image: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglCarousel, [{
        type: Component,
        args: [{
                selector: 'ngl-carousel',
                template: "\n<div class=\"slds-carousel__stage\"><span class=\"slds-carousel__autoplay\" *ngIf=\"autoScroll\">\n    <button class=\"slds-button slds-button_icon slds-button_icon-border-filled slds-button_icon-x-small\" [attr.aria-pressed]=\"!playing\" [title]=\"playLabel()\" (click)=\"togglePlay()\">\n      <svg class=\"slds-button__icon\" [nglIconName]=\"playing ? 'utility:pause' : 'utility:right'\"></svg><span class=\"slds-assistive-text\">{{ playLabel() }}</span>\n    </button></span>\n  <div class=\"slds-carousel__panels\" [style.transform]=\"'translateX(' + (-active * 100) + '%)'\">\n    <ng-content></ng-content>\n  </div>\n  <ul class=\"slds-carousel__indicators\" #indicatorsEl role=\"tablist\" (keydown)=\"onKeyboard($event)\">\n    <li class=\"slds-carousel__indicator\" *ngFor=\"let image of images; let i = index\" role=\"presentation\"><a class=\"slds-carousel__indicator-action\" nglCarouselIndicator href=\"javascript:void(0);\" role=\"tab\" [isActive]=\"isActive(i)\" [image]=\"getImage(i)\" [attr.aria-controls]=\"image.uid\" [title]=\"image.header\" (click)=\"onIndicatorClick(i)\"><span class=\"slds-assistive-text\">{{ image.header }}</span></a></li>\n  </ul>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-carousel]': 'true'
                }
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { activeChange: [{
            type: Output
        }], scrollDuration: [{
            type: Input
        }], autoScroll: [{
            type: Input
        }], autoRefresh: [{
            type: Input
        }], labels: [{
            type: Input
        }], active: [{
            type: Input
        }], images: [{
            type: ContentChildren,
            args: [NglCarouselImage]
        }], indicators: [{
            type: ViewChildren,
            args: [NglCarouselIndicator]
        }], indicatorsEl: [{
            type: ViewChild,
            args: ['indicatorsEl', { static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglCarouselModule, [{
        type: NgModule,
        args: [{
                declarations: [...DIRECTIVES$b, NglCarouselIndicator],
                exports: DIRECTIVES$b,
                imports: [CommonModule, NglIconsModule, NglInternalOutletModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglCarouselModule, { declarations: function () { return [NglCarousel, NglCarouselImage, NglCarouselIndicator]; }, imports: function () { return [CommonModule, NglIconsModule, NglInternalOutletModule]; }, exports: function () { return [NglCarousel, NglCarouselImage]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglCheckboxInput, [{
        type: Directive,
        args: [{
                selector: 'input[ngl][type=checkbox]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { required: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglCheckboxButton, [{
        type: Component,
        args: [{
                selector: 'ngl-checkbox-button',
                template: "\n<ng-content></ng-content>\n<label class=\"slds-checkbox_faux\" [attr.for]=\"_uid\"><span class=\"slds-assistive-text\" [nglInternalOutlet]=\"label\"></span></label>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-checkbox_add-button]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { input: [{
            type: ContentChild,
            args: [NglCheckboxInput, { static: true }]
        }], label: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglCheckbox, [{
        type: Component,
        args: [{
                selector: 'ngl-checkbox,[ngl-checkbox]',
                template: "\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-checkbox\" [class.slds-checkbox_stacked]=\"stacked\"><abbr class=\"slds-required\" *ngIf=\"required\" title=\"required\">*</abbr>\n    <ng-content></ng-content>\n    <label class=\"slds-checkbox__label\" [attr.for]=\"_uid\"><span class=\"slds-checkbox_faux\"></span><span class=\"slds-form-element__label\" [nglInternalOutlet]=\"label\"></span></label>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"hasError\" [id]=\"errorId\" [nglInternalOutlet]=\"error\"></div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-form-element]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { hasError: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }], input: [{
            type: ContentChild,
            args: [NglCheckboxInput, { static: true }]
        }], label: [{
            type: Input
        }], error: [{
            type: Input
        }], stacked: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglCheckboxToggle, [{
        type: Component,
        args: [{
                selector: 'ngl-checkbox-toggle',
                template: "\n<label class=\"slds-checkbox_toggle slds-grid\"><abbr class=\"slds-required\" *ngIf=\"required\" title=\"required\">*</abbr><span class=\"slds-form-element__label slds-m-bottom_none\" [nglInternalOutlet]=\"label\"></span>\n  <ng-content></ng-content><span class=\"slds-checkbox_faux_container\" [id]=\"uid\" aria-live=\"assertive\"><span class=\"slds-checkbox_faux\"></span><span class=\"slds-checkbox_on\">{{enabledText}}</span><span class=\"slds-checkbox_off\">{{disabledText}}</span></span>\n</label>\n<div class=\"slds-form-element__help\" *ngIf=\"error\">{{error}}</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-form-element]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { enabledText: [{
            type: Input
        }], disabledText: [{
            type: Input
        }], hasError: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }], input: [{
            type: ContentChild,
            args: [NglCheckboxInput, { static: true }]
        }], label: [{
            type: Input
        }], error: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglCheckboxOption, [{
        type: Component,
        args: [{
                selector: 'ngl-checkbox-option',
                template: "\n<ng-content></ng-content>\n<label class=\"slds-checkbox__label\" *ngIf=\"type === 'list'\" [attr.for]=\"input.id\"><span class=\"slds-checkbox_faux\"></span><span class=\"slds-form-element__label\" [nglInternalOutlet]=\"label\"></span></label>\n<label class=\"slds-checkbox_button__label\" *ngIf=\"type === 'button'\" [attr.for]=\"input.id\"><span class=\"slds-checkbox_faux\" [nglInternalOutlet]=\"label\"></span></label>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: HostService }]; }, { label: [{
            type: Input
        }], input: [{
            type: ContentChild,
            args: [NglCheckboxInput, { static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglCheckboxGroup, [{
        type: Component,
        args: [{
                selector: 'ngl-checkbox-group,[ngl-checkbox-group]',
                template: "\n<legend class=\"slds-form-element__legend slds-form-element__label\"><abbr class=\"slds-required\" *ngIf=\"required\" title=\"required\">*</abbr><span [nglInternalOutlet]=\"label\"></span></legend>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-checkbox_button-group\" *ngIf=\"type === 'button'; else contentTpl\">\n    <ng-container *ngTemplateOutlet=\"contentTpl\"></ng-container>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"hasError\" [id]=\"errorId\" [nglInternalOutlet]=\"error\"></div>\n<ng-template #contentTpl>\n  <ng-content></ng-content>\n</ng-template>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-form-element]': 'true'
                }
            }]
    }], function () { return []; }, { hasError: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }], type: [{
            type: Input
        }], options: [{
            type: ContentChildren,
            args: [NglCheckboxOption]
        }], label: [{
            type: Input
        }], error: [{
            type: Input
        }], required: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglCheckboxesModule, [{
        type: NgModule,
        args: [{
                declarations: DIRECTIVES$a,
                exports: DIRECTIVES$a,
                imports: [CommonModule, NglInternalOutletModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglCheckboxesModule, { declarations: function () { return [NglCheckboxButton, NglCheckbox, NglCheckboxToggle, NglCheckboxInput, NglCheckboxGroup, NglCheckboxOption]; }, imports: function () { return [CommonModule, NglInternalOutletModule]; }, exports: function () { return [NglCheckboxButton, NglCheckbox, NglCheckboxToggle, NglCheckboxInput, NglCheckboxGroup, NglCheckboxOption]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglTab, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[ngl-tab]',
                exportAs: 'nglTab'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, { activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], id: [{
            type: Input
        }], label: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglTabs, [{
        type: Component,
        args: [{
                selector: 'ngl-tabset',
                template: "\n<ul [ngClass]=\"'slds-tabs_' + variant + '__nav'\" role=\"tablist\" (keydown.ArrowLeft)=\"move($event, -1)\" (keydown.ArrowRight)=\"move($event, 1)\">\n  <li *ngFor=\"let tab of tabs; trackBy: trackByTab\" [ngClass]=\"'slds-tabs_' + variant + '__item'\" [class.slds-is-active]=\"tab.active\" [id]=\"tab.uid + '__item'\" [attr.aria-controls]=\"tab.uid\" (click)=\"select(tab)\" role=\"presentation\"><a [nglInternalOutlet]=\"tab.label\" [ngClass]=\"'slds-tabs_' + variant + '__link'\" role=\"tab\" [attr.aria-selected]=\"tab.active\" [attr.tabindex]=\"tab.active ? 0 : -1\"></a></li>\n</ul>\n<div *ngFor=\"let tab of tabs; trackBy: trackByTab\" [id]=\"tab.uid\" [attr.aria-labelledby]=\"tab.uid + '__item'\" [ngClass]=\"tabClass(tab)\" role=\"tabpanel\">\n  <ng-container *ngIf=\"!lazy || tab.active\">\n    <ng-template [ngTemplateOutlet]=\"tab?.templateRef\"></ng-template>\n  </ng-container>\n</div>"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { selectedChange: [{
            type: Output
        }], lazy: [{
            type: Input
        }], variant: [{
            type: Input
        }], setSelected: [{
            type: Input,
            args: ['selected']
        }], tabs: [{
            type: ContentChildren,
            args: [NglTab]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglTabLabel, [{
        type: Directive,
        args: [{ selector: '[ngl-tab-label]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglTabContent, [{
        type: Directive,
        args: [{ selector: '[ngl-tab-content]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglTabVerbose, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'ngl-tab',
                providers: [{ provide: NglTab, useExisting: NglTabVerbose }]
            }]
    }], null, { contentTemplate: [{
            type: ContentChild,
            args: [NglTabContent]
        }], labelTemplate: [{
            type: ContentChild,
            args: [NglTabLabel]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglTabsModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_TAB_DIRECTIVES],
                exports: [NGL_TAB_DIRECTIVES],
                imports: [CommonModule, NglInternalOutletModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglTabsModule, { declarations: function () { return [NglTabs, NglTab, NglTabVerbose, NglTabContent, NglTabLabel]; }, imports: function () { return [CommonModule, NglInternalOutletModule]; }, exports: function () { return [NglTabs, NglTab, NglTabVerbose, NglTabContent, NglTabLabel]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglPopover, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'section[ngl-popover]',
                template: "\n<button class=\"slds-button slds-button_icon slds-button_icon-small slds-float_right slds-popover__close\" *ngIf=\"canClose &amp;&amp; closeVisible\" [title]=\"closeTitle\" [class.slds-button_icon-inverse]=\"inverseCloseButton\" (click)=\"onClose()\">\n  <svg class=\"slds-button__icon\" nglIconName=\"close\"></svg><span class=\"slds-assistive-text\" *ngIf=\"closeTitle\">{{closeTitle}}</span>\n</button>\n<header class=\"slds-popover__header\" *ngIf=\"header\">\n  <div *ngIf=\"isTemplateRef(header); else defaultTpl\" [id]=\"labelledby\">\n    <ng-container [ngTemplateOutlet]=\"header\"></ng-container>\n  </div>\n  <ng-template #defaultTpl>\n    <h2 class=\"slds-text-heading_small\" [id]=\"labelledby\">{{header}}</h2>\n  </ng-template>\n</header>\n<div class=\"slds-popover__body\" [id]=\"uid\" [nglInternalOutlet]=\"template\"></div>\n<footer class=\"slds-popover__footer\" *ngIf=\"footer\" [nglInternalOutlet]=\"footer\"></footer>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService],
                host: {
                    'role': 'dialog',
                    '[class.slds-popover]': 'true'
                }
            }]
    }], function () { return [{ type: HostService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.FocusTrapFactory }, { type: ɵngcc0.ChangeDetectorRef }]; }, { labelledby: [{
            type: HostBinding,
            args: ['attr.aria-labelledby']
        }], describedby: [{
            type: HostBinding,
            args: ['attr.aria-describedby']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglPopoverTrigger, [{
        type: Directive,
        args: [{
                selector: '[nglPopover]',
                exportAs: 'nglPopover'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc3.Overlay }]; }, { closeTitle: [{
            type: Input,
            args: ['nglPopoverCloseTitle']
        }], closeVisible: [{
            type: Input,
            args: ['nglPopoverCloseVisible']
        }], nglPopoverOpenChange: [{
            type: Output
        }], placement: [{
            type: Input,
            args: ['nglPopoverPlacement']
        }], nglOpen: [{
            type: Input,
            args: ['nglPopoverOpen']
        }], onclick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], template: [{
            type: Input,
            args: ['nglPopover']
        }], header: [{
            type: Input,
            args: ['nglPopoverHeader']
        }], footer: [{
            type: Input,
            args: ['nglPopoverFooter']
        }], variant: [{
            type: Input,
            args: ['nglPopoverVariant']
        }], size: [{
            type: Input,
            args: ['nglPopoverSize']
        }], popoverClass: [{
            type: Input,
            args: ['nglPopoverClass']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglPopoversModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_POPOVER_DIRECTIVES],
                exports: [NGL_POPOVER_DIRECTIVES],
                imports: [CommonModule, OverlayModule, A11yModule, NglInternalOutletModule, NglIconsModule],
                entryComponents: [NglPopover]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglPopoversModule, { declarations: function () { return [NglPopover, NglPopoverTrigger]; }, imports: function () { return [CommonModule, OverlayModule, A11yModule, NglInternalOutletModule, NglIconsModule]; }, exports: function () { return [NglPopover, NglPopoverTrigger]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglTooltip, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'div[ngl-tooltip]',
                template: "\n<div class=\"slds-popover__body\" [nglInternalOutlet]=\"template\"></div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: HostService }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglTooltipTrigger, [{
        type: Directive,
        args: [{
                selector: '[nglTooltip]',
                exportAs: 'nglTooltip'
            }]
    }], function () { return [{ type: NglTooltipConfig, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NGL_TOOLTIP_CONFIG]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc3.Overlay }]; }, { nglTooltipOpenChange: [{
            type: Output
        }], openAuto: [{
            type: Input,
            args: ['nglTooltipOpenAuto']
        }], interactive: [{
            type: Input,
            args: ['nglTooltipInteractive']
        }], delay: [{
            type: Input,
            args: ['nglTooltipDelay']
        }], placement: [{
            type: Input,
            args: ['nglTooltipPlacement']
        }], nglOpen: [{
            type: Input,
            args: ['nglTooltipOpen']
        }], onMouseOver: [{
            type: HostListener,
            args: ['mouseenter']
        }, {
            type: HostListener,
            args: ['focus']
        }], onMouseOut: [{
            type: HostListener,
            args: ['mouseleave']
        }, {
            type: HostListener,
            args: ['blur']
        }], template: [{
            type: Input,
            args: ['nglTooltip']
        }], tooltipClass: [{
            type: Input,
            args: ['nglTooltipClass']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglTooltipsModule, [{
        type: NgModule,
        args: [{
                declarations: [NglTooltip, NglTooltipTrigger],
                exports: [NglTooltipTrigger],
                imports: [CommonModule, OverlayModule, A11yModule, NglInternalOutletModule],
                entryComponents: [NglTooltip]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglTooltipsModule, { declarations: function () { return [NglTooltip, NglTooltipTrigger]; }, imports: function () { return [CommonModule, OverlayModule, A11yModule, NglInternalOutletModule]; }, exports: function () { return [NglTooltipTrigger]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglFormLabel, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'label[nglFormLabel]',
                template: "<abbr class=\"slds-required\" *ngIf=\"required\" title=\"Required\">*</abbr><span [nglInternalOutlet]=\"label\"></span>\n<ng-content></ng-content>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { klass: [{
            type: Input,
            args: ['nglFormLabelClass']
        }], label: [{
            type: Input,
            args: ['nglFormLabel']
        }], required: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglFormHelp, [{
        type: Component,
        args: [{
                selector: 'ngl-form-help',
                template: "\n<button class=\"slds-button slds-button_icon\" [nglTooltip]=\"content\" [(nglTooltipOpen)]=\"isOpen\">\n  <svg class=\"slds-button__icon\" nglIconName=\"utility:info\"></svg><span class=\"slds-assistive-text\">Help</span>\n</button>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-form-element__icon]': 'true'
                }
            }]
    }], function () { return []; }, { content: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglFormsModule, [{
        type: NgModule,
        args: [{
                declarations: DIRECTIVES$9,
                exports: DIRECTIVES$9,
                imports: [CommonModule, NglInternalOutletModule, NglIconsModule, NglTooltipsModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglFormsModule, { declarations: function () { return [NglFormLabel, NglFormHelp]; }, imports: function () { return [CommonModule, NglInternalOutletModule, NglIconsModule, NglTooltipsModule]; }, exports: function () { return [NglFormLabel, NglFormHelp]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglColorpicker, [{
        type: Component,
        args: [{
                selector: 'ngl-colorpicker',
                template: "\n<div class=\"slds-color-picker__summary slds-form-element\" [class.slds-has-error]=\"!isValidInput\">\n  <label class=\"slds-form-element__label slds-color-picker__summary-label\" [nglFormLabel]=\"label\" [attr.for]=\"uid + '-summary-input'\" [required]=\"required\">\n    <ngl-form-help class=\"slds-m-horizontal_xx-small\" *ngIf=\"fieldLevelHelpTooltip\" [content]=\"fieldLevelHelpTooltip\"></ngl-form-help>\n  </label>\n  <div class=\"slds-form-element__control\">\n    <button class=\"slds-button slds-color-picker__summary-button slds-button_icon slds-button_icon-more\" [title]=\"label\" [nglPopover]=\"tip\" nglPopoverPlacement=\"bottom-left\" [nglPopoverOpen]=\"open\" (nglPopoverOpenChange)=\"openChange($event)\" nglPopoverClass=\"slds-color-picker__selector\" [nglPopoverFooter]=\"footer\" nglPopoverCloseVisible=\"false\" [disabled]=\"disabled\"><span class=\"slds-swatch\" nglColorpickerSwatch [color]=\"isValidInput ? color : hexCurrent\"></span>\n      <svg class=\"slds-button__icon slds-button__icon_small slds-m-left_xx-small\" *ngIf=\"!disabled\" nglIconName=\"utility:down\"></svg><span class=\"slds-assistive-text\">{{ label }}: {{ color }}</span>\n    </button>\n    <div class=\"slds-color-picker__summary-input\">\n      <input class=\"slds-input\" [id]=\"uid + '-summary-input'\" type=\"text\" [value]=\"color\" (input)=\"onInput($event.target.value)\" [disabled]=\"disabled\" [readOnly]=\"readonlyInput\" maxlength=\"7\" [placeholder]=\"placeholder || ''\">\n    </div>\n    <p class=\"slds-form-error\" *ngIf=\"!isValidInput\" [nglInternalOutlet]=\"invalidColorLabel\"></p>\n  </div>\n</div>\n<ng-template #tip>\n  <ng-container [ngSwitch]=\"variant\">\n    <ng-container *ngSwitchCase=\"'swatches'\">\n      <ng-template [ngTemplateOutlet]=\"swatches\"></ng-template>\n    </ng-container>\n    <ng-container *ngSwitchCase=\"'custom'\">\n      <ng-template [ngTemplateOutlet]=\"custom\"></ng-template>\n    </ng-container>\n    <ngl-tabset *ngSwitchDefault [selected]=\"defaultSelectedTab\" (selectedChange)=\"defaultSelectedTab = $event.id\">\n      <ng-template ngl-tab id=\"swatches\" [label]=\"swatchTabLabel\">\n        <ng-template [ngTemplateOutlet]=\"swatches\"></ng-template>\n      </ng-template>\n      <ng-template ngl-tab id=\"custom\" [label]=\"customTabLabel\">\n        <ng-template [ngTemplateOutlet]=\"custom\"></ng-template>\n      </ng-template>\n    </ngl-tabset>\n  </ng-container>\n</ng-template>\n<ng-template #swatches>\n  <ngl-colorpicker-swatches [hex]=\"hexCurrent\" (hexChange)=\"onSwatchSelection($event)\" [swatchColors]=\"swatchColors\"></ngl-colorpicker-swatches>\n</ng-template>\n<ng-template #custom>\n  <ngl-colorpicker-custom [hsv]=\"hsvCurrent\" (hsvChange)=\"onCustomSelection($event)\"></ngl-colorpicker-custom>\n</ng-template>\n<ng-template #footer>\n  <div class=\"slds-color-picker__selector-footer\">\n    <button class=\"slds-button slds-button_neutral\" type=\"button\" (click)=\"cancel()\">{{ cancelButtonLabel }}</button>\n    <button class=\"slds-button slds-button_brand\" type=\"button\" (click)=\"done()\" [disabled]=\"!canApply()\">{{ submitButtonLabel }}</button>\n  </div>\n</ng-template>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [NGL_COLORPICKER_VALUE_ACCESSOR]
            }]
    }], function () { return [{ type: NglColorpickerConfig, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NGL_COLORPICKER_CONFIG]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, { label: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], cancelButtonLabel: [{
            type: Input
        }], submitButtonLabel: [{
            type: Input
        }], required: [{
            type: Input
        }], invalidColorLabel: [{
            type: Input
        }], swatchTabLabel: [{
            type: Input
        }], customTabLabel: [{
            type: Input
        }], readonlyInput: [{
            type: Input
        }], defaultSelectedTab: [{
            type: Input
        }], swatchColors: [{
            type: Input
        }], variant: [{
            type: Input
        }], fieldLevelHelpTooltip: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglColorpickerSwatch, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: '[nglColorpickerSwatch]',
                template: "<span class=\"slds-assistive-text\" aria-hidden=\"true\">{{ color }}</span>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { color: [{
            type: HostBinding,
            args: ['style.background']
        }, {
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglColorpickerCustom, [{
        type: Component,
        args: [{
                selector: 'ngl-colorpicker-custom',
                template: "\n<ngl-colorpicker-range [hsv]=\"hsv\" (hsvChange)=\"onHsvChange($event)\"></ngl-colorpicker-range>\n<ngl-colorpicker-inputs [hex]=\"hex\" (hexChange)=\"onHexChange($event)\"></ngl-colorpicker-inputs>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { hsvChange: [{
            type: Output
        }], hsv: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglColorpickerRange, [{
        type: Component,
        args: [{
                selector: 'ngl-colorpicker-range',
                template: "\n<p class=\"slds-assistive-text\" [attr.id]=\"uid + '-instructions'\">Use arrow keys to select a saturation and brightness, on an x and y axis.</p>\n<div class=\"slds-color-picker__custom-range\" #rangeIndicatorContainer [style.background]=\"'hsl(' + hsv.hue + ', 100%, 50%)'\"><a class=\"slds-color-picker__range-indicator\" #rangeIndicator href=\"javascript:void(0);\" aria-live=\"assertive\" aria-atomic=\"true\" [attr.aria-describedby]=\"uid + '-instructions'\" [ngStyle]=\"indicatorStyle()\" (keydown)=\"rangeIndicatorKeyboard($event)\"><span class=\"slds-assistive-text\">Saturation: {{hsv.saturation}}%. Brightness: {{hsv.value}}%.</span></a></div>\n<div class=\"slds-color-picker__hue-and-preview\">\n  <label class=\"slds-assistive-text\" [attr.for]=\"uid + '-hue'\">Select Hue</label>\n  <input class=\"slds-color-picker__hue-slider\" #hueSlider type=\"range\" min=\"0\" max=\"360\" [id]=\"uid + '-hue'\" [value]=\"hsv.hue\" (input)=\"hueSliderChange($event.target.value)\"><span nglColorpickerSwatch [color]=\"hex\"></span>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { hsvChange: [{
            type: Output
        }], hsv: [{
            type: Input
        }], rangeIndicator: [{
            type: ViewChild,
            args: ['rangeIndicator']
        }], rangeIndicatorContainer: [{
            type: ViewChild,
            args: ['rangeIndicatorContainer']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglColorpickerInputs, [{
        type: Component,
        args: [{
                selector: 'ngl-colorpicker-inputs',
                template: "\n<div class=\"slds-color-picker__custom-inputs\">\n  <div class=\"slds-form-element slds-color-picker__input-custom-hex\" [class.slds-has-error]=\"isHexInvalid\">\n    <label class=\"slds-form-element__label\" [attr.for]=\"uid + 'hex'\">Hex</label>\n    <div class=\"slds-form-element__control\">\n      <input class=\"slds-input\" [id]=\"uid + 'hex'\" type=\"text\" maxlength=\"7\" [value]=\"hex\" (input)=\"updateHex($event.target.value)\">\n    </div>\n  </div>\n  <div class=\"slds-form-element\" [class.slds-has-error]=\"!isColorNumberValid('red')\">\n    <label class=\"slds-form-element__label\" [attr.for]=\"uid + 'red'\"><abbr title=\"red\">R</abbr></label>\n    <div class=\"slds-form-element__control\">\n      <input class=\"slds-input\" [id]=\"uid + 'red'\" type=\"text\" maxlength=\"3\" [value]=\"red\" (input)=\"onRGB('red', $event.target.value)\">\n    </div>\n  </div>\n  <div class=\"slds-form-element\" [class.slds-has-error]=\"!isColorNumberValid('green')\">\n    <label class=\"slds-form-element__label\" [attr.for]=\"uid + 'green'\"><abbr title=\"green\">G</abbr></label>\n    <div class=\"slds-form-element__control\">\n      <input class=\"slds-input\" [id]=\"uid + 'green'\" type=\"text\" maxlength=\"3\" [value]=\"green\" (input)=\"onRGB('green', $event.target.value)\">\n    </div>\n  </div>\n  <div class=\"slds-form-element\" [class.slds-has-error]=\"!isColorNumberValid('blue')\">\n    <label class=\"slds-form-element__label\" [attr.for]=\"uid + 'blue'\"><abbr title=\"blue\">B</abbr></label>\n    <div class=\"slds-form-element__control\">\n      <input class=\"slds-input\" [id]=\"uid + 'blue'\" type=\"text\" maxlength=\"3\" [value]=\"blue\" (input)=\"onRGB('blue', $event.target.value)\">\n    </div>\n  </div>\n</div>\n<div class=\"slds-color-picker\">\n  <p class=\"slds-form-error slds-color-picker__input-custom-error\" *ngIf=\"isHexInvalid; else rgbError\">The color entered is invalid</p>\n  <ng-template #rgbError>\n    <p class=\"slds-form-error slds-color-picker__input-custom-error\" *ngIf=\"!isRGBValid()\">The value needs to be an integer from 0-255</p>\n  </ng-template>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { hexChange: [{
            type: Output
        }], hex: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglColorpickerSwatchTrigger, [{
        type: Directive,
        args: [{
                selector: '[nglColorpickerSwatchTrigger]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { selectedChange: [{
            type: Output
        }], onSelect: [{
            type: HostListener,
            args: ['click']
        }], selected: [{
            type: HostBinding,
            args: ['class.ngl-color-picker__swatch-selected']
        }, {
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglColorpickerSwatches, [{
        type: Component,
        args: [{
                selector: 'ngl-colorpicker-swatches',
                template: "\n<li class=\"slds-color-picker__swatch\" *ngFor=\"let color of swatchColors; let i = index\" role=\"presentation\"><a nglColorpickerSwatchTrigger href=\"javascript:void(0);\" [selected]=\"isSelected(color)\" [attr.tabindex]=\"activeIndex === i ? 0 : -1\" (selectedChange)=\"onSelect(color)\"><span nglColorpickerSwatch [color]=\"color\"></span></a></li>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
    .ngl-color-picker__swatch-selected {
      box-shadow: rgb(117, 112, 112) 1px 1px 1px;
    }
  `]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { hexChange: [{
            type: Output
        }], swatchColors: [{
            type: Input
        }], onSelectViaInteraction: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], hex: [{
            type: Input
        }], triggers: [{
            type: ViewChildren,
            args: [NglColorpickerSwatchTrigger]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglColorpickerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    ...DIRECTIVES$8,
                    NglColorpickerSwatch,
                    NglColorpickerCustom,
                    NglColorpickerRange,
                    NglColorpickerInputs,
                    NglColorpickerSwatches,
                    NglColorpickerSwatchTrigger,
                ],
                exports: DIRECTIVES$8,
                imports: [
                    CommonModule,
                    NglIconsModule,
                    NglTabsModule,
                    NglPopoversModule,
                    NglFormsModule,
                    NglInternalOutletModule,
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglColorpickerModule, { declarations: function () { return [NglColorpicker, NglColorpickerSwatch, NglColorpickerCustom, NglColorpickerRange, NglColorpickerInputs, NglColorpickerSwatches, NglColorpickerSwatchTrigger]; }, imports: function () { return [CommonModule, NglIconsModule, NglTabsModule, NglPopoversModule, NglFormsModule, NglInternalOutletModule]; }, exports: function () { return [NglColorpicker]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglOverlaynglOverlayScrolledOutsideViewDirective, [{
        type: Directive,
        args: [{
                selector: '[nglOverlayScrolledOutsideView]'
            }]
    }], function () { return [{ type: ɵngcc3.CdkConnectedOverlay, decorators: [{
                type: Self
            }] }, { type: ɵngcc0.NgZone }, { type: ɵngcc3.ScrollDispatcher }]; }, { overlayOutside: [{
            type: Output,
            args: ['nglOverlayScrolledOutsideView']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglOverlayModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: DIRECTIVES$7,
                exports: DIRECTIVES$7
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglOverlayModule, { declarations: function () { return [NglOverlaynglOverlayScrolledOutsideViewDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglOverlaynglOverlayScrolledOutsideViewDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglComboboxService, [{
        type: Injectable
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglComboboxOption, [{
        type: Component,
        args: [{
                selector: 'ngl-combobox-option, [nglComboboxOption]',
                template: "\n<div class=\"slds-media slds-listbox__option slds-listbox__option_plain slds-media_small slds-media_center\" role=\"option\" [attr.id]=\"uid\" [class.slds-has-focus]=\"active\" [class.slds-is-selected]=\"selected\" [attr.aria-selected]=\"selected || null\" [attr.aria-disabled]=\"disabled || null\"><span class=\"slds-media__figure slds-listbox__option-icon\"><span class=\"slds-icon_container slds-icon-utility-check slds-current-color\" *ngIf=\"selected\">\n      <svg class=\"slds-icon slds-icon_x-small\" nglIconName=\"utility:check\"></svg></span></span><span class=\"slds-media__body\"><span class=\"slds-truncate\"><span class=\"slds-assistive-text\" *ngIf=\"selected\">Current Selection:</span>{{ label }}</span></span></div>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NglComboboxService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { disabled: [{
            type: Input
        }], onSelectViaInteraction: [{
            type: HostListener,
            args: ['mousedown', ['$event']]
        }], hover: [{
            type: HostListener,
            args: ['mouseenter']
        }], value: [{
            type: Input
        }], label: [{
            type: Input
        }], selected: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglComboboxInput, [{
        type: Directive,
        args: [{
                selector: 'input[nglCombobox]'
            }]
    }], function () { return [{ type: NglComboboxService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { isReadonly: [{
            type: HostBinding,
            args: ['readOnly']
        }], ariaAutocomplete: [{
            type: HostBinding,
            args: ['attr.aria-autocomplete']
        }], hasReadonlyValue: [{
            type: HostBinding,
            args: ['class.slds-combobox__input-value']
        }], onMouseInteraction: [{
            type: HostListener,
            args: ['click']
        }], onBlur: [{
            type: HostListener,
            args: ['blur']
        }], onKeyboard: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglCombobox, [{
        type: Component,
        args: [{
                selector: 'ngl-combobox',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "\n<label [nglFormLabel]=\"label\" [attr.for]=\"inputEl.id\"></label>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-combobox_container\" [class.slds-has-selection]=\"hasLookupSingleSelection\">\n    <div class=\"slds-combobox slds-dropdown-trigger slds-dropdown-trigger_click\" [attr.aria-expanded]=\"open\" aria-haspopup=\"listbox\" role=\"combobox\" [class.slds-is-open]=\"open\" [attr.aria-owns]=\"uid\">\n      <div class=\"slds-combobox__form-element slds-input-has-icon\" role=\"none\" cdkOverlayOrigin #overlayOrigin=\"cdkOverlayOrigin\" [class.slds-input-has-icon_group-right]=\"loading\" [class.slds-input-has-icon_right]=\"!loading\">\n        <ng-content select=\"input\"></ng-content>\n        <div class=\"slds-input__icon-group slds-input__icon-group_right\" *ngIf=\"loading; else iconRight\">\n          <div class=\"slds-spinner slds-spinner_brand slds-spinner_x-small slds-input__spinner\" role=\"status\"><span class=\"slds-assistive-text\">{{ loadingLabel }}</span>\n            <div class=\"slds-spinner__dot-a\"></div>\n            <div class=\"slds-spinner__dot-b\"></div>\n          </div>\n          <ng-template [ngTemplateOutlet]=\"iconRight\"></ng-template>\n        </div>\n        <ng-template #iconRight>\n          <button class=\"slds-button slds-button_icon slds-input__icon slds-input__icon_right\" *ngIf=\"hasLookupSingleSelection; else iconTpl\" type=\"button\" (click)=\"onClearSelection()\" [title]=\"removeSelectedLabel\">\n            <svg class=\"slds-button__icon\" nglIconName=\"utility:close\"></svg><span class=\"slds-assistive-text\">{{ removeSelectedLabel }}</span>\n          </button>\n        </ng-template>\n        <ng-template #iconTpl><span class=\"slds-icon_container slds-input__icon slds-input__icon_right\">\n            <svg class=\"slds-icon slds-icon_x-small slds-icon-text-default\" [nglIconName]=\"inputIconRight()\"></svg></span></ng-template>\n      </div>\n    </div>\n  </div>\n</div>\n<ng-template cdkConnectedOverlay #cdkOverlay=\"cdkConnectedOverlay\" [cdkConnectedOverlayPositions]=\"overlayPositions\" [cdkConnectedOverlayOrigin]=\"overlayOrigin\" [cdkConnectedOverlayMinWidth]=\"overlayWidth\" [cdkConnectedOverlayOpen]=\"open\" (nglOverlayScrolledOutsideView)=\"close()\" (attach)=\"onAttach()\" (detach)=\"onDetach()\">\n  <div class=\"slds-dropdown slds-dropdown_fluid\" #dropdown [attr.id]=\"uid\" role=\"listbox\" [ngClass]=\"dropdownClass()\" (mousedown)=\"$event.preventDefault()\">\n    <ul class=\"slds-listbox slds-listbox_vertical\" role=\"presentation\">\n      <li *ngFor=\"let d of data; trackBy: trackByOption\" nglComboboxOption [value]=\"d.value\" [label]=\"d.label\" [disabled]=\"d.disabled\" [selected]=\"isSelected(d.value)\"></li>\n      <li class=\"slds-listbox__item\" *ngIf=\"loadingMore\" role=\"presentation\">\n        <div class=\"slds-align_absolute-center slds-p-top_medium\">\n          <div class=\"slds-spinner slds-spinner_x-small slds-spinner_inline\" role=\"status\">\n            <div class=\"slds-assistive-text\">{{ loadingLabel }}</div>\n            <div class=\"slds-spinner__dot-a\"></div>\n            <div class=\"slds-spinner__dot-b\"></div>\n          </div>\n        </div>\n      </li>\n      <li class=\"slds-listbox__item\" *ngIf=\"hasNoMatches()\" role=\"presentation\" aria-live=\"polite\">\n        <div class=\"slds-align_absolute-center\"><span role=\"status\">{{ noOptionsFound }}</span></div>\n      </li>\n    </ul>\n  </div>\n</ng-template>",
                host: {
                    'class.slds-form-element': 'true'
                },
                providers: [NglComboboxService]
            }]
    }], function () { return [{ type: NglComboboxConfig, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NGL_COMBOBOX_CONFIG]
            }] }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: NglComboboxService }]; }, { variant: [{
            type: Input
        }], open: [{
            type: Input
        }], openChange: [{
            type: Output
        }], selectionChange: [{
            type: Output
        }], multiple: [{
            type: Input
        }], visibleLength: [{
            type: Input
        }], closeOnSelection: [{
            type: Input
        }], selectionValueFn: [{
            type: Input
        }], loadingLabel: [{
            type: Input
        }], noOptionsFound: [{
            type: Input
        }], removeSelectedLabel: [{
            type: Input
        }], data: [{
            type: Input,
            args: ['options']
        }], label: [{
            type: Input
        }], selection: [{
            type: Input
        }], inputEl: [{
            type: ContentChild,
            args: [NglComboboxInput, { static: true }]
        }], loading: [{
            type: Input
        }], loadingMore: [{
            type: Input
        }], options: [{
            type: ViewChildren,
            args: [NglComboboxOption]
        }], overlayOrigin: [{
            type: ViewChild,
            args: ['overlayOrigin', { static: true }]
        }], cdkOverlay: [{
            type: ViewChild,
            args: ['cdkOverlay']
        }], dropdownElementRef: [{
            type: ViewChild,
            args: ['dropdown']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglComboboxesModule, [{
        type: NgModule,
        args: [{
                declarations: DIRECTIVES$6,
                exports: DIRECTIVES$6,
                imports: [CommonModule, NglInternalOutletModule, NglIconsModule, NglFormsModule, OverlayModule, NglOverlayModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglComboboxesModule, { declarations: function () { return [NglCombobox, NglComboboxOption, NglComboboxInput]; }, imports: function () { return [CommonModule, NglInternalOutletModule, NglIconsModule, NglFormsModule, OverlayModule, NglOverlayModule]; }, exports: function () { return [NglCombobox, NglComboboxOption, NglComboboxInput]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDatatableCell, [{
        type: Directive,
        args: [{ selector: '[nglDatatableCell]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDatatableHeadingTemplate, [{
        type: Directive,
        args: [{ selector: '[nglDatatableHeading]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDatatableColumn, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'ngl-datatable-column'
            }]
    }], function () { return []; }, { sortable: [{
            type: Input
        }], truncate: [{
            type: Input
        }], heading: [{
            type: Input
        }], key: [{
            type: Input
        }], headClass: [{
            type: Input
        }], cellClass: [{
            type: Input
        }], cellTpl: [{
            type: ContentChild,
            args: [NglDatatableCell]
        }], headingTpl: [{
            type: ContentChild,
            args: [NglDatatableHeadingTemplate]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDatatableLoadingOverlay, [{
        type: Directive,
        args: [{ selector: '[nglLoadingOverlay]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDatatableNoRowsOverlay, [{
        type: Directive,
        args: [{ selector: '[nglNoRowsOverlay]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDatatable, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'table[ngl-datatable]',
                template: "\n<thead>\n  <tr class=\"slds-line-height_reset\">\n    <th *ngFor=\"let col of columns; trackBy:columnTrackBy\" nglDatatableHead scope=\"col\" [heading]=\"col.heading\" [headingTpl]=\"col.headingTpl?.templateRef\" [sortable]=\"col.sortable\" [sortOrder]=\"getColumnSortOrder(col)\" (sort)=\"onColumnSort(col, $event)\" [ngClass]=\"col.headClass\"></th>\n  </tr>\n</thead>\n<tbody>\n  <ng-template #noData>\n    <tr>\n      <td [attr.colspan]=\"columns.length\">\n        <ng-template [ngTemplateOutlet]=\"noRowsOverlay?.templateRef\"></ng-template>\n      </td>\n    </tr>\n  </ng-template>\n  <ng-container *ngIf=\"data &amp;&amp; data.length &gt; 0; else noData\">\n    <tr *ngFor=\"let d of data; let i = index; trackBy:dataTrackBy\" (click)=\"onRowClick($event, d)\">\n      <td *ngFor=\"let col of columns; trackBy:columnTrackBy\" [ngClass]=\"col.cellClass\" nglDatatatableCell_ [row]=\"d\" [column]=\"col\" [index]=\"i\"></td>\n    </tr>\n  </ng-container>\n</tbody>\n<div class=\"ngl-datatable-loading slds-align_absolute-center\" *ngIf=\"showLoading\">\n  <ng-template [ngTemplateOutlet]=\"loadingOverlay.templateRef\"></ng-template>\n</div>",
                host: {
                    '[class.slds-table]': 'true'
                },
                styles: [`
    .ngl-datatable-loading {
      position: absolute;
      z-index: 1;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255, 255, 255, 0.5)
    }
  `]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { data: [{
            type: Input
        }], sortChange: [{
            type: Output
        }], loading: [{
            type: HostBinding,
            args: ['class.slds-is-relative']
        }, {
            type: Input
        }], rowClick: [{
            type: Output
        }], trackByKey: [{
            type: Input
        }], sort: [{
            type: Input
        }], loadingOverlay: [{
            type: ContentChild,
            args: [NglDatatableLoadingOverlay]
        }], noRowsOverlay: [{
            type: ContentChild,
            args: [NglDatatableNoRowsOverlay]
        }], columns: [{
            type: ContentChildren,
            args: [NglDatatableColumn]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglInternalDatatableHeadCell, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'th[nglDatatableHead]',
                template: "<a class=\"slds-th__action slds-text-link_reset\" *ngIf=\"sortable; else baseTpl\" (click)=\"sortChange()\" role=\"button\" tabindex=\"0\"><span class=\"slds-assistive-text\">Sort by:</span>\n  <div class=\"slds-grid slds-grid_vertical-align-center slds-has-flexi-truncate\"><span class=\"slds-truncate\" [attr.title]=\"attrTitle\" [nglInternalOutlet]=\"header\"></span><span class=\"slds-icon_container slds-icon-utility-arrowdown\">\n      <svg class=\"slds-icon slds-icon-text-default slds-is-sortable__icon\" nglIconName=\"arrowdown\"></svg></span></div></a>\n<ng-template #baseTpl>\n  <div class=\"slds-truncate\" [attr.title]=\"attrTitle\" [nglInternalOutlet]=\"header\"></div>\n</ng-template>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-is-sorted_asc]': `sortOrder === 'asc'`,
                    '[class.slds-is-sorted_desc]': `sortOrder === 'desc'`,
                    '[class.slds-is-sorted]': `!!sortOrder`
                }
            }]
    }], function () { return []; }, { sort: [{
            type: Output
        }], ariaSort: [{
            type: HostBinding,
            args: ['attr.aria-sort']
        }], heading: [{
            type: Input
        }], headingTpl: [{
            type: Input
        }], sortable: [{
            type: HostBinding,
            args: ['class.slds-is-sortable']
        }, {
            type: Input
        }], sortOrder: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglInternalDatatableCell, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'td[nglDatatatableCell_]',
                template: "\n<div [class.slds-truncate]=\"column.truncate\" [attr.title]=\"column.truncate ? value : null\">\n  <ng-container *ngIf=\"column.cellTpl; else stringTpl\" [ngTemplateOutlet]=\"column.cellTpl.templateRef\" [ngTemplateOutletContext]=\"context\"></ng-container>\n  <ng-template #stringTpl>{{ value }}</ng-template>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { dataLabel: [{
            type: HostBinding,
            args: ['attr.data-label']
        }], row: [{
            type: Input
        }], column: [{
            type: Input
        }], index: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDatatablesModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_DATATABLE_DIRECTIVES, NglInternalDatatableHeadCell, NglInternalDatatableCell],
                exports: [NGL_DATATABLE_DIRECTIVES],
                imports: [CommonModule, NglIconsModule, NglInternalOutletModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglDatatablesModule, { declarations: function () { return [NglDatatable, NglDatatableColumn, NglDatatableCell, NglDatatableHeadingTemplate, NglDatatableLoadingOverlay, NglDatatableNoRowsOverlay, NglInternalDatatableHeadCell, NglInternalDatatableCell]; }, imports: function () { return [CommonModule, NglIconsModule, NglInternalOutletModule]; }, exports: function () { return [NglDatatable, NglDatatableColumn, NglDatatableCell, NglDatatableHeadingTemplate, NglDatatableLoadingOverlay, NglDatatableNoRowsOverlay]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglClickOutsideDirective, [{
        type: Directive,
        args: [{
                selector: '[nglClickOutside]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.ElementRef }]; }, { clickOutside: [{
            type: Output,
            args: ['nglClickOutside']
        }], ignore: [{
            type: Input,
            args: ['nglClickOutsideIgnore']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglClickOutsideModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: DIRECTIVES$5,
                exports: DIRECTIVES$5
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglClickOutsideModule, { declarations: function () { return [NglClickOutsideDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglClickOutsideDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDateAdapter, [{
        type: Injectable
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDatepickerInput, [{
        type: Component,
        args: [{
                selector: 'ngl-datepicker-input',
                template: "\n<label class=\"slds-form-element__label\" *ngIf=\"label\" [attr.for]=\"uid\" [nglInternalOutlet]=\"label\"></label>\n<div class=\"slds-form-element__control slds-input-has-icon slds-input-has-icon_right\" #formEl cdkOverlayOrigin #overlayOrigin=\"cdkOverlayOrigin\">\n  <ng-content></ng-content>\n  <button class=\"slds-button slds-button_icon slds-input__icon slds-input__icon_right\" type=\"button\" [title]=\"selectDateLabel\" [disabled]=\"disabled\" (click)=\"onTriggerClick('button')\">\n    <svg class=\"slds-button__icon\" nglIconName=\"utility:event\"></svg><span class=\"slds-assistive-text\">{{ selectDateLabel }}</span>\n  </button>\n</div>\n<ng-template cdkConnectedOverlay #cdkOverlay=\"cdkConnectedOverlay\" [cdkConnectedOverlayPositions]=\"overlayPositions\" [cdkConnectedOverlayOrigin]=\"overlayOrigin\" [cdkConnectedOverlayOpen]=\"open\" (nglOverlayScrolledOutsideView)=\"closeCalendar(false)\" (attach)=\"onAttach()\" (detach)=\"onDetach()\">\n  <ngl-datepicker class=\"slds-dropdown\" [attr.aria-hidden]=\"!open\" [date]=\"date\" [monthNames]=\"monthNames\" [dayNamesShort]=\"dayNamesShort\" [dayNamesLong]=\"dayNamesLong\" [firstDayOfWeek]=\"firstDayOfWeek\" [showToday]=\"showToday\" [min]=\"min\" [max]=\"max\" [relativeYearFrom]=\"relativeYearFrom\" [relativeYearTo]=\"relativeYearTo\" [todayLabel]=\"todayLabel\" [previousMonthLabel]=\"previousMonthLabel\" [nextMonthLabel]=\"nextMonthLabel\" [dateDisabled]=\"dateDisabled\" (dateChange)=\"pickerSelection($event)\" (nglClickOutside)=\"closeCalendar(false)\" [nglClickOutsideIgnore]=\"formEl\"></ngl-datepicker>\n</ng-template>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [NGL_DATEPICKER_INPUT_VALUE_ACCESSOR, NGL_DATEPICKER_INPUT_VALIDATOR, HostService]
            }]
    }], function () { return [{ type: NglDatepickerConfig, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NGL_DATEPICKER_CONFIG]
            }] }, { type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }, { type: HostService }, { type: ɵngcc0.NgZone }, { type: ɵngcc2.FocusTrapFactory }, { type: NglDateAdapter }]; }, { valueChange: [{
            type: Output
        }], selectDateLabel: [{
            type: Input
        }], dateDisabled: [{
            type: Input
        }], format: [{
            type: Input
        }], delimiter: [{
            type: Input
        }], monthNames: [{
            type: Input
        }], dayNamesShort: [{
            type: Input
        }], dayNamesLong: [{
            type: Input
        }], firstDayOfWeek: [{
            type: Input
        }], showToday: [{
            type: Input
        }], relativeYearFrom: [{
            type: Input
        }], relativeYearTo: [{
            type: Input
        }], openOnInputClick: [{
            type: Input
        }], todayLabel: [{
            type: Input
        }], previousMonthLabel: [{
            type: Input
        }], nextMonthLabel: [{
            type: Input
        }], patternPlaceholder: [{
            type: Input
        }], value: [{
            type: Input
        }], disabled: [{
            type: Input
        }], label: [{
            type: Input
        }], dropdownAlign: [{
            type: Input
        }], cdkOverlay: [{
            type: ViewChild,
            args: ['cdkOverlay']
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDay, [{
        type: Directive,
        args: [{
                selector: 'td[nglDay]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], date: [{
            type: Input,
            args: ['nglDay']
        }], nglDayDisabled: [{
            type: HostBinding,
            args: ['class.slds-disabled-text']
        }, {
            type: HostBinding,
            args: ['attr.aria-disabled']
        }, {
            type: Input
        }], nglDaySelected: [{
            type: HostBinding,
            args: ['class.slds-is-selected']
        }, {
            type: HostBinding,
            args: ['attr.aria-selected']
        }, {
            type: Input
        }], isActive: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDatepickerMonth, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: '[nglDatepickerMonth]',
                template: "\n<tr *ngFor=\"let week of weeks; trackBy:indexTrackBy\">\n  <td *ngFor=\"let date of week; trackBy:dateTrackBy\" [class.slds-is-today]=\"date.today\" [isActive]=\"date.active\" [nglDay]=\"date\" [nglDaySelected]=\"date.selected\" [nglDayDisabled]=\"date.disabled\" (click)=\"onSelect(date)\" role=\"gridcell\"><span class=\"slds-day\">{{ date.day }}</span></td>\n</tr>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, { dateDisabled: [{
            type: Input
        }], selectDate: [{
            type: Output
        }], selected: [{
            type: Input
        }], year: [{
            type: Input
        }], month: [{
            type: Input
        }], day: [{
            type: Input
        }], firstDayOfWeek: [{
            type: Input
        }], minDate: [{
            type: Input
        }], maxDate: [{
            type: Input
        }], days: [{
            type: ViewChildren,
            args: [NglDay]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDatepicker, [{
        type: Component,
        args: [{
                selector: 'ngl-datepicker',
                template: "\n<div class=\"slds-datepicker__filter slds-grid\">\n  <div class=\"slds-datepicker__filter_month slds-grid slds-grid_align-spread slds-grow\">\n    <div class=\"slds-align-middle\">\n      <button class=\"slds-button slds-button_icon-container\" type=\"button\" (click)=\"moveMonth(-1)\" [disabled]=\"previousDisabled()\" [title]=\"previousMonthLabel\">\n        <svg class=\"slds-button__icon\" nglIconName=\"left\"></svg><span class=\"slds-assistive-text\">{{ previousMonthLabel }}</span>\n      </button>\n    </div>\n    <h2 class=\"slds-align-middle\" [id]=\"uid + '_month'\" aria-live=\"assertive\" aria-atomic=\"true\">{{ monthLabel }}</h2>\n    <div class=\"slds-align-middle\">\n      <button class=\"slds-button slds-button_icon-container\" type=\"button\" (click)=\"moveMonth(1)\" [disabled]=\"nextDisabled()\" [title]=\"nextMonthLabel\">\n        <svg class=\"slds-button__icon\" nglIconName=\"right\"></svg><span class=\"slds-assistive-text\">{{ nextMonthLabel }}</span>\n      </button>\n    </div>\n  </div>\n  <ngl-date-year class=\"slds-shrink-none\" [year]=\"current.year\" [from]=\"minDate\" [to]=\"maxDate\" (yearChange)=\"moveYear($event)\"></ngl-date-year>\n</div>\n<table class=\"datepicker__month\" role=\"grid\" [attr.aria-labelledby]=\"uid + '_month'\" (keydown)=\"keyboardHandler($event)\">\n  <thead>\n    <tr nglWeekdays [firstDayOfWeek]=\"firstDayOfWeek\" [dayNamesShort]=\"dayNamesShort\" [dayNamesLong]=\"dayNamesLong\"></tr>\n  </thead>\n  <tbody *ngIf=\"current\" nglDatepickerMonth [year]=\"current.year\" [month]=\"current.month\" [day]=\"current.day\" [selected]=\"_date\" [firstDayOfWeek]=\"firstDayOfWeek\" [minDate]=\"minDate\" [maxDate]=\"maxDate\" [dateDisabled]=\"dateDisabled\" (selectDate)=\"select($event)\"></tbody>\n</table>\n<button class=\"slds-button slds-align_absolute-center slds-text-link\" *ngIf=\"showToday\" (click)=\"selectToday()\">{{ todayLabel }}</button>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-datepicker]': 'true'
                },
                styles: [`:host { display: block; }`]
            }]
    }], function () { return [{ type: NglDatepickerInput, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NglDatepickerInput]
            }] }, { type: NglDatepickerConfig, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NGL_DATEPICKER_CONFIG]
            }] }, { type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }, { type: ɵngcc0.ElementRef }]; }, { dateDisabled: [{
            type: Input
        }], dateChange: [{
            type: Output
        }], monthNames: [{
            type: Input
        }], dayNamesShort: [{
            type: Input
        }], dayNamesLong: [{
            type: Input
        }], firstDayOfWeek: [{
            type: Input
        }], showToday: [{
            type: Input
        }], relativeYearFrom: [{
            type: Input
        }], relativeYearTo: [{
            type: Input
        }], todayLabel: [{
            type: Input
        }], previousMonthLabel: [{
            type: Input
        }], nextMonthLabel: [{
            type: Input
        }], date: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], monthView: [{
            type: ViewChild,
            args: [NglDatepickerMonth]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDatepickerInputDirective, [{
        type: Directive,
        args: [{
                selector: 'input[nglDatepickerInput]',
                exportAs: 'nglDatepickerInput'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: NglDatepickerInput }]; }, { onClick: [{
            type: HostListener,
            args: ['click']
        }], onKeydown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], onInput: [{
            type: HostListener,
            args: ['input']
        }], onBlur: [{
            type: HostListener,
            args: ['blur']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDatepickerWeekdays, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'tr[nglWeekdays]',
                template: "\n<th *ngFor=\"let day of weekdays\" [id]=\"day.id\" scope=\"col\"><abbr [title]=\"day.title\">{{day.label}}</abbr></th>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { dayNamesShort: [{
            type: Input
        }], dayNamesLong: [{
            type: Input
        }], firstDayOfWeek: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDatepickerYear, [{
        type: Component,
        args: [{
                selector: 'ngl-date-year',
                template: "\n<label class=\"slds-assistive-text\" [attr.for]=\"uid\">Pick a Year</label>\n<div class=\"slds-select_container\">\n  <select class=\"slds-select\" [id]=\"uid\" [ngModel]=\"year\" (ngModelChange)=\"change($event)\">\n    <option *ngFor=\"let yr of range\" [value]=\"yr\">{{yr}}</option>\n  </select>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { yearChange: [{
            type: Output
        }], from: [{
            type: Input
        }], to: [{
            type: Input
        }], year: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDatepickersModule, [{
        type: NgModule,
        args: [{
                declarations: [...EXPORTS, NglDay, NglDatepickerWeekdays, NglDatepickerYear, NglDatepickerMonth],
                exports: EXPORTS,
                imports: [
                    CommonModule,
                    FormsModule,
                    NglIconsModule,
                    NglInternalOutletModule,
                    OverlayModule,
                    NglClickOutsideModule,
                    NglOverlayModule,
                ],
                providers: [NglDateAdapter]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglDatepickersModule, { declarations: function () { return [NglDatepicker, NglDatepickerInput, NglDatepickerInputDirective, NglDay, NglDatepickerWeekdays, NglDatepickerYear, NglDatepickerMonth]; }, imports: function () { return [CommonModule,
        FormsModule, NglIconsModule, NglInternalOutletModule, OverlayModule, NglClickOutsideModule, NglOverlayModule]; }, exports: function () { return [NglDatepicker, NglDatepickerInput, NglDatepickerInputDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BaseDynamicIconComponent, [{
        type: Directive
    }], null, { alternativeText: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDynamicIcon, [{
        type: Component,
        args: [{
                selector: 'ngl-dynamic-icon',
                template: "\n<ng-container [ngSwitch]=\"type\">\n  <ngl-dynamic-icon-ellie *ngSwitchCase=\"'ellie'\" [alternativeText]=\"alternativeText\"></ngl-dynamic-icon-ellie>\n  <ngl-dynamic-icon-eq *ngSwitchCase=\"'eq'\" [option]=\"option\" [alternativeText]=\"alternativeText\"></ngl-dynamic-icon-eq>\n  <ngl-dynamic-icon-score *ngSwitchCase=\"'score'\" [option]=\"option\" [alternativeText]=\"alternativeText\"></ngl-dynamic-icon-score>\n  <ngl-dynamic-icon-waffle *ngSwitchCase=\"'waffle'\" [alternativeText]=\"alternativeText\"></ngl-dynamic-icon-waffle>\n</ng-container>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { type: [{
            type: Input
        }], option: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDynamicIconEllie, [{
        type: Component,
        args: [{
                selector: 'ngl-dynamic-icon-ellie',
                template: "<span class=\"slds-icon-ellie slds-is-animated\">\n  <svg viewbox=\"0 0 280 14\" aria-hidden=\"true\">\n    <circle cx=\"7\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"7\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"21\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"21\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"35\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"35\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"49\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"49\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"63\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"63\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"77\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"77\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"91\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"91\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"105\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"105\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"119\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"119\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"133\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"133\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"147\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"147\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"161\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"161\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"175\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"175\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"189\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"189\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"203\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"203\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"217\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"217\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"231\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"231\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"245\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"245\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"259\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"259\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"273\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"273\" cy=\"7\" r=\"3\"></circle>\n  </svg><span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{alternativeText}}</span></span>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDynamicIconEq, [{
        type: Component,
        args: [{
                selector: 'ngl-dynamic-icon-eq',
                template: "\n<div class=\"slds-icon-eq\" [class.slds-is-animated]=\"isAnimated()\">\n  <div class=\"slds-icon-eq__bar\"></div>\n  <div class=\"slds-icon-eq__bar\"></div>\n  <div class=\"slds-icon-eq__bar\"></div><span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{alternativeText}}</span>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { option: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDynamicIconScore, [{
        type: Component,
        args: [{
                selector: 'ngl-dynamic-icon-score',
                template: "<span class=\"slds-icon-score\" [attr.data-slds-state]=\"option\">\n  <svg class=\"slds-icon-score__positive\" viewBox=\"0 0 5 5\" aria-hidden=\"true\">\n    <circle cx=\"50%\" cy=\"50%\" r=\"1.875\"></circle>\n  </svg>\n  <svg class=\"slds-icon-score__negative\" viewBox=\"0 0 5 5\" aria-hidden=\"true\">\n    <circle cx=\"50%\" cy=\"50%\" r=\"1.875\"></circle>\n  </svg><span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{alternativeText}}</span></span>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { option: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDynamicIconWaffle, [{
        type: Component,
        args: [{
                selector: 'ngl-dynamic-icon-waffle',
                template: "\n<button class=\"slds-button slds-icon-waffle_container\" type=\"button\"><span class=\"slds-icon-waffle\"><span class=\"slds-r1\"></span><span class=\"slds-r2\"></span><span class=\"slds-r3\"></span><span class=\"slds-r4\"></span><span class=\"slds-r5\"></span><span class=\"slds-r6\"></span><span class=\"slds-r7\"></span><span class=\"slds-r8\"></span><span class=\"slds-r9\"></span></span><span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{alternativeText}}</span></button>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDynamicIconsModule, [{
        type: NgModule,
        args: [{
                declarations: NGL_DYNAMIC_ICON_DIRECTIVES,
                exports: NGL_DYNAMIC_ICON_DIRECTIVES,
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglDynamicIconsModule, { declarations: function () { return [NglDynamicIcon, NglDynamicIconEllie, NglDynamicIconEq, NglDynamicIconScore, NglDynamicIconWaffle]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglDynamicIcon, NglDynamicIconEllie, NglDynamicIconEq, NglDynamicIconScore, NglDynamicIconWaffle]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglFile, [{
        type: Component,
        args: [{
                selector: 'ngl-file',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "\n<figure>\n  <ng-content></ng-content>\n  <figcaption class=\"slds-file__title slds-file__title_card\" *ngIf=\"text\">\n    <div class=\"slds-media slds-media_small slds-media_center\">\n      <div class=\"slds-media__figure slds-line-height_reset\" *ngIf=\"iconName\">\n        <ngl-icon [iconName]=\"iconName\"></ngl-icon>\n      </div>\n      <div class=\"slds-media__body\"><span class=\"slds-file__text slds-truncate\" [title]=\"text\" [nglInternalOutlet]=\"text\"></span></div>\n    </div>\n  </figcaption>\n</figure>"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { text: [{
            type: HostBinding,
            args: ['class.slds-has-title']
        }, {
            type: Input
        }], iconName: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglFileCrop, [{
        type: Directive,
        args: [{
                selector: '[nglFileCrop]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { nglFileCrop: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglFilesModule, [{
        type: NgModule,
        args: [{
                declarations: [NglFile, NglFileCrop],
                exports: [NglFile, NglFileCrop],
                imports: [CommonModule, NglIconsModule, NglInternalOutletModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglFilesModule, { declarations: function () { return [NglFile, NglFileCrop]; }, imports: function () { return [CommonModule, NglIconsModule, NglInternalOutletModule]; }, exports: function () { return [NglFile, NglFileCrop]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglFileUpload, [{
        type: Component,
        args: [{
                selector: 'ngl-file-upload',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "<span class=\"slds-form-element__label\" *ngIf=\"label\" [id]=\"uid + '-primary-label'\" [nglInternalOutlet]=\"label\"></span>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-file-selector slds-file-selector_files\">\n    <div class=\"slds-file-selector__dropzone\" [class.slds-has-drag-over]=\"isDragOver\" (dragover)=\"onDropZone($event)\" (dragleave)=\"onDropZone($event)\" (drop)=\"onDropZone($event)\">\n      <input class=\"slds-file-selector__input slds-assistive-text\" type=\"file\" [id]=\"uid\" [attr.accept]=\"accept\" [disabled]=\"disabled\" [multiple]=\"maxFiles !== 1\" [attr.aria-describedby]=\"error ? uid + '-error' : null\" [attr.aria-labelledby]=\"uid + '-primary-label ' + uid + '-secondary-label'\" (change)=\"onInputChange($event.target.files)\">\n      <label class=\"slds-file-selector__body\" [attr.for]=\"uid\" [id]=\"uid + '-secondary-label'\"><span class=\"slds-file-selector__button slds-button slds-button_neutral\">\n          <svg class=\"slds-button__icon slds-button__icon_left\" nglIconName=\"utility:upload\"></svg>{{ uploadButtonLabel }}</span><span class=\"slds-file-selector__text slds-medium-show\">{{ dropZoneLabel }}</span></label>\n    </div>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"error\" [id]=\"uid + '-error'\" [nglInternalOutlet]=\"error\"></div>",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: NglFileUpload,
                        multi: true
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: NglFileUpload,
                        multi: true
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { accept: [{
            type: Input
        }], disabled: [{
            type: Input
        }], maxFiles: [{
            type: Input
        }], maxFilesize: [{
            type: Input
        }], error: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }, {
            type: Input
        }], uploadButtonLabel: [{
            type: Input
        }], dropZoneLabel: [{
            type: Input
        }], label: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglFileUploadModule, [{
        type: NgModule,
        args: [{
                declarations: [NglFileUpload],
                exports: [NglFileUpload],
                imports: [CommonModule, NglIconsModule, NglInternalOutletModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglFileUploadModule, { declarations: function () { return [NglFileUpload]; }, imports: function () { return [CommonModule, NglIconsModule, NglInternalOutletModule]; }, exports: function () { return [NglFileUpload]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglInputElement, [{
        type: Directive,
        args: [{
                selector: 'input[ngl]:not([type=checkbox]):not([type=radio])',
                host: {
                    '[class.slds-input]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { required: [{
            type: Input
        }], describedBy: [{
            type: HostBinding,
            args: ['attr.aria-describedby']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglInput, [{
        type: Component,
        args: [{
                selector: 'ngl-input,[ngl-input]',
                template: "\n<label [nglFormLabel]=\"label\" [attr.for]=\"_uid\" [required]=\"required\"></label>\n<ngl-form-help *ngIf=\"fieldLevelHelpTooltip\" [content]=\"fieldLevelHelpTooltip\"></ngl-form-help>\n<div class=\"slds-form-element__control\">\n  <ng-content></ng-content>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"hasError\" [id]=\"errorId\" [nglInternalOutlet]=\"error\"></div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-form-element]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { hasError: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }], input: [{
            type: ContentChild,
            args: [NglInputElement, { static: true }]
        }], label: [{
            type: Input
        }], error: [{
            type: Input
        }], stacked: [{
            type: Input
        }], fieldLevelHelpTooltip: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglInputModule, [{
        type: NgModule,
        args: [{
                declarations: DIRECTIVES$4,
                exports: DIRECTIVES$4,
                imports: [CommonModule, NglFormsModule, NglInternalOutletModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglInputModule, { declarations: function () { return [NglInput, NglInputElement]; }, imports: function () { return [CommonModule, NglFormsModule, NglInternalOutletModule]; }, exports: function () { return [NglInput, NglInputElement]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDropdownItem, [{
        type: Directive,
        args: [{
                selector: '[nglDropdownItem]',
                host: {
                    'tabindex': '0'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { onFocus: [{
            type: HostListener,
            args: ['focus']
        }], onBlur: [{
            type: HostListener,
            args: ['blur']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDropdown, [{
        type: Directive,
        args: [{
                selector: '[nglDropdown]',
                host: {
                    '[class.slds-dropdown-trigger]': 'true',
                    '[class.slds-dropdown-trigger_click]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { handlePageEvents: [{
            type: Input
        }], isOpenChange: [{
            type: Output,
            args: ['openChange']
        }], isOpen: [{
            type: Input,
            args: ['open']
        }], onKeydownClose: [{
            type: HostListener,
            args: ['keydown.esc', ['"esc"']]
        }, {
            type: HostListener,
            args: ['keydown.tab', ['"tab"']]
        }], onKeydownFocusNext: [{
            type: HostListener,
            args: ['keydown.arrowdown', ['$event', '"next"']]
        }, {
            type: HostListener,
            args: ['keydown.arrowup', ['$event', '"previous"']]
        }], items: [{
            type: ContentChildren,
            args: [NglDropdownItem, { descendants: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglDropdownTrigger, [{
        type: Directive,
        args: [{
                selector: '[nglDropdownTrigger]',
                host: {
                    'aria-haspopup': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NglDropdown }]; }, { toggleOpen: [{
            type: HostListener,
            args: ['click']
        }], onKeyDownOpen: [{
            type: HostListener,
            args: ['keydown.arrowdown', ['$event']]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglMenusModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_DROPDOWN_DIRECTIVES],
                exports: [NGL_DROPDOWN_DIRECTIVES],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglMenusModule, { declarations: function () { return [NglDropdown, NglDropdownTrigger, NglDropdownItem]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglDropdown, NglDropdownTrigger, NglDropdownItem]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglModalHeaderTemplate, [{
        type: Directive,
        args: [{ selector: '[nglModalHeader]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglModalTaglineTemplate, [{
        type: Directive,
        args: [{ selector: '[nglModalTagline]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglModalFooterTemplate, [{
        type: Directive,
        args: [{ selector: '[nglModalFooter]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglModal, [{
        type: Component,
        args: [{
                selector: 'ngl-modal',
                template: "\n<section class=\"slds-modal\" [ngClass]=\"modalClass()\" [attr.aria-hidden]=\"!open\" [attr.aria-labelledby]=\"headingId\" [attr.aria-describedby]=\"contentId\" aria-modal=\"true\" [attr.role]=\"prompt ? 'alertdialog' : 'dialog'\" tabindex=\"-1\">\n  <div class=\"slds-modal__container\">\n    <header class=\"slds-modal__header\" [ngClass]=\"modalHeaderClass()\">\n      <button class=\"slds-button slds-button_icon slds-button_icon-inverse slds-modal__close\" *ngIf=\"showClose\" type=\"button\" (click)=\"close()\">\n        <svg class=\"slds-button__icon slds-button__icon_large\" nglIconName=\"utility:close\"></svg><span class=\"slds-assistive-text\" *ngIf=\"closeButtonAssistiveText\">{{closeButtonAssistiveText}}</span>\n      </button>\n      <ng-template #localHeader>\n        <h2 class=\"slds-text-heading_medium slds-hyphenate\" *ngIf=\"header\" [id]=\"headingId\">{{header}}</h2>\n      </ng-template>\n      <ng-template *ngIf=\"headerTpl; else localHeader\" [ngTemplateOutlet]=\"headerTpl.templateRef\" [ngTemplateOutletContext]=\"{id: headingId}\"></ng-template>\n      <p class=\"slds-m-top_x-small\" *ngIf=\"hasHeader &amp;&amp; taglineTpl\">\n        <ng-template [ngTemplateOutlet]=\"taglineTpl.templateRef\"></ng-template>\n      </p>\n    </header>\n    <div class=\"slds-modal__content\" [id]=\"contentId\" cdkScrollable>\n      <ng-content></ng-content>\n    </div>\n    <footer class=\"slds-modal__footer\" *ngIf=\"footer\" [ngClass]=\"modalFooterClass()\">\n      <ng-template [ngTemplateOutlet]=\"footer.templateRef\"></ng-template>\n    </footer>\n  </div>\n</section>\n<div class=\"slds-backdrop\" [class.slds-backdrop_open]=\"open\"></div>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc2.FocusTrapFactory }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc3.Overlay }, { type: ɵngcc0.ElementRef }]; }, { header: [{
            type: Input
        }], directional: [{
            type: Input
        }], open: [{
            type: Input
        }], closeButtonAssistiveText: [{
            type: Input
        }], openChange: [{
            type: Output
        }], dismissOnClickOutside: [{
            type: Input
        }], close: [{
            type: HostListener,
            args: ['keydown.esc', ['$event']]
        }], clickOutside: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], size: [{
            type: Input
        }], headerTpl: [{
            type: ContentChild,
            args: [NglModalHeaderTemplate]
        }], taglineTpl: [{
            type: ContentChild,
            args: [NglModalTaglineTemplate]
        }], footer: [{
            type: ContentChild,
            args: [NglModalFooterTemplate]
        }], prompt: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglModalsModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_MODAL_DIRECTIVES],
                exports: [NGL_MODAL_DIRECTIVES],
                imports: [CommonModule, A11yModule, OverlayModule, NglIconsModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglModalsModule, { declarations: function () { return [NglModal, NglModalFooterTemplate, NglModalHeaderTemplate, NglModalTaglineTemplate]; }, imports: function () { return [CommonModule, A11yModule, OverlayModule, NglIconsModule]; }, exports: function () { return [NglModal, NglModalFooterTemplate, NglModalHeaderTemplate, NglModalTaglineTemplate]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglToast, [{
        type: Component,
        args: [{
                selector: 'ngl-toast',
                template: "<span class=\"slds-assistive-text\">{{assistiveText || variant}}</span>\n<ngl-icon class=\"slds-m-right_small slds-no-flex slds-align-top\" *ngIf=\"iconName\" [iconName]=\"iconName\" size=\"small\" variant=\"\"></ngl-icon>\n<div class=\"slds-notify__content\">\n  <ng-content></ng-content>\n</div>\n<button class=\"slds-button slds-button_icon slds-notify__close slds-button_icon-inverse\" *ngIf=\"dismissible\" type=\"button\" (click)=\"close('button', $event)\">\n  <svg class=\"slds-button__icon slds-button__icon_large\" nglIconName=\"utility:close\"></svg><span class=\"slds-assistive-text\" *ngIf=\"closeButtonAssistiveText\">{{closeButtonAssistiveText}}</span>\n</button>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'nglToast'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglToastClose, [{
        type: Directive,
        args: [{
                selector: 'ngl-toast[close],ngl-toast[nglClose]'
            }]
    }], function () { return [{ type: NglToast }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglToastModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_TOAST_DIRECTIVES],
                exports: [NGL_TOAST_DIRECTIVES],
                imports: [CommonModule, NglIconsModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglToastModule, { declarations: function () { return [NglToast, NglToastClose]; }, imports: function () { return [CommonModule, NglIconsModule]; }, exports: function () { return [NglToast, NglToastClose]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglPagination, [{
        type: Component,
        args: [{
                selector: 'ngl-pagination',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "\n<div class=\"slds-button-group\" role=\"group\">\n  <button class=\"slds-button slds-button_neutral\" *ngIf=\"boundaryLinks\" [disabled]=\"!hasPrevious()\" (click)=\"goto(1)\">{{firstText}}</button>\n  <button class=\"slds-button slds-button_neutral\" [disabled]=\"!hasPrevious()\" (click)=\"goto(current - 1)\">{{previousText}}</button>\n  <button class=\"slds-button\" *ngFor=\"let page of pages; trackBy:pageTrackBy\" [ngClass]=\"'slds-button_' + (page.number === current ? 'brand' : 'neutral')\" (click)=\"goto(page.number)\" [disabled]=\"page.disabled\">{{page.number}}</button>\n  <button class=\"slds-button slds-button_neutral\" [disabled]=\"!hasNext()\" (click)=\"goto(current + 1)\">{{nextText}}</button>\n  <button class=\"slds-button slds-button_neutral\" *ngIf=\"boundaryLinks\" [disabled]=\"!hasNext()\" (click)=\"goto(totalPages)\">{{lastText}}</button>\n</div>",
                exportAs: 'nglPagination'
            }]
    }], function () { return []; }, { pageChange: [{
            type: Output
        }], perPage: [{
            type: Input
        }], limit: [{
            type: Input
        }], boundaryNumbers: [{
            type: Input
        }], firstText: [{
            type: Input
        }], previousText: [{
            type: Input
        }], nextText: [{
            type: Input
        }], lastText: [{
            type: Input
        }], boundaryLinks: [{
            type: Input
        }], page: [{
            type: Input
        }], total: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglPaginationsModule, [{
        type: NgModule,
        args: [{
                declarations: [NglPagination],
                exports: [NglPagination],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglPaginationsModule, { declarations: function () { return [NglPagination]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglPagination]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglPick, [{
        type: Directive,
        args: [{
                selector: '[nglPick]'
            }]
    }], function () { return []; }, { nglPickChange: [{
            type: Output
        }], nglOptionDestroyed: [{
            type: Output
        }], isMultiple: [{
            type: Input,
            args: ['nglPickMultiple']
        }], setSelected: [{
            type: Input,
            args: ['nglPick']
        }], nglPickActiveClass: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglPickOption, [{
        type: Directive,
        args: [{
                selector: '[nglPickOption]',
                exportAs: 'nglPickOption',
                host: {
                    'role': 'button'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: NglPick }]; }, { setValue: [{
            type: Input,
            args: ['nglPickOption']
        }], pick: [{
            type: HostListener,
            args: ['click']
        }, {
            type: HostListener,
            args: ['keydown.Space', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.Enter', ['$event']]
        }], nglPickActiveClass: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglPickModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_PICK_DIRECTIVES],
                exports: [NGL_PICK_DIRECTIVES],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglPickModule, { declarations: function () { return [NglPick, NglPickOption]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglPick, NglPickOption]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglPill, [{
        type: Component,
        args: [{
                selector: 'ngl-pill',
                template: "<span class=\"slds-pill__icon_container\" *ngIf=\"pillIcon\">\n  <ng-container *ngIf=\"isTemplateRef(pillIcon); else defaultTpl\" [ngTemplateOutlet]=\"pillIcon\"></ng-container>\n  <ng-template #defaultTpl>\n    <ngl-icon *ngIf=\"icon; else avatarTpl\" [iconName]=\"icon\"></ngl-icon>\n    <ng-template #avatarTpl>\n      <ngl-avatar [src]=\"avatar\" variant=\"circle\"></ngl-avatar>\n    </ng-template>\n  </ng-template></span>\n<ng-container *ngIf=\"linked; else unlinked\">\n  <ng-content select=\"a\"></ng-content>\n</ng-container>\n<ng-template #unlinked><span class=\"slds-pill__label\">\n    <ng-content></ng-content></span></ng-template>\n<button class=\"slds-button slds-button_icon slds-pill__remove\" *ngIf=\"canRemove &amp;&amp; removable\" type=\"button\" [title]=\"removeTitle\" (click)=\"onRemove($event)\">\n  <svg class=\"slds-button__icon\" nglIconName=\"close\"></svg><span class=\"slds-assistive-text\" *ngIf=\"removeTitle\">{{removeTitle}}</span>\n</button>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-pill]': 'true'
                }
            }]
    }], function () { return []; }, { hasError: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.slds-has-error']
        }], removable: [{
            type: Input
        }], removeTitle: [{
            type: Input
        }], remove: [{
            type: Output
        }], linked: [{
            type: HostBinding,
            args: ['class.slds-pill_link']
        }], icon: [{
            type: Input
        }], avatar: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglPillLink, [{
        type: Component,
        args: [{
                //  tslint:disable-next-line:component-selector
                selector: 'a[nglPillAction]',
                template: "<span class=\"slds-pill__label\">\n  <ng-content></ng-content></span>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-pill__action]': 'true'
                }
            }]
    }], function () { return [{ type: NglPill }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglPillsModule, [{
        type: NgModule,
        args: [{
                declarations: NGL_PILL_DIRECTIVES,
                exports: NGL_PILL_DIRECTIVES,
                imports: [CommonModule, NglIconsModule, NglAvatarModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglPillsModule, { declarations: function () { return [NglPill, NglPillLink]; }, imports: function () { return [CommonModule, NglIconsModule, NglAvatarModule]; }, exports: function () { return [NglPill, NglPillLink]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglProgressBar, [{
        type: Component,
        args: [{
                selector: 'ngl-progress-bar',
                template: "<span class=\"slds-progress-bar__value\" [style.width.%]=\"value\"><span class=\"slds-assistive-text\">Progress: {{value}}%</span></span>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: HostService }]; }, { value: [{
            type: Input
        }], size: [{
            type: Input
        }], variant: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglProgressBarModule, [{
        type: NgModule,
        args: [{
                declarations: [NglProgressBar],
                exports: [NglProgressBar],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglProgressBarModule, { declarations: function () { return [NglProgressBar]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglProgressBar]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglRadioGroup, [{
        type: Component,
        args: [{
                selector: 'ngl-radio-group,[ngl-radio-group]',
                template: "\n<legend class=\"slds-form-element__legend slds-form-element__label\"><abbr class=\"slds-required\" *ngIf=\"required\" title=\"required\">*</abbr><span [nglInternalOutlet]=\"label\"></span></legend>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-radio_button-group\" *ngIf=\"type === 'button'; else contentTpl\">\n    <ng-container *ngTemplateOutlet=\"contentTpl\"></ng-container>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"error\" [id]=\"errorId\">{{error}}</div>\n<ng-template #contentTpl>\n  <ng-content></ng-content>\n</ng-template>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-form-element]': 'true'
                }
            }]
    }], function () { return []; }, { error: [{
            type: Input
        }], type: [{
            type: Input
        }], hasError: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }], label: [{
            type: Input
        }], required: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglRadioInput, [{
        type: Directive,
        args: [{
                selector: 'input[ngl][type=radio]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { name: [{
            type: HostBinding,
            args: ['attr.name']
        }], describedBy: [{
            type: HostBinding,
            args: ['attr.aria-describedby']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglRadioOption, [{
        type: Component,
        args: [{
                selector: 'ngl-radio-option',
                template: "\n<ng-content></ng-content>\n<label class=\"slds-radio__label\" *ngIf=\"type === 'list'\" [attr.for]=\"input.id\"><span class=\"slds-radio_faux\"></span><span class=\"slds-form-element__label\" [nglInternalOutlet]=\"label\"></span></label>\n<label class=\"slds-radio_button__label\" *ngIf=\"type === 'button'\" [attr.for]=\"input.id\"><span class=\"slds-radio_faux\" [nglInternalOutlet]=\"label\"></span></label>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NglRadioGroup }, { type: ɵngcc0.ChangeDetectorRef }]; }, { isTypeList: [{
            type: HostBinding,
            args: ['class.slds-radio']
        }], isTypeButton: [{
            type: HostBinding,
            args: ['class.slds-button']
        }, {
            type: HostBinding,
            args: ['class.slds-radio_button']
        }], label: [{
            type: Input
        }], input: [{
            type: ContentChild,
            args: [NglRadioInput, { static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglRadiosModule, [{
        type: NgModule,
        args: [{
                declarations: DIRECTIVES$3,
                exports: DIRECTIVES$3,
                imports: [CommonModule, NglInternalOutletModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglRadiosModule, { declarations: function () { return [NglRadioGroup, NglRadioOption, NglRadioInput]; }, imports: function () { return [CommonModule, NglInternalOutletModule]; }, exports: function () { return [NglRadioGroup, NglRadioOption, NglRadioInput]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglRatingIconTemplate, [{
        type: Directive,
        args: [{ selector: '[nglRatingIcon]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglRating, [{
        type: Component,
        args: [{
                selector: 'ngl-rating',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "\n<ng-template #t let-fill=\"fill\">\n  <svg class=\"slds-icon\" [nglIconName]=\"icon\" [ngClass]=\"size ? 'slds-icon_' + size : ''\" [style.fill]=\"fill === 100 ? colorOn : colorOff\"></svg>\n  <svg class=\"slds-icon\" *ngIf=\"fill &gt; 0 &amp;&amp; fill &lt; 100\" [nglIconName]=\"icon\" [ngClass]=\"size ? 'slds-icon_' + size : ''\" [style.fill]=\"colorOn\" style=\"position:absolute; bottom:0;\" [style.left.%]=\"fill - 100\" [xPos]=\"(100 - fill) + '%'\"></svg>\n</ng-template>\n<div class=\"slds-show_inline-block\" *ngFor=\"let r of range; let i = index\" (click)=\"update(r)\" (mouseenter)=\"enter(r)\" style=\"position: relative;\">\n  <ng-template [ngTemplateOutlet]=\"_template\" [ngTemplateOutletContext]=\"{$implicit: r &lt;= currentRate, index: i, fill: getFill(r)}\"></ng-template>\n</div>",
                host: {
                    'style': 'white-space: nowrap;',
                    'tabindex': '0',
                    'aria-valuemin': '0',
                    '[attr.aria-valuemax]': 'max'
                }
            }]
    }], function () { return [{ type: NglRatingConfig, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NGL_RATING_CONFIG]
            }] }]; }, { icon: [{
            type: Input
        }], readonly: [{
            type: Input,
            args: ['isReadonly']
        }], rateChange: [{
            type: Output
        }], hover: [{
            type: Output
        }], colorOn: [{
            type: Input
        }], colorOff: [{
            type: Input
        }], rate: [{
            type: Input
        }], max: [{
            type: Input
        }], reset: [{
            type: HostListener,
            args: ['mouseleave']
        }], 
    // Keyboard interactions
    keyboardIncrease: [{
            type: HostListener,
            args: ['keydown.ArrowUp', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.ArrowRight', ['$event']]
        }], keyboardDecrease: [{
            type: HostListener,
            args: ['keydown.ArrowDown', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.ArrowLeft', ['$event']]
        }], ariaValuenow: [{
            type: HostBinding,
            args: ['attr.aria-valuenow']
        }], size: [{
            type: Input
        }], defaultTemplate: [{
            type: ViewChild,
            args: ['t', { static: true }]
        }], iconTemplate: [{
            type: ContentChild,
            args: [NglRatingIconTemplate]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglRatingsModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, NglIconsModule],
                declarations: [...DIRECTIVES$2],
                exports: [...DIRECTIVES$2]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglRatingsModule, { declarations: function () { return [NglRating, NglRatingIconTemplate]; }, imports: function () { return [CommonModule, NglIconsModule]; }, exports: function () { return [NglRating, NglRatingIconTemplate]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglExpandableSection, [{
        type: Component,
        args: [{
                selector: 'ngl-expandable-section',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "\n<h3 class=\"slds-section__title\" [class.slds-theme_shade]=\"!collapsable\">\n  <button class=\"slds-button slds-section__title-action\" *ngIf=\"collapsable; else simple_title\" [attr.aria-controls]=\"uid\" [attr.aria-expanded]=\"expanded\" type=\"button\" (click)=\"toggle($event)\">\n    <svg class=\"slds-section__title-action-icon slds-button__icon slds-button__icon_left\" nglIconName=\"switch\"></svg><span class=\"slds-truncate\" [title]=\"title\">{{title}}</span>\n  </button>\n  <ng-template #simple_title><span class=\"slds-truncate slds-p-horizontal_small\" [title]=\"title\">{{title}}</span>\n  </ng-template>\n</h3>\n<div class=\"slds-section__content\" [attr.aria-hidden]=\"!expanded\" [attr.id]=\"uid\">\n  <ng-content></ng-content>\n</div>",
                host: {
                    '[class.slds-section]': 'true'
                }
            }]
    }], function () { return []; }, { collapsable: [{
            type: Input
        }], open: [{
            type: Input
        }], openChange: [{
            type: Output
        }], expanded: [{
            type: HostBinding,
            args: ['class.slds-is-open']
        }], title: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglSectionsModule, [{
        type: NgModule,
        args: [{
                declarations: [NglExpandableSection],
                exports: [NglExpandableSection],
                imports: [CommonModule, NglIconsModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglSectionsModule, { declarations: function () { return [NglExpandableSection]; }, imports: function () { return [CommonModule, NglIconsModule]; }, exports: function () { return [NglExpandableSection]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglSelectInput, [{
        type: Directive,
        args: [{
                selector: 'select[ngl]',
                host: {
                    '[class.slds-select]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { required: [{
            type: Input
        }], describedBy: [{
            type: HostBinding,
            args: ['attr.aria-describedby']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglSelect, [{
        type: Component,
        args: [{
                selector: 'ngl-select,[ngl-select]',
                template: "\n<label [nglFormLabel]=\"label\" [attr.for]=\"_uid\" [required]=\"required\"></label>\n<ngl-form-help *ngIf=\"fieldLevelHelpTooltip\" [content]=\"fieldLevelHelpTooltip\"></ngl-form-help>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-select_container\">\n    <ng-content></ng-content>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"hasError\" [id]=\"errorId\" [nglInternalOutlet]=\"error\"></div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-form-element]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { hasError: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }], input: [{
            type: ContentChild,
            args: [NglSelectInput, { static: true }]
        }], label: [{
            type: Input
        }], fieldLevelHelpTooltip: [{
            type: Input
        }], error: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglSelectModule, [{
        type: NgModule,
        args: [{
                declarations: DIRECTIVES$1,
                exports: DIRECTIVES$1,
                imports: [CommonModule, NglFormsModule, NglInternalOutletModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglSelectModule, { declarations: function () { return [NglSelect, NglSelectInput]; }, imports: function () { return [CommonModule, NglFormsModule, NglInternalOutletModule]; }, exports: function () { return [NglSelect, NglSelectInput]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglSlider, [{
        type: Component,
        args: [{
                selector: 'ngl-slider',
                template: "\n<label class=\"slds-form-element__label\" [attr.for]=\"uid\"><span class=\"slds-slider-label\"><span class=\"slds-slider-label__label\" *ngIf=\"label\" [nglInternalOutlet]=\"label\"></span><span class=\"slds-slider-label__range\">{{min}} - {{max}}</span></span></label>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-slider\" [ngClass]=\"sliderClass()\">\n    <input class=\"slds-slider__range\" [id]=\"uid\" type=\"range\" [value]=\"value\" [min]=\"min\" [max]=\"max\" [step]=\"step\" [disabled]=\"disabled\" [attr.aria-describedby]=\"hasError ? uid + '-error' : null\" (input)=\"onInput($event.target.value)\"><span class=\"slds-slider__value\" aria-hidden=\"true\">{{value}}</span>\n  </div>\n  <div class=\"slds-form-element__help\" *ngIf=\"hasError\" [id]=\"uid + '-error'\" [nglInternalOutlet]=\"error\"></div>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [NGL_SLIDER_VALUE_ACCESSOR]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, { min: [{
            type: Input
        }], max: [{
            type: Input
        }], step: [{
            type: Input
        }], vertical: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], hasError: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }], value: [{
            type: Input
        }], disabled: [{
            type: Input
        }], label: [{
            type: Input
        }], size: [{
            type: Input
        }], error: [{
            type: Input
        }] }); })();

class NglSliderModule {
}
NglSliderModule.ɵfac = function NglSliderModule_Factory(t) { return new (t || NglSliderModule)(); };
NglSliderModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglSliderModule });
NglSliderModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglInternalOutletModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglSliderModule, [{
        type: NgModule,
        args: [{
                declarations: [NglSlider],
                exports: [NglSlider],
                imports: [CommonModule, NglInternalOutletModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglSliderModule, { declarations: function () { return [NglSlider]; }, imports: function () { return [CommonModule, NglInternalOutletModule]; }, exports: function () { return [NglSlider]; } }); })();

class NglSpinner {
    constructor(element, renderer, hostService) {
        this.element = element;
        this.renderer = renderer;
        this.hostService = hostService;
        this.renderer.addClass(this.element.nativeElement, 'slds-spinner');
        this.renderer.setAttribute(this.element.nativeElement, 'role', 'status');
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    setHostClass() {
        this.hostService.updateClass(this.element, {
            [`slds-spinner_${this.size || 'medium'}`]: true,
            [`slds-spinner_${this.variant}`]: !!this.variant,
        });
    }
}
NglSpinner.ɵfac = function NglSpinner_Factory(t) { return new (t || NglSpinner)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(HostService)); };
NglSpinner.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglSpinner, selectors: [["ngl-spinner"]], inputs: { size: "size", variant: "variant", alternativeText: "alternativeText" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 3, vars: 1, consts: [["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-spinner__dot-a"], [1, "slds-spinner__dot-b"], [1, "slds-assistive-text"]], template: function NglSpinner_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglSpinner_span_0_Template, 2, 1, "span", 0);
        ɵngcc0.ɵɵelement(1, "div", 1);
        ɵngcc0.ɵɵelement(2, "div", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.alternativeText);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
NglSpinner.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService }
];
NglSpinner.propDecorators = {
    size: [{ type: Input }],
    variant: [{ type: Input }],
    alternativeText: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglSpinner, [{
        type: Component,
        args: [{
                selector: 'ngl-spinner',
                template: "<span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{ alternativeText }}</span>\n<div class=\"slds-spinner__dot-a\"></div>\n<div class=\"slds-spinner__dot-b\"></div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: HostService }]; }, { size: [{
            type: Input
        }], variant: [{
            type: Input
        }], alternativeText: [{
            type: Input
        }] }); })();

class NglSpinnersModule {
}
NglSpinnersModule.ɵfac = function NglSpinnersModule_Factory(t) { return new (t || NglSpinnersModule)(); };
NglSpinnersModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglSpinnersModule });
NglSpinnersModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglSpinnersModule, [{
        type: NgModule,
        args: [{
                declarations: [NglSpinner],
                exports: [NglSpinner],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglSpinnersModule, { declarations: function () { return [NglSpinner]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglSpinner]; } }); })();

class NglTextareaInput {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.ɵRequiredSubject = new BehaviorSubject(false);
        if (!this.el.nativeElement.id) {
            this.renderer.setAttribute(this.el.nativeElement, 'id', uniqueId('textarea'));
        }
    }
    set required(required) {
        this.ɵRequiredSubject.next(toBoolean(required));
    }
    get id() {
        return this.el.nativeElement.id;
    }
}
NglTextareaInput.ɵfac = function NglTextareaInput_Factory(t) { return new (t || NglTextareaInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglTextareaInput.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NglTextareaInput, selectors: [["textarea", "ngl", ""]], hostVars: 3, hostBindings: function NglTextareaInput_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-describedby", ctx.describedBy);
        ɵngcc0.ɵɵclassProp("slds-textarea", true);
    } }, inputs: { required: "required" } });
NglTextareaInput.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NglTextareaInput.propDecorators = {
    describedBy: [{ type: HostBinding, args: ['attr.aria-describedby',] }],
    required: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglTextareaInput, [{
        type: Directive,
        args: [{
                selector: 'textarea[ngl]',
                host: {
                    '[class.slds-textarea]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { required: [{
            type: Input
        }], describedBy: [{
            type: HostBinding,
            args: ['attr.aria-describedby']
        }] }); })();

class NglTextarea {
    constructor(cd) {
        this.cd = cd;
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this._uid}`;
    }
    ngOnChanges() {
        this.input.describedBy = this.error ? this.errorId : null;
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <textarea> with [ngl] attribute inside ngl-textarea`);
        }
        this.ɵRequiredSubscription = this.input.ɵRequiredSubject.subscribe((required) => {
            this.required = required;
            this.cd.detectChanges();
        });
        this._uid = this.input.id;
        this.cd.detectChanges();
    }
    ngOnDestroy() {
        if (this.ɵRequiredSubscription) {
            this.ɵRequiredSubscription.unsubscribe();
            this.ɵRequiredSubscription = null;
        }
    }
}
NglTextarea.ɵfac = function NglTextarea_Factory(t) { return new (t || NglTextarea)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglTextarea.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NglTextarea, selectors: [["ngl-textarea"], ["", "ngl-textarea", ""]], contentQueries: function NglTextarea_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglTextareaInput, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 4, hostBindings: function NglTextarea_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-form-element", true)("slds-has-error", ctx.hasError);
    } }, inputs: { label: "label", fieldLevelHelpTooltip: "fieldLevelHelpTooltip", error: "error" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 6, vars: 5, consts: [[3, "nglFormLabel", "required"], [3, "content", 4, "ngIf"], [1, "slds-form-element__control"], [1, "slds-textarea_container"], ["class", "slds-form-element__help", 3, "id", 4, "ngIf"], [3, "content"], [1, "slds-form-element__help", 3, "id"]], template: function NglTextarea_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelement(0, "label", 0);
        ɵngcc0.ɵɵtemplate(1, NglTextarea_ngl_form_help_1_Template, 1, 1, "ngl-form-help", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, NglTextarea_div_5_Template, 2, 2, "div", 4);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("nglFormLabel", ctx.label)("required", ctx.required);
        ɵngcc0.ɵɵattribute("for", ctx._uid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.fieldLevelHelpTooltip);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.error);
    } }, directives: [NglFormLabel, ɵngcc1.NgIf, NglFormHelp], encapsulation: 2, changeDetection: 0 });
NglTextarea.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NglTextarea.propDecorators = {
    input: [{ type: ContentChild, args: [NglTextareaInput, { static: true },] }],
    label: [{ type: Input }],
    fieldLevelHelpTooltip: [{ type: Input }],
    error: [{ type: Input }],
    hasError: [{ type: HostBinding, args: ['class.slds-has-error',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglTextarea, [{
        type: Component,
        args: [{
                selector: 'ngl-textarea,[ngl-textarea]',
                template: "\n<label [nglFormLabel]=\"label\" [attr.for]=\"_uid\" [required]=\"required\"></label>\n<ngl-form-help *ngIf=\"fieldLevelHelpTooltip\" [content]=\"fieldLevelHelpTooltip\"></ngl-form-help>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-textarea_container\">\n    <ng-content></ng-content>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"error\" [id]=\"errorId\">{{error}}</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-form-element]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { hasError: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }], input: [{
            type: ContentChild,
            args: [NglTextareaInput, { static: true }]
        }], label: [{
            type: Input
        }], fieldLevelHelpTooltip: [{
            type: Input
        }], error: [{
            type: Input
        }] }); })();

const DIRECTIVES = [
    NglTextarea,
    NglTextareaInput,
];
class NglTextareaModule {
}
NglTextareaModule.ɵfac = function NglTextareaModule_Factory(t) { return new (t || NglTextareaModule)(); };
NglTextareaModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglTextareaModule });
NglTextareaModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NglFormsModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglTextareaModule, [{
        type: NgModule,
        args: [{
                declarations: DIRECTIVES,
                exports: DIRECTIVES,
                imports: [CommonModule, NglFormsModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglTextareaModule, { declarations: function () { return [NglTextarea, NglTextareaInput]; }, imports: function () { return [CommonModule, NglFormsModule]; }, exports: function () { return [NglTextarea, NglTextareaInput]; } }); })();

const MODULES = [
    NglAccordionModule,
    NglAlertModule,
    NglAvatarModule,
    NglBadgesModule,
    NglBreadcrumbsModule,
    NglButtonIconsModule,
    NglButtonsModule,
    NglCarouselModule,
    NglCheckboxesModule,
    NglColorpickerModule,
    NglComboboxesModule,
    NglDatatablesModule,
    NglDatepickersModule,
    NglDynamicIconsModule,
    NglFilesModule,
    NglFileUploadModule,
    NglIconsModule,
    NglInputModule,
    NglMenusModule,
    NglModalsModule,
    NglToastModule,
    NglPaginationsModule,
    NglPickModule,
    NglPillsModule,
    NglPopoversModule,
    NglProgressBarModule,
    NglRadiosModule,
    NglRatingsModule,
    NglSectionsModule,
    NglSelectModule,
    NglSliderModule,
    NglSpinnersModule,
    NglTabsModule,
    NglTextareaModule,
    NglTooltipsModule,
];
class NglModule {
}
NglModule.ɵfac = function NglModule_Factory(t) { return new (t || NglModule)(); };
NglModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NglModule });
NglModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [NglAccordionModule, NglAlertModule, NglAvatarModule, NglBadgesModule, NglBreadcrumbsModule, NglButtonIconsModule, NglButtonsModule, NglCarouselModule, NglCheckboxesModule, NglColorpickerModule, NglComboboxesModule, NglDatatablesModule, NglDatepickersModule, NglDynamicIconsModule, NglFilesModule, NglFileUploadModule, NglIconsModule, NglInputModule, NglMenusModule, NglModalsModule, NglToastModule, NglPaginationsModule, NglPickModule, NglPillsModule, NglPopoversModule, NglProgressBarModule, NglRadiosModule, NglRatingsModule, NglSectionsModule, NglSelectModule, NglSliderModule, NglSpinnersModule, NglTabsModule, NglTextareaModule, NglTooltipsModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NglModule, [{
        type: NgModule,
        args: [{
                exports: MODULES
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglModule, { exports: [NglAccordionModule, NglAlertModule, NglAvatarModule, NglBadgesModule, NglBreadcrumbsModule, NglButtonIconsModule, NglButtonsModule, NglCarouselModule, NglCheckboxesModule, NglColorpickerModule, NglComboboxesModule, NglDatatablesModule, NglDatepickersModule, NglDynamicIconsModule, NglFilesModule, NglFileUploadModule, NglIconsModule, NglInputModule, NglMenusModule, NglModalsModule, NglToastModule, NglPaginationsModule, NglPickModule, NglPillsModule, NglPopoversModule, NglProgressBarModule, NglRadiosModule, NglRatingsModule, NglSectionsModule, NglSelectModule, NglSliderModule, NglSpinnersModule, NglTabsModule, NglTextareaModule, NglTooltipsModule] }); })();

/*
 * Public API Surface of ng-lightning
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NGL_COLORPICKER_CONFIG, NGL_DATEPICKER_CONFIG, NGL_ICON_CONFIG, NGL_RATING_CONFIG, NGL_TOOLTIP_CONFIG, NglAccordion, NglAccordionModule, NglAccordionSection, NglAlert, NglAlertClose, NglAlertModule, NglAvatar, NglAvatarModule, NglBadge, NglBadgesModule, NglBreadcrumb, NglBreadcrumbs, NglBreadcrumbsModule, NglButton, NglButtonIcon, NglButtonIconStateful, NglButtonIconsModule, NglButtonStateHover, NglButtonStateOff, NglButtonStateOn, NglButtonStateful, NglButtonsModule, NglCarousel, NglCarouselImage, NglCarouselModule, NglCheckbox, NglCheckboxButton, NglCheckboxGroup, NglCheckboxInput, NglCheckboxOption, NglCheckboxToggle, NglCheckboxesModule, NglColorpicker, NglColorpickerConfig, NglColorpickerModule, NglCombobox, NglComboboxInput, NglComboboxOption, NglComboboxesModule, NglDatatable, NglDatatableCell, NglDatatableColumn, NglDatatableHeadingTemplate, NglDatatableLoadingOverlay, NglDatatableNoRowsOverlay, NglDatatablesModule, NglDatepicker, NglDatepickerConfig, NglDatepickerInput, NglDatepickerInputDirective, NglDatepickersModule, NglDropdown, NglDropdownItem, NglDropdownTrigger, NglDynamicIcon, NglDynamicIconEllie, NglDynamicIconEq, NglDynamicIconScore, NglDynamicIconWaffle, NglDynamicIconsModule, NglExpandableSection, NglFile, NglFileCrop, NglFileUpload, NglFileUploadModule, NglFilesModule, NglIcon, NglIconConfig, NglIconSvg, NglIconsModule, NglInput, NglInputElement, NglInputModule, NglMenusModule, NglModal, NglModalFooterTemplate, NglModalHeaderTemplate, NglModalTaglineTemplate, NglModalsModule, NglModule, NglPagination, NglPaginationsModule, NglPick, NglPickModule, NglPickOption, NglPill, NglPillLink, NglPillsModule, NglPopover, NglPopoverTrigger, NglPopoversModule, NglProgressBar, NglProgressBarModule, NglRadioGroup, NglRadioInput, NglRadioOption, NglRadiosModule, NglRating, NglRatingConfig, NglRatingIconTemplate, NglRatingsModule, NglSectionsModule, NglSelect, NglSelectInput, NglSelectModule, NglSlider, NglSliderModule, NglSpinner, NglSpinnersModule, NglTab, NglTabContent, NglTabLabel, NglTabVerbose, NglTabs, NglTabsModule, NglTextarea, NglTextareaInput, NglTextareaModule, NglToast, NglToastClose, NglToastModule, NglTooltipConfig, NglTooltipTrigger, NglTooltipsModule, InputBoolean as ɵa, InputNumber as ɵb, NglInternalDatatableHeadCell as ɵba, NglInternalDatatableCell as ɵbb, NglDatepickerMonth as ɵbc, NglDay as ɵbd, NglDateAdapter as ɵbe, NglDateAdapterBase as ɵbf, NglDatepickerWeekdays as ɵbg, NglDatepickerYear as ɵbh, NglClickOutsideModule as ɵbi, NglClickOutsideDirective as ɵbj, BaseDynamicIconComponent as ɵbk, NglAccordionItem as ɵc, HostService as ɵd, NglInternalOutletModule as ɵe, NglInternalOutlet as ɵf, NglCommonNotify as ɵg, NglCommonNotifyClose as ɵh, NglCarouselIndicator as ɵi, NglColorpickerSwatch as ɵj, NglColorpickerCustom as ɵk, NglColorpickerRange as ɵl, NglColorpickerInputs as ɵm, NglColorpickerSwatches as ɵn, NglColorpickerSwatchTrigger as ɵo, OnChange as ɵp, hasObservers as ɵq, NglFormsModule as ɵr, NglFormLabel as ɵs, NglFormHelp as ɵt, NglTooltip as ɵu, NglComboboxService as ɵv, NGL_COMBOBOX_CONFIG as ɵw, NglComboboxConfig as ɵx, NglOverlayModule as ɵy, NglOverlaynglOverlayScrolledOutsideViewDirective as ɵz };

//# sourceMappingURL=ng-lightning.js.map